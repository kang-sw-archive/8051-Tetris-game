

       MCS-51 Family Macro Assembler   A S E M - 5 1   V 1.3
       =====================================================



        Source File:    core.asm
        Object File:    bin\core.hex
        List File:      bin\core.lst



 Line  I  Addr  Code            Source

    1:                          $ NOPAGING DEBUG NOTABS
    2:                          ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    3:                          ;
    4:                          ;             ** MULTIPLE GAME PLATFORM      **
    5:                          ;             ** MICROPROCESSOR I FINAL TASK **
    6:                          ;
    7:                          ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    8:                          ;       PROGRAM DESCRIPTION
    9:                          ; ...
   10:                          ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   11:                          ;       FILE DESCRIPTION
   12:                          ; This file is the topmost asm file which provides definitions
   13:                          ;  and locations of memory segments, logic elements, etc.
   14:                          ; The overall program is consist of lots of submodules defined
   15:                          ;  in inc files. The communication between submodules are controled
   16:                          ;  by this core file.
   17:                          ; Since the Macro Assembler 51 doesn't provide linking through
   18:                          ;  multiple source files, every submodule should be wrote on inc file
   19:                          ;  and be included in somewhere.
   20:                          ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   21:                          ;       RULES
   22:                          ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   23:                          ;       SYSTEMIC MACROS
   24:                          ; This area defines several macros which should be included on each
   25:                          ;  inc files to prevent multiple inclusion.
   26:                          ; --------------------------------------------------------------------
   27:                          ;* Every single inc file have to instanciate this macro via its name.
   28:                          ;  These macros prevent duplicated inclusion of every single inc files
   29:                          ;  therefore enables to keep label definitions unique.
   30:                          DEFINE_MODULE MACRO     MODULENAME
   31:                                  IFN     ____&MODULENAME
   32:                          ____&MODULENAME         SET     1
   33:                                  ENDM
   34:                          ;* This macro should be defined for each inc files.
   35:                          DECLARE_MODULE MACRO    MODULENAME
   36:                          ;; To prevent multiple instanciation of this macro ...
   37:                          ____&MODULENAME&_DEF    EQU     0
   38:                          ____&MODULENAME SET     0
   39:                                  ENDM
   40:                          ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   41:                          $INCLUDE        (_MEMORY.INC)
   42: 1
   43: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   44: 1                        ;       MEMORY LOCATION DEFINITIONS
   45: 1                        ; This area is consist of overall memory allocation and pre-definition
   46: 1                        ; $ Stack begins at last position of external memory offset.
   47: 1                        ; --------------------------------------------------------------------
   48: 1                        ; Global/internal memory helper macro.
   49: 1                        ;
   50: 1                        ; By using following macros, the offset and location of memories are
   51: 1                        ;  can be easily managed by identifier. Operation principle is simeple-
   52: 1                        ;  just declare a global data identifier with its offset, then internal
   53: 1                        ;  HEAD which pointing current usable memory address will define that
   54: 1                        ;  identifier as current HEAD location, and will be move forward for
   55: 1                        ;  the amount of given size. You can use this macro like-
   56: 1                        ;       GLBMEM SOME_DAT_ID, 4
   57: 1                        ;       LOCMEM SOME_DAT_ID, 35
   58: 1                        ;       LOCMEM_PVT ; This macro will reset local memory assignement
   59: 1                        ;                 to 2000h. Should be used on situation which are
   60: 1                        ;                 perfectly independent and separted so that the
   61: 1                        ;                 given memories are asured to never be used at
   62: 1                        ;                 the same time.
   63: 1                        ;       INTMEM SOME_DAT_ID, 3; This macro will assign given id on
   64: 1                        ;                       internal memory location from 30H~,
   65: 1                        ;                       and all the rest of internal memory
   66: 1                        ;                       are for stack.
   67: 1                        ;       GBIT SOME_BIT_FLAG;     This macro will assign a bit flag from
   68: 1                        ;                        2FH.7 ~ 28H.0. Since the memories from
   69: 1                        ;                        20H to 27H is used as bit-referenceable
   70: 1                        ;                        registers as an identifer of 'BR0 ~ BR7',
   71: 1                        ;                        the number of GBIT and LBIT should be
   72: 1                        ;                        less than 128.
   73: 1                        ;       LBIT ID; This is same with the relationship between GLBMEM
   74: 1                        ;                 and LOCMEM
   75: 1                        ;       LBIT_PVT
   76: 1                        ;
   77: 1                        ; To ensure valid operation on specific cases(for example, when you
   78: 1                        ;  have to avoid any carry occured to DPH while incrementing DPL),
   79: 1                        ;  a alignment macro is provided. When you call this macro with
   80: 1                        ;  alignment offset and HEAD identifier, the HEAD will be aligned
   81: 1                        ;  on given memory offset. Like-
   82: 1                        ;       MEMALIGN GLOBAL_MEMORY, 100H    ; Align global memory by
   83: 1                        ;                                  100H byte boundary
   84: 1                        ;       MEMALIGN LOCAL_MEMORY, 20H      ; Align local memory by
   85: 1                        ;                                  20H byte boundary
   86: 1                        ; --------------------------------------------------------------------
   87: 1
   88: 1                        ; MEMALIGN
   89: 1                        ;       GLOBAL_MEMORY
   90: 1                        ;       LOCAL_MEMORY
   91: 1
   92: 1                        ; GLBMEM(ID, SIZE)
   93: 1                        ; GLBMEMAT(ID, SIZE, LOCATION)
   94: 1                        ; LOCMEM(ID, SIZE)
   95: 1                        ; GBIT(ID)
   96: 1
   97: 1                        ; LBIT_PVT()
   98: 1                        ; LBIT(ID)
   99: 1                        ; ==> GLOBAL MEMORY ASSIGNMENT
  100: 1        N      1000     GLOBAL_MEMORY   SET     1000H
  101: 1
  102: 1                        GLBMEM  MACRO   ID, SIZE
  103: 1                        ID      EQU     GLOBAL_MEMORY
  104: 1                        GLOBAL_MEMORY   SET     GLOBAL_MEMORY+SIZE
  105: 1                        IF      GLOBAL_MEMORY>=2000H
  106: 1                        $ERROR  ("GLOBAL MEMORY OVERFLOW")
  107: 1                        ENDIF
  108: 1                        ENDM
  109: 1
  110: 1                        GLBMEMAT        MACRO   ID, SIZE, LOC
  111: 1                        IF      LOC<GLOBAL_MEMORY
  112: 1                        $ERROR  ("INVALID GLOBAL MEMORY OFFSET")
  113: 1                        ENDIF
  114: 1                        ID      EQU     LOC
  115: 1                        GLOBAL_MEMORY   SET     LOC+SIZE
  116: 1                        ENDM
  117: 1
  118: 1                        ; ==> EXTERNAL MEMORY MANAGEMENT
  119: 1        N      2000     LOCAL_MEMORY SET        2000H
  120: 1
  121: 1                        LOCMEM_PVT      MACRO
  122: 1                        LOCAL_MEMORY SET        2000H
  123: 1                        ENDM
  124: 1
  125: 1                        LOCMEM  MACRO   ID, SIZE
  126: 1                        ID      SET     LOCAL_MEMORY
  127: 1                        LOCAL_MEMORY SET        LOCAL_MEMORY+SIZE
  128: 1                        IF      LOCAL_MEMORY>=4000H
  129: 1                        $ERROR  ("EXTERNAL MEMORY OVERFLOW")
  130: 1                        ENDIF
  131: 1                        ENDM
  132: 1
  133: 1                        ; ==> INTERNAL MEMORY ASSIGNMENT
  134: 1        N      0030     __INT_OFST      SET     30H
  135: 1
  136: 1                        INTMEM  MACRO   ID, SIZE
  137: 1                                LOCAL   ADDR
  138: 1                        ADDR:
  139: 1                        IF      ADDR>=4000H
  140: 1                        $ERROR  ("INTMEM declaration should precede code segment.")
  141: 1                        ENDIF
  142: 1                        ID      EQU     __INT_OFST
  143: 1                        __INT_OFST      SET     __INT_OFST+SIZE
  144: 1                        ENDM
  145: 1
  146: 1                        ; ==> INTERNAL BIT DATA ASSIGNEMENT
  147: 1        N      007F     __INTB_OFST     SET     07FH
  148: 1
  149: 1                        GBIT    MACRO   ID
  150: 1                                LOCAL   ADDR
  151: 1                        ADDR:
  152: 1                        IF      ADDR>=4000H
  153: 1                        $ERROR  ("GBIT declaration should precede code segment.")
  154: 1                        ENDIF
  155: 1                        ID      EQU     __INTB_OFST
  156: 1                        __INTB_OFST     SET     __INTB_OFST-1
  157: 1                        ENDM
  158: 1
  159: 1                        ; ==> LOCAL BIT DATA ASSIGNMENT
  160: 1                        LBIT_PVT        MACRO
  161: 1                                LOCAL   ADDR
  162: 1                        ADDR:
  163: 1                        IF      ADDR < 4000H
  164: 1                        $ERROR  ("LBIT should be placed after code segment.")
  165: 1                        ENDIF
  166: 1                        __LB_PIVOT      SET     __INTB_OFST
  167: 1                        ENDM
  168: 1
  169: 1                        LBIT    MACRO   ID
  170: 1                        ID      SET     __LB_PIVOT
  171: 1                        __LB_PIVOT      SET     __LB_PIVOT -1
  172: 1                        ENDM
  173: 1
  174: 1                        ; ==> These macro helps align data by data boundary
  175: 1                        MEMALIGN        MACRO   HEAD, ALIGN
  176: 1                        HEAD    SET     ((HEAD+(ALIGN-1))/ALIGN)*ALIGN
  177: 1                        ENDM
  178: 1
  179: 1                        ; ==> CONSTANT
  180: 1                        CONST   MACRO   ID, VALUE
  181: 1                        ID      EQU     VALUE
  182: 1                        ENDM
  183: 1
  184: 1                        ; ==> PORT DEFINITION
  185: 1        N      8000     LCDPORT EQU     8000H
  186: 1        N      C000     OUTPUTPORT      EQU     0C000H
  187: 1        N      C000     INPUTPORT       EQU     0C000H
  188: 1                        ; ####################################################################
  189: 1                        ; ####################################################################
  190: 1                        ; ####################################################################
  191: 1                        ; ##################  MEMORY ALLOCATION  #############################
  192: 1                        ; ####################################################################
  193: 1                        ; ####################################################################
  194: 1                        ; ####################################################################
  195: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  196: 1                        ; --------------------------------------------------------------------
  197: 1                        ; TYPE     |IDENTIFIER |SIZE/DESCRIPTION
  198: 1                        ; ---------|-----------|----------------------------------------------
  199: 1                        GLBMEMAT        GBUFFER1,       100H, 1000H;.2nd graphics buffer
  200+ 2        N      0000     IF      1000H<GLOBAL_MEMORY
  201+ 2                        $ERROR  ("INVALID GLOBAL MEMORY OFFSET")
  202+ 2                        ENDIF
  203+ 2        N      1000     GBUFFER1        EQU     1000H
  204+ 2        N      1100     GLOBAL_MEMORY   SET     1000H+100H
  205: 1                        GLBMEMAT        GBUFFER2,       100H, 1100H;.2nd graphics buffer
  206+ 2        N      0000     IF      1100H<GLOBAL_MEMORY
  207+ 2                        $ERROR  ("INVALID GLOBAL MEMORY OFFSET")
  208+ 2                        ENDIF
  209+ 2        N      1100     GBUFFER2        EQU     1100H
  210+ 2        N      1200     GLOBAL_MEMORY   SET     1100H+100H
  211: 1                        GBIT    CURBUFF;        .A flag notices which
  212+ 2  0000                  ??0000:
  213+ 2        N      0000     IF      ??0000>=4000H
  214+ 2                        $ERROR  ("GBIT declaration should precede code segment.")
  215+ 2                        ENDIF
  216+ 2        N      007F     CURBUFF EQU     __INTB_OFST
  217+ 2        N      007E     __INTB_OFST     SET     __INTB_OFST-1
  218: 1                                        ; buffer is idle now. If this flag indicates
  219: 1                                        ; 1, then the gameplay loop can call draw
  220: 1                                        ; operations targetting GBUFFER1.
  221: 1                        GBIT    FRAMEBOUND60; .A flag which notices
  222+ 2  0000                  ??0001:
  223+ 2        N      0000     IF      ??0001>=4000H
  224+ 2                        $ERROR  ("GBIT declaration should precede code segment.")
  225+ 2                        ENDIF
  226+ 2        N      007E     FRAMEBOUND60    EQU     __INTB_OFST
  227+ 2        N      007D     __INTB_OFST     SET     __INTB_OFST-1
  228: 1                                        ; a framerate boundary, which will be set per 16 ms.
  229: 1                        GBIT    FRAMEBOUND30; .30FPS BOUNDARY
  230+ 2  0000                  ??0002:
  231+ 2        N      0000     IF      ??0002>=4000H
  232+ 2                        $ERROR  ("GBIT declaration should precede code segment.")
  233+ 2                        ENDIF
  234+ 2        N      007D     FRAMEBOUND30    EQU     __INTB_OFST
  235+ 2        N      007C     __INTB_OFST     SET     __INTB_OFST-1
  236: 1
  237: 1                        ;GBIT   SPK_1;  .Flags which drive
  238: 1                        ;GBIT   SPK_2;  .extern speaker.
  239: 1                                        ; These will be bound into NAND gate with SPK
  240: 1                                        ; Enable signal, therefore can mute the
  241: 1                                        ; speaker.
  242: 1
  243: 1                        ;CONST  SPKEN, LCDPORT; .D4 and D5 bit will
  244: 1                                        ; be used to indicate the speaker enable
  245: 1                                        ; signal.
  246: 1
  247: 1                        ;INTMEM SPK_HZ1,        1;      .These bytes indicate
  248: 1                        ;INTMEM SPK_HZ2,        1;      .the counts left until
  249: 1                                        ; the timer inturruption routine would flip
  250: 1                                        ; the SPK output.
  251: 1
  252: 1                        ;INTMEM SPK_LD1,        1;
  253: 1                        ;INTMEM SPK_LD2,        1;      .These bytes indicate
  254: 1                                        ; the counts which will be reloaded onto
  255: 1                                        ; SPK_HZ register when the output flipping
  256: 1                                        ; occurs.
  257: 1
  258: 1        D      008B     RANDNUM SET     TL1
  259: 1                        INTMEM  CS_INPUTPR,     2;      .CALLBACKS
  260+ 2  0000                  ??0003:
  261+ 2        N      0000     IF      ??0003>=4000H
  262+ 2                        $ERROR  ("INTMEM declaration should precede code segment.")
  263+ 2                        ENDIF
  264+ 2        N      0030     CS_INPUTPR      EQU     __INT_OFST
  265+ 2        N      0032     __INT_OFST      SET     __INT_OFST+2
  266: 1                        INTMEM  CS_UPDATE,      2;
  267+ 2  0000                  ??0004:
  268+ 2        N      0000     IF      ??0004>=4000H
  269+ 2                        $ERROR  ("INTMEM declaration should precede code segment.")
  270+ 2                        ENDIF
  271+ 2        N      0032     CS_UPDATE       EQU     __INT_OFST
  272+ 2        N      0034     __INT_OFST      SET     __INT_OFST+2
  273: 1                        INTMEM  CS_DRAW,        2;
  274+ 2  0000                  ??0005:
  275+ 2        N      0000     IF      ??0005>=4000H
  276+ 2                        $ERROR  ("INTMEM declaration should precede code segment.")
  277+ 2                        ENDIF
  278+ 2        N      0034     CS_DRAW EQU     __INT_OFST
  279+ 2        N      0036     __INT_OFST      SET     __INT_OFST+2
  280: 1
  281: 1                        INTMEM  GLB_P2CACHE,1;  .The global byte location
  282+ 2  0000                  ??0006:
  283+ 2        N      0000     IF      ??0006>=4000H
  284+ 2                        $ERROR  ("INTMEM declaration should precede code segment.")
  285+ 2                        ENDIF
  286+ 2        N      0036     GLB_P2CACHE     EQU     __INT_OFST
  287+ 2        N      0037     __INT_OFST      SET     __INT_OFST+1
  288: 1                                        ; which is used for caching P2 value, this exists
  289: 1                                        ; to protect P2 value while interrupt subroutine.
  290: 1
  291: 1                        INTMEM  PREV_INPUT, 1;  .Will be used on input preprocessor.
  292+ 2  0000                  ??0007:
  293+ 2        N      0000     IF      ??0007>=4000H
  294+ 2                        $ERROR  ("INTMEM declaration should precede code segment.")
  295+ 2                        ENDIF
  296+ 2        N      0037     PREV_INPUT      EQU     __INT_OFST
  297+ 2        N      0038     __INT_OFST      SET     __INT_OFST+1
  298: 1
  299: 1                        MEMALIGN        GLOBAL_MEMORY, 20H
  300+ 2        N      1200     GLOBAL_MEMORY   SET     ((GLOBAL_MEMORY+(20H-1))/20H)*20H
  301: 1                        GLBMEM  TCNT, 8;                .Timer memory allocation.
  302+ 2        N      1200     TCNT    EQU     GLOBAL_MEMORY
  303+ 2        N      1208     GLOBAL_MEMORY   SET     GLOBAL_MEMORY+8
  304+ 2        N      0000     IF      GLOBAL_MEMORY>=2000H
  305+ 2                        $ERROR  ("GLOBAL MEMORY OVERFLOW")
  306+ 2                        ENDIF
  307: 1                        GLBMEM  TCALBAKOFST, 2
  308+ 2        N      1208     TCALBAKOFST     EQU     GLOBAL_MEMORY
  309+ 2        N      120A     GLOBAL_MEMORY   SET     GLOBAL_MEMORY+2
  310+ 2        N      0000     IF      GLOBAL_MEMORY>=2000H
  311+ 2                        $ERROR  ("GLOBAL MEMORY OVERFLOW")
  312+ 2                        ENDIF
  313: 1
  314: 1                        GLBMEM  RANKING_RETURN, 2;      .At the end of any game session,
  315+ 2        N      120A     RANKING_RETURN  EQU     GLOBAL_MEMORY
  316+ 2        N      120C     GLOBAL_MEMORY   SET     GLOBAL_MEMORY+2
  317+ 2        N      0000     IF      GLOBAL_MEMORY>=2000H
  318+ 2                        $ERROR  ("GLOBAL MEMORY OVERFLOW")
  319+ 2                        ENDIF
  320: 1                                        ;  the program will ask player's name and will
  321: 1                                        ;  record it into SCORE_GAMENAME. Any game ending
  322: 1                                        ;  will cache the returning session after
  323: 1                                        ;  recording and score recorded in 4 digit BCD
  324: 1                                        ;  which was calculated in the session's own.
  325: 1                                        ; Then it transite into recording session.
  326: 1                                        ; On the recording session, the session will
  327: 1                                        ;  take player's name and read game informations
  328: 1                                        ;  from SCORECACHE_GAME, SCORECACHE_SCORE_BCD
  329: 1                                        ;  and record it to the game's own memory space.
  330: 1
  331: 1                        GBIT    RANKING_RECORDEN; .Determines whether record score to
  332+ 2  0000                  ??0008:
  333+ 2        N      0000     IF      ??0008>=4000H
  334+ 2                        $ERROR  ("GBIT declaration should precede code segment.")
  335+ 2                        ENDIF
  336+ 2        N      007C     RANKING_RECORDEN        EQU     __INTB_OFST
  337+ 2        N      007B     __INTB_OFST     SET     __INTB_OFST-1
  338: 1                                        ;  ranking or not.
  339: 1                        MEMALIGN        GLOBAL_MEMORY, 20H
  340+ 2        N      1220     GLOBAL_MEMORY   SET     ((GLOBAL_MEMORY+(20H-1))/20H)*20H
  341: 1                        GLBMEM  RANKING_GAMEINFO, 1;
  342+ 2        N      1220     RANKING_GAMEINFO        EQU     GLOBAL_MEMORY
  343+ 2        N      1221     GLOBAL_MEMORY   SET     GLOBAL_MEMORY+1
  344+ 2        N      0000     IF      GLOBAL_MEMORY>=2000H
  345+ 2                        $ERROR  ("GLOBAL MEMORY OVERFLOW")
  346+ 2                        ENDIF
  347: 1                        GLBMEM  RANKING_SCORE, 4;
  348+ 2        N      1221     RANKING_SCORE   EQU     GLOBAL_MEMORY
  349+ 2        N      1225     GLOBAL_MEMORY   SET     GLOBAL_MEMORY+4
  350+ 2        N      0000     IF      GLOBAL_MEMORY>=2000H
  351+ 2                        $ERROR  ("GLOBAL MEMORY OVERFLOW")
  352+ 2                        ENDIF
  353: 1
  354: 1                        ; SCORES = TETRIS, SCORES + 4 = JIRUNG, SCORES + 8 = ?
  355: 1                        GLBMEM  RANKING_HIGHST, 12
  356+ 2        N      1225     RANKING_HIGHST  EQU     GLOBAL_MEMORY
  357+ 2        N      1231     GLOBAL_MEMORY   SET     GLOBAL_MEMORY+12
  358+ 2        N      0000     IF      GLOBAL_MEMORY>=2000H
  359+ 2                        $ERROR  ("GLOBAL MEMORY OVERFLOW")
  360+ 2                        ENDIF
  361: 1        B      0092     ERRORBIT        EQU     P1.2
  362: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  363: 1                        ; --------------------------------------------------------------------
  364: 1                        ;       CONSTANT IDENTIFIERS
  365: 1                        ; IDENTIFIER    VALUE   DESCRIPTION
  366: 1                        ; ---------------------|-----------|----------------------------------
  367: 1        N      0020     BR0     EQU     20H     ; Usable bit-refrence registers...
  368: 1        N      0021     BR1     EQU     21H
  369: 1        N      0022     BR2     EQU     22H
  370: 1        N      0023     BR3     EQU     23H
  371: 1        N      0024     BR4     EQU     24H
  372: 1        N      0025     BR5     EQU     25H
  373: 1        N      0026     BR6     EQU     26H
  374: 1        N      0027     BR7     EQU     27H
  375: 1
  376: 1        N      0000     DBGBANK EQU     00H;
  377: 1        N      0008     GPUBANK EQU     08H;    register bank used in Graphics
  378: 1                                        ; processing sequence.
  379: 1        N      0010     GAMEBANK        EQU     10H;    register bank used in gameplay
  380: 1                                        ; update procedure.
  381: 1        N      0018     BANK2   EQU     18H;    temporary banks which can be used
  382: 1                        ;BANK3  EQU     18H; in primitive functions.
  383: 1
  384: 1        N      0018     _SSN_BANK       EQU     18H;    register bank used in session
  385: 1        N      C43B     _FRAME  EQU     0C43BH; C43BH = 60FPS, 881DH = 30FPS
  386: 1
  387: 1        N      0001     BTN0    EQU     01H
  388: 1        N      0002     BTN1    EQU     02H
  389: 1        N      0004     BTN2    EQU     04H
  390: 1        N      0008     BTN3    EQU     08H
  391: 1        N      0010     BTN4    EQU     10H
  392: 1        N      0020     BTN5    EQU     20H
  393: 1        N      0040     BTN6    EQU     40H
  394: 1        N      0080     BTN7    EQU     80H
  395: 1                        ; --------------------------------------------------------------------
  396: 1                        ; Options
  397: 1        N      0001     __OPT_SIZE__    EQU     1
  398: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  399: 1                        ; ####################################################################
  400: 1                        ; ####################################################################
  401: 1                        ; ####################################################################
  402: 1                        ; ####################################################################
  403: 1                        ; ####################################################################
  404: 1                        ; ####################################################################
  405: 1                        ; ####################################################################
  406: 1                        ; ####################################################################
  407: 1                        ; ####################################################################
  408:                          ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  409:                          ;       INTERRUPT SUBROUTINES
  410:                          ; The gameplay update logic will be assigned on Timer0's inturrupt
  411:                          ;  service routine.
  412:                          ; The sound management logic will be assigned on Timer1's inturrupt
  413:                          ;  service routine.
  414:                          ; The graphics processing subroutine will be plaeced in main loop,
  415:                          ;  will operate without any idling.
  416:                          ; --------------------------------------------------------------------
  417:          N      4000             ORG     4000H
  418:    4000  02 4B BD                LJMP    MAIN    ; long jump since will jump over
  419:                                                  ;  huge code segment made from
  420:                                                  ; lots of submodules.
  421:          N      4003             ORG     4003H
  422:
  423:          N      400B             ORG     400BH
  424:    400B  02 42 8C                LJMP    iUPDATE_DISPLAY
  425:                                                  ; Timer 0 interrupt will trigger
  426:                                                  ; the display-a-line procedure
  427:          N      4013             ORG     4013H
  428:          N      401B             ORG     401BH
  429:                          ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  430:                          ; --------------------------------------------------------------------
  431:                          ;       MODULE DECLARATION
  432:                          ; --------------------------------------------------------------------
  433:                          DECLARE_MODULE  GRAPHICS
  434+ 1
  435+ 1        N      0000     ____GRAPHICS_DEF        EQU     0
  436+ 1        N      0000     ____GRAPHICS    SET     0
  437:                          DECLARE_MODULE  UTILS
  438+ 1
  439+ 1        N      0000     ____UTILS_DEF   EQU     0
  440+ 1        N      0000     ____UTILS       SET     0
  441:                          ; --------------------------------------------------------------------
  442:                          ;       MODULE INCLUSION
  443:                          ; --------------------------------------------------------------------
  444:                          $INCLUDE        (GRAPHICS.INC)
  445: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  446: 1                        DEFINE_MODULE   Graphics ; Change this as you want.
  447+ 2        N      0000             IFN     ____Graphics
  448+ 2        N      0001     ____Graphics    SET     1
  449: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  450: 1                        $INCLUDE        (UTILS.INC)
  451: 2                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  452: 2                        DEFINE_MODULE   UTILS ; Change this as you want.
  453+ 3        N      0000             IFN     ____UTILS
  454+ 3        N      0001     ____UTILS       SET     1
  455: 2                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  456: 2                        ;
  457: 2                        ;       TemplateModule
  458: 2                        ;
  459: 2                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  460: 2                        ;       DESCRIPTION
  461: 2                        ; Write down the description of this module.
  462: 2                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  463: 2                        ; ######### SUBROUTINES & MACROS #####################################
  464: 2                        ;
  465: 2                        ; ¬ß LIST OF PREFIXES:: PROC, SPEC[0-9a-zA-Z_]*, CALBAK
  466: 2                        ;
  467: 2                        ;       Prefix PROC indicates a general callable procedure which
  468: 2                        ;        indicates an interface function.
  469: 2                        ;
  470: 2                        ;       Prefix SPEC[..] indicates a special purpose function which
  471: 2                        ;        should be called only in specific sequence.
  472: 2                        ;        All of the rules about prefix words and procedure concepts
  473: 2                        ;        should be concretely defined.
  474: 2                        ;
  475: 2                        ;       Prefix CALBAK indicates a procedure is callback which fits
  476: 2                        ;        in specific calling protocol.
  477: 2                        ;
  478: 2                        ; --------------------------------------------------------------------
  479: 2                        ; #MACRO        STRING  LITERAL
  480: 2                        ; --------------------------------------------------------------------
  481: 2                        STRING  MACRO   LBL, LTRL
  482: 2                                LOCAL   ECC
  483: 2                                SJMP    ECC
  484: 2                        LBL:    DB      LTRL, 0
  485: 2                        ECC:
  486: 2                        ENDM
  487: 2                        ; --------------------------------------------------------------------
  488: 2                        ; #MACRO        NEG     A
  489: 2                        ; --------------------------------------------------------------------
  490: 2                        ; Negates A
  491: 2                        NEG     MACRO   _A
  492: 2                                CPL     _A
  493: 2                                INC     _A
  494: 2                        ENDM
  495: 2                        ; --------------------------------------------------------------------
  496: 2                        ; --------------------------------------------------------------------
  497: 2                        ; #MACRO        MOVP2   VAL
  498: 2                        ; --------------------------------------------------------------------
  499: 2                        MOVP2   MACRO   VAL
  500: 2                                MOV     GLB_P2CACHE,VAL
  501: 2                                MOV     P2,     VAL
  502: 2                                ENDM
  503: 2                        ; --------------------------------------------------------------------
  504: 2                        ; #MACRO        LDP2CDW P2, RN, CONSTDW
  505: 2                        ; --------------------------------------------------------------------
  506: 2                        LDCDWP2 MACRO   _RN, CONSTDW
  507: 2                                MOVP2           #HIGH(CONSTDW)
  508: 2                                MOV     _RN,    #LOW(CONSTDW)
  509: 2                                ENDM
  510: 2                        ; --------------------------------------------------------------------
  511: 2                        ; #MACRO        LOADCDW HI, LO, CONSTDW
  512: 2                        ; --------------------------------------------------------------------
  513: 2                        LDCDW   MACRO   HI, LO, CONSTDW
  514: 2                                MOV     HI,     #HIGH(CONSTDW)
  515: 2                                MOV     LO,     #LOW(CONSTDW)
  516: 2                                ENDM
  517: 2                        ; --------------------------------------------------------------------
  518: 2                        ; #MACRO        PEAKP2  TGET
  519: 2                        ; --------------------------------------------------------------------
  520: 2                        PEAKP2  MACRO   TGET
  521: 2                                MOV     TGET,   GLB_P2CACHE
  522: 2                                ENDM
  523: 2                        ; --------------------------------------------------------------------
  524: 2                        ; #MACRO        PUSHP2
  525: 2                        ; --------------------------------------------------------------------
  526: 2                        PUSHP2  MACRO
  527: 2                                PUSH    GLB_P2CACHE
  528: 2                                ENDM
  529: 2                        ; --------------------------------------------------------------------
  530: 2                        ; #MACRO        POPP2
  531: 2                        ; --------------------------------------------------------------------
  532: 2                        POPP2   MACRO
  533: 2                                POP     GLB_P2CACHE
  534: 2                                PEAKP2  P2
  535: 2                                ENDM
  536: 2                        ; --------------------------------------------------------------------
  537: 2                        ; #MACRO        DCALL   IDPTR
  538: 2                        ;       X A, DPTR
  539: 2                        ; --------------------------------------------------------------------
  540: 2                        ; Calls function dynamically on dptr
  541: 2                        DCALL   MACRO   IDPTR
  542: 2                                LOCAL   BACK
  543: 2                                MOV     A,      #LOW(BACK)
  544: 2                                PUSH    ACC
  545: 2                                MOV     A,      #HIGH(BACK)
  546: 2                                PUSH    ACC
  547: 2                                MOV     A,      #0
  548: 2                                JMP     @A+IDPTR
  549: 2                        BACK:
  550: 2                                ENDM
  551: 2                        ; --------------------------------------------------------------------
  552: 2                        ; #MACRO        MOVW    OP1(W), OP2(DW)
  553: 2                        ; --------------------------------------------------------------------
  554: 2                        ; Moves a word from op2 to op1. Operand should be directly addressed.
  555: 2                        MOVW    MACRO   OP1, OP2
  556: 2                                MOV     OP1,    OP2
  557: 2                                MOV     OP1+1,  OP2+1
  558: 2                                ENDM
  559: 2                        ; --------------------------------------------------------------------
  560: 2                        ;
  561: 2                        ; @PROC ADDSEP
  562: 2                        ;
  563: 2                        ; I     R1      OPERAND 1
  564: 2                        ; I     R2      OPERAND 2
  565: 2                        ; OUT   A       RESULT
  566: 2                        ;
  567: 2                        ; X     B
  568: 2                        ;
  569: 2                        ; --------------------------------------------------------------------
  570: 2                        ; Performs signed addition operation, seprately upper and lower 4bits
  571: 2  401B  E9              rADDSEP:        MOV     A,      R1
  572: 2  401C  2A                      ADD     A,      R2
  573: 2  401D  C0 E0                   PUSH    ACC
  574: 2  401F  E9                      MOV     A,      R1
  575: 2  4020  54 F0                   ANL     A,      #0F0H
  576: 2  4022  2A                      ADD     A,      R2
  577: 2  4023  54 F0                   ANL     A,      #0F0H
  578: 2  4025  F5 F0                   MOV     B,      A
  579: 2  4027  D0 E0                   POP     ACC
  580: 2  4029  54 0F                   ANL     A,      #00FH
  581: 2  402B  25 F0                   ADD     A,      B
  582: 2  402D  22                      RET
  583: 2                        ; --------------------------------------------------------------------
  584: 2                        ;
  585: 2                        ; @PROC MEMSET
  586: 2                        ;
  587: 2                        ; I     B       MEM TO SET
  588: 2                        ; IX    DPTR    BEGIN
  589: 2                        ; IX    R1:R0   SIZE TO CLEAR
  590: 2                        ;
  591: 2                        ; X     A
  592: 2                        ;
  593: 2                        ; --------------------------------------------------------------------
  594: 2  402E                  rMEMSET:        ; Set memory
  595: 2  402E  E5 F0                   MOV     A,      B
  596: 2  4030  F0                      MOVX    @DPTR,  A
  597: 2  4031  A3                      INC     DPTR
  598: 2                                ; To next index
  599: 2  4032  E8                      MOV     A,      R0
  600: 2  4033  C3                      CLR     C
  601: 2  4034  94 01                   SUBB    A,      #1
  602: 2  4036  F8                      MOV     R0,     A
  603: 2  4037  E9                      MOV     A,      R1
  604: 2  4038  94 00                   SUBB    A,      #0
  605: 2  403A  F9                      MOV     R1,     A
  606: 2                                ; Check if done
  607: 2  403B  70 F1                   JNZ     rMEMSET
  608: 2  403D  E8                      MOV     A,      R0
  609: 2  403E  70 EE                   JNZ     rMEMSET
  610: 2                                ; If input size has turned to zero, return.
  611: 2  4040  22                      RET
  612: 2                        ; --------------------------------------------------------------------
  613: 2                        ;
  614: 2                        ; @PROC DTOA
  615: 2                        ;
  616: 2                        ; I     B       Input BCD
  617: 2                        ; I     DPTR    String location
  618: 2                        ; OUT   DPTR    New string location, '\0' stored.
  619: 2                        ;
  620: 2                        ; X     ACC
  621: 2                        ;
  622: 2                        ; -------------------------------------------------------------------
  623: 2                        ; Appends decimal to ascii result into given string location.
  624: 2                        ; Behavior is undefined if given B value is not a BCD number.
  625: 2  4041  E5 F0           rDTOA:  MOV     A,      B
  626: 2                                ; First, masks upper 4bit and draw it to lower place.
  627: 2  4043  54 F0                   ANL     A,      #0F0H
  628: 2  4045  C4                      SWAP    A
  629: 2                                ; Then makes it a ASCII code
  630: 2  4046  24 30                   ADD     A,      #'0'
  631: 2                                ; Store it
  632: 2  4048  F0                      MOVX    @DPTR,  A
  633: 2                                ; Repeat this to lower 4bits
  634: 2  4049  A3                      INC     DPTR
  635: 2  404A  E5 F0                   MOV     A,      B
  636: 2  404C  54 0F                   ANL     A,      #0FH
  637: 2  404E  24 30                   ADD     A,      #'0'
  638: 2  4050  F0                      MOVX    @DPTR,  A
  639: 2                                ; Append null character at the end of the string.
  640: 2  4051  A3                      INC     DPTR
  641: 2  4052  74 00                   MOV     A,      #0
  642: 2  4054  F0                      MOVX    @DPTR,  A
  643: 2  4055  22                      RET
  644: 2                        ; --------------------------------------------------------------------
  645: 2                        ;
  646: 2                        ; @PROC ADDBLKSEP
  647: 2                        ;
  648: 2                        ; IX    A       OP1
  649: 2                        ; I     R2      OP2
  650: 2                        ; OUT   A       RESULT
  651: 2                        ;
  652: 2                        ; X     B
  653: 2                        ;
  654: 2                        ; --------------------------------------------------------------------
  655: 2                        ; Adds two signed number, which are the 4bit-4bit separated format.
  656: 2  4056                  rADDBLKSEP:
  657: 2  4056  C0 E0                   PUSH    ACC
  658: 2                                ; Adds upper 4bit first.
  659: 2  4058  54 F0                   ANL     A,      #0F0H
  660: 2  405A  2A                      ADD     A,      R2
  661: 2  405B  54 F0                   ANL     A,      #0F0H
  662: 2                                ; Adds lower 4bit
  663: 2  405D  F5 F0                   MOV     B,      A
  664: 2  405F  D0 E0                   POP     ACC
  665: 2  4061  2A                      ADD     A,      R2
  666: 2  4062  54 0F                   ANL     A,      #00FH
  667: 2                                ; Adds each value other.
  668: 2  4064  25 F0                   ADD     A,      B
  669: 2  4066  22                      RET
  670: 2                        ; --------------------------------------------------------------------
  671: 2                        ;
  672: 2                        ; @PROC DELAY
  673: 2                        ;
  674: 2                        ; I     A       Milliseconds to delay
  675: 2                        ; XX    B
  676: 2                        ;
  677: 2                        ; --------------------------------------------------------------------
  678: 2  4067  75 F0 E6        rDELAY: MOV     B,      #230
  679: 2  406A  00              DELAY_0:        NOP
  680: 2  406B  00                      NOP
  681: 2  406C  D5 F0 FB                DJNZ    B,      DELAY_0
  682: 2  406F  D5 E0 F5                DJNZ    ACC,    rDELAY
  683: 2  4072  22                      RET
  684: 2                        ; --------------------------------------------------------------------
  685: 2                        ;
  686: 2                        ; @PROC ITOA
  687: 2                        ;
  688: 2                        ; --------------------------------------------------------------------
  689: 2
  690: 2                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  691: 2
  692: 2                        ENDIF
  693: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  694: 1                        ;
  695: 1                        ;       Graphics Module
  696: 1                        ;
  697: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  698: 1                        ;       DESCRIPTION
  699: 1                        ;
  700: 1                        ; This module contains most of graphical utilities and subroutines.
  701: 1                        ; Every procedures are designed to enable to drive "DFR0471" smoothly
  702: 1                        ;  which is 32*16 RGB display whose pixel count is 512.
  703: 1                        ;
  704: 1                        ; Every procedure labels begin with prefix 'GP' assumes that they
  705: 1                        ;  are called only in main graphics processing loop, therefore there
  706: 1                        ;  is not any memory allocation sequence to secure this process.
  707: 1                        ;
  708: 1                        ; Procedures wich consists the rest of code segment are interface
  709: 1                        ;  functions which draw primitive elements on the graphics back buffer.
  710: 1                        ;
  711: 1                        ; Since drawing a single dot repeatively is pretty inefficient process,
  712: 1                        ;  this module provides many types of drawing functionality.
  713: 1                        ;
  714: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  715: 1                        ; ######### SUBROUTINES & MACROS #####################################
  716: 1                        ;
  717: 1                        ; ¬ß LIST OF PREFIXES:: PROC, SPEC[0-9a-zA-Z_]*, CALBAK
  718: 1                        ;
  719: 1                        ;       Prefix PROC indicates a general callable procedure which
  720: 1                        ;        indicates an interface function.
  721: 1                        ;
  722: 1                        ;       Prefix SPEC[..] indicates a special purpose function which
  723: 1                        ;        should be called only in specific sequence.
  724: 1                        ;        All of the rules about prefix words and procedure concepts
  725: 1                        ;        should be concretely defined.
  726: 1                        ;
  727: 1                        ;       Prefix CALBAK indicates a procedure is callback which fits
  728: 1                        ;        in specific calling protocol.
  729: 1                        ;
  730: 1                        ; --------------------------------------------------------------------
  731: 1                        ;
  732: 1                        ; @NOTICE       DRAWING API OVERALL
  733: 1                        ;
  734: 1                        ; ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î
       1                        Ä‚îÄ‚îÄ‚îÄ‚îê ‚Üë
  735: 1                        ; ‚îÇ x                                 ‚îÇ 8   SCREEN SELECTION 0
  736: 1                        ; ‚îÇ                                   ‚îÇ ‚Üì
  737: 1                        ; ‚îÇ                                   ‚îÇ ‚Üë
  738: 1                        ; ‚îÇ                                   ‚îÇ 8   SCREEN SELECTION 1
  739: 1                        ; ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î
       1                        Ä‚îÄ‚îÄ‚îÄ‚îò ‚Üì
  740: 1                        ; |‚Üê---------------32----------------‚Üí|
  741: 1                        ;  x : Origin.
  742: 1                        ;
  743: 1                        ; The first dot of display is at left and topmost.
  744: 1                        ; To draw a dot on display, you should specify the address of target
  745: 1                        ;  dot which is indicated by a bit and a byte. A bit indicates a
  746: 1                        ;  selection between screens divided upper and lower segment,
  747: 1                        ;  assigning 0 on this bit targets upper screen.
  748: 1                        ; The higher 3bit of address byte indicates the vertical line, and
  749: 1                        ;  lower 5bit of byte indicates horizontal line.
  750: 1                        ; Additionally, (You don't need to remember this thing..) the OUTPUT
  751: 1                        ;  port of this 8051 kit will be used to indicate 6 bit of RGB output
  752: 1                        ;  which will be pushed into display's register. This will be separted
  753: 1                        ;  into upper and lower 4bits, and their topmost bit will be ignored.
  754: 1                        ;  This targets to adapt SWAP operation onto them smoothly therefore
  755: 1                        ;  to achieve higher performance.
  756: 1                        ; --------------------------------------------------------------------
  757: 1                        ;
  758: 1                        ; @PROC FILLBUFFER
  759: 1                        ; $MC 1047
  760: 1                        ; I     A       INPUT COLOR. Uses only lower 4bits
  761: 1                        ; OUT   DPH     BACK BUFFER
  762: 1                        ;
  763: 1                        ; XX    DPL     WILL BE 0.
  764: 1                        ;
  765: 1                        ; --------------------------------------------------------------------
  766: 1                        ; Fills back buffer as given color input.
  767: 1  4073                  rFILLBUFFER:
  768: 1  4073  C0 F0                   PUSH    B
  769: 1                                ; >>>>>
  770: 1                                ; copies lower 4bits' data onto upper 4bit
  771: 1  4075  54 0F                   ANL     A,      #0FH
  772: 1  4077  F5 F0                   MOV     B,      A
  773: 1  4079  C4                      SWAP    A
  774: 1  407A  25 F0                   ADD     A,      B
  775: 1  407C  F5 F0                   MOV     B,      A
  776: 1
  777: 1                                ; gets current back buffer
  778: 1  407E  12 42 83                CALL    rBUFFER_BACK
  779: 1
  780: 1                                ; set initial buffer point
  781: 1  4081  F5 83                   MOV     DPH,    A
  782: 1  4083  75 82 00                MOV     DPL,    #0
  783: 1
  784: 1  4086  E5 F0                   MOV     A,      B
  785: 1
  786: 1                        ; fills all of the cells as given color.
  787: 1                        ; this will operate by decrementing direction.
  788: 1  4088                  FILLBUFFER_0:
  789: 1  4088  F0                      MOVX    @DPTR,  A
  790: 1  4089  D5 82 FC                DJNZ    DPL,    FILLBUFFER_0
  791: 1
  792: 1                                ; <<<<<
  793: 1  408C  D0 F0                   POP     B
  794: 1  408E  22                      RET
  795: 1                        ; --------------------------------------------------------------------
  796: 1                        ; #MACRO        DP_ASMLOC       AA, BB
  797: 1                        ; AA    I A     Y value. 0~15
  798: 1                        ; BB    IO B    X value. 0~31. Will contain result.
  799: 1                        ;       O F0    Screen selection output.
  800: 1                        ; --------------------------------------------------------------------
  801: 1                        DP_ASMLOC       MACRO   AA, BB
  802: 1                                MOV     F0,     ACC.3
  803: 1                                SWAP    AA
  804: 1                                RL      A
  805: 1                                ANL     B       #00011111B
  806: 1                                ANL     A       #11100000B
  807: 1                                ORL     B,      A
  808: 1                                ENDM
  809: 1                        ; --------------------------------------------------------------------
  810: 1                        ;
  811: 1                        ; @PROC DRAWBOX
  812: 1                        ; $MC 40*WIDTH + 51*HEIGHT - 34
  813: 1                        ;
  814: 1                        ; I     DPH     BACK BUFFER
  815: 1                        ; IX    CY      SCRREEN SELECTION
  816: 1                        ; IX    DPL     [Y3:X5] LOCATION
  817: 1                        ; IX [3:0]      B       COLOR
  818: 1                        ; I     R1      WIDTH
  819: 1                        ; IX    R2      HEIGHT
  820: 1                        ;
  821: 1                        ; X BIT F0
  822: 1                        ;
  823: 1                        ; --------------------------------------------------------------------
  824: 1                        ; Draws a box on given location with given width and height.
  825: 1  408F                  rDRAWBOX:
  826: 1        N        02             USING   GAMEBANK/8
  827: 1        D      0011     WIDTH   SET     AR1
  828: 1        D      0012     HEIGHT  SET     AR2
  829: 1        R        R3     CACHE   SET     R3
  830: 1        R        R4     COLOR   SET     R4
  831: 1
  832: 1  408F  C0 13                   PUSH    AR3
  833: 1  4091  C0 14                   PUSH    AR4
  834: 1  4093  C0 E0                   PUSH    ACC
  835: 1
  836: 1                                ; >>>>>
  837: 1                                ; Uses lower 4bit of color only.
  838: 1  4095  53 F0 0F                ANL     B,      #0FH
  839: 1                                ; caches color.
  840: 1  4098  85 F0 14                MOV     AR4,    B
  841: 1
  842: 1                                ; this will define a HEAD, and will draw a box via moving
  843: 1                                ;  the HEAD as the amount of it should move on.
  844: 1
  845: 1                                ; the first it will move into right, and then go down,
  846: 1                                ;  and then go left, and will go back to beginning point.
  847: 1
  848: 1                                ; caches CY
  849: 1  409B  92 D5                   MOV     F0,     C
  850: 1
  851: 1                                ; 1. Goes by right direction. R3 will indicate
  852: 1                                ;  counts left to move.
  853: 1  409D  AB 11                   MOV     CACHE,  WIDTH
  854: 1  409F                  DRAWBOX_R:      ; Draws dot until it reached at given width.
  855: 1                                ; Select screen
  856: 1  409F  A2 D5                   MOV     C,      F0
  857: 1  40A1  8C F0                   MOV     B,      COLOR
  858: 1                                ; draws dot on current HEAD location
  859: 1  40A3  12 42 56                CALL    rDRAWDOT
  860: 1                                ; moves HEAD right
  861: 1  40A6  05 82                   INC     DPL
  862: 1                                ; repeat...
  863: 1  40A8  DB F5                   DJNZ    CACHE,  DRAWBOX_R
  864: 1
  865: 1                        ;       SJMP    DRAWBOX_X
  866: 1
  867: 1                                ; since the HEAD is pointing 1 dot further, roll it back.
  868: 1  40AA  15 82                   DEC     DPL
  869: 1                                ; 2. Goes down.
  870: 1                                ; @the value in HEIGHT will not be used anymore.
  871: 1                                ; since the first dot was already drawn...
  872: 1  40AC  15 12                   DEC     HEIGHT
  873: 1                        ; at this point, the HEAD is pointing the latest drawn dot.
  874: 1                        ;  to avoid duplication, this sequence moves HEAD first,
  875: 1                        ;  and then begins drawing dot.
  876: 1  40AE                  DRAWBOX_D:      ; downs HEAD by adding 0b00100000
  877: 1  40AE  74 20                   MOV     A,      #00100000B
  878: 1  40B0  25 82                   ADD     A,      DPL
  879: 1  40B2  F5 82                   MOV     DPL,    A
  880: 1                                ; adapt ORL to C and F0. since the screen selection
  881: 1                                ;  value never be cleared after set ever once.
  882: 1  40B4  72 D5                   ORL     C,      F0
  883: 1  40B6  92 D5                   MOV     F0,     C
  884: 1                                ; draw dot.
  885: 1  40B8  8C F0                   MOV     B,      COLOR
  886: 1  40BA  12 42 56                CALL    rDRAWDOT
  887: 1                                ; draw left side also. it can be easily adapted by
  888: 1                                ;  subtracting (Width-1) from DPL
  889: 1                                ; WIDTH-1
  890: 1  40BD  E5 11                   MOV     A,      WIDTH
  891: 1  40BF  14                      DEC     A
  892: 1                                ; gets the 2's complementary of A.
  893: 1  40C0  F4                      CPL     A
  894: 1  40C1  04                      INC     A
  895: 1                                ; cache DPL
  896: 1  40C2  AB 82                   MOV     CACHE,  DPL
  897: 1                                ; add this onto DPL, actually indicates the operation
  898: 1                                ;  "DPL - (WIDTH - 1)"
  899: 1  40C4  25 82                   ADD     A,      DPL
  900: 1  40C6  F5 82                   MOV     DPL,    A
  901: 1                                ; draw a dot
  902: 1  40C8  8C F0                   MOV     B,      COLOR
  903: 1  40CA  A2 D5                   MOV     C,      F0
  904: 1  40CC  12 42 56                CALL    rDRAWDOT
  905: 1                                ; revert DPL.
  906: 1  40CF  8B 82                   MOV     DPL,    CACHE
  907: 1                                ; repeat this for height count ...
  908: 1  40D1  D5 12 DA                DJNZ    HEIGHT,         DRAWBOX_D
  909: 1
  910: 1                                ; start to draw left side ...
  911: 1                                ; to avoid duplication, it should draw dots for
  912: 1                                ;  (WIDTH - 2) times.
  913: 1  40D4  AB 11                   MOV     CACHE,  WIDTH
  914: 1  40D6  1B                      DEC     CACHE
  915: 1  40D7  1B                      DEC     CACHE
  916: 1                                ; at this point the HEAD is pointing the rightmost and
  917: 1                                ;  downmost dot of the box boundary.
  918: 1  40D8                  DRAWBOX_L:      ; draws dots by moving left...
  919: 1  40D8  15 82                   DEC     DPL
  920: 1  40DA  8C F0                   MOV     B,      COLOR
  921: 1  40DC  A2 D5                   MOV     C,      F0
  922: 1  40DE  12 42 56                CALL    rDRAWDOT
  923: 1  40E1  DB F5                   DJNZ    CACHE,  DRAWBOX_L
  924: 1
  925: 1  40E3                  DRAWBOX_X:      ; <<<<<
  926: 1  40E3  D0 E0                   POP     ACC
  927: 1  40E5  D0 14                   POP     AR4
  928: 1  40E7  D0 13                   POP     AR3
  929: 1  40E9  22                      RET
  930: 1                        ; --------------------------------------------------------------------
  931: 1                        ;
  932: 1                        ; @PROC FILLBOX
  933: 1                        ; $MC 23 + HEIGHT*(15 + WIDTH*20)
  934: 1                        ;
  935: 1                        ; I     DPH     BACK BUFFER
  936: 1                        ; IX B  CY      SCRREEN SELECTION
  937: 1                        ; IX    DPL     [Y3:X5] LOCATION
  938: 1                        ; IX [3:0]      B       COLOR
  939: 1                        ; I     R1      WIDTH
  940: 1                        ; IX    R2      HEIGHT
  941: 1                        ;
  942: 1                        ; X  B  F0
  943: 1                        ;
  944: 1                        ; --------------------------------------------------------------------
  945: 1                        ; Fill a box with given color.
  946: 1  40EA                  rFILLBOX:
  947: 1        N        02             USING   GAMEBANK/8
  948: 1        R        R1     WIDTH   SET     R1
  949: 1        R        R2     HEIGHT  SET     R2
  950: 1        R        R3     CACHE   SET     R3
  951: 1        R        R4     COLOR   SET     R4
  952: 1        D      0015     WID_IT  SET     AR5
  953: 1
  954: 1  40EA  C0 E0                   PUSH    ACC
  955: 1  40EC  C0 13                   PUSH    AR3
  956: 1  40EE  C0 14                   PUSH    AR4
  957: 1  40F0  C0 15                   PUSH    AR5
  958: 1                                ; >>>>>
  959: 1                        ; fills horizontal lines one by one.
  960: 1                                ; masks input color for lower 4bits.
  961: 1  40F2  53 F0 0F                ANL     B,      #0FH
  962: 1                                ; caches CY and input color
  963: 1  40F5  92 D5                   MOV     F0,     C
  964: 1  40F7  AC F0                   MOV     COLOR,  B
  965: 1
  966: 1  40F9                  FILLBOX_VERT:
  967: 1                        ; the outer loop does vertical indexing.
  968: 1                                ; caches DPL before filling a horizontal line.
  969: 1  40F9  AB 82                   MOV     CACHE,  DPL
  970: 1  40FB  89 15                   MOV     WID_IT, WIDTH
  971: 1  40FD                  FILLBOX_HORI:
  972: 1                        ; the inner loop does horizontal line filling.
  973: 1                                ; .draws a dot on HEAD
  974: 1                                ; assign screen seleciton
  975: 1  40FD  A2 D5                   MOV     C,      F0
  976: 1  40FF  8C F0                   MOV     B,      COLOR
  977: 1  4101  12 42 56                CALL    rDRAWDOT
  978: 1                                ; move HEAD to next.
  979: 1  4104  05 82                   INC     DPL
  980: 1                                ; repeats this for WIDTH
  981: 1  4106  D5 15 F4                DJNZ    WID_IT, FILLBOX_HORI
  982: 1                        ; ~FILLBOX_HORI
  983: 1                                ; .moves HEAD down for 1 dot.
  984: 1                                ; rolls back dpl from cache
  985: 1  4109  8B 82                   MOV     DPL,    CACHE
  986: 1                                ; moves down HEAD by adding 0010 0000 = 20h
  987: 1  410B  74 20                   MOV     A,      #20H
  988: 1  410D  25 82                   ADD     A,      DPL
  989: 1  410F  F5 82                   MOV     DPL,    A
  990: 1                                ; adapt ORL to C and F0. since the screen selection
  991: 1                                ;  value never be cleared after set ever once.
  992: 1  4111  72 D5                   ORL     C,      F0
  993: 1  4113  92 D5                   MOV     F0,     C
  994: 1  4115  DA E2                   DJNZ    HEIGHT, FILLBOX_VERT
  995: 1                        ; ~FILLBOX_VERT
  996: 1                                ; <<<<<
  997: 1  4117  D0 15                   POP     AR5
  998: 1  4119  D0 14                   POP     AR4
  999: 1  411B  D0 13                   POP     AR3
 1000: 1  411D  D0 E0                   POP     ACC
 1001: 1  411F  22                      RET
 1002: 1                        ; --------------------------------------------------------------------
 1003: 1                        ;
 1004: 1                        ; @PROC DRAWIMAGE
 1005: 1                        ;
 1006: 1                        ; I     P2      BACK BUFFER
 1007: 1                        ; IX B  CY      SCREEN_SELECTION
 1008: 1                        ; IX    R1      [Y3:X5] PIVOT LOCATION
 1009: 1                        ; I  2  DPTR    IMAGE LOCATION
 1010: 1                        ;
 1011: 1                        ; X  B  F0
 1012: 1                        ; X     B
 1013: 1                        ;
 1014: 1                        ; --------------------------------------------------------------------
 1015: 1                        ; Draws image onto given location. An image format is
 1016: 1                        ;       {0:1bit}{1:7}...{{2:x}{'0b10001000'}}*{1}
 1017: 1                        ; ex.
 1018: 1                        ;       00000100
 1019: 1                        ;               0110:0111 0010:0001 0100:0001 10001000
 1020: 1                        ;               0100:0001 0100:1000 1000:0010 0001:0010 10001000
 1021: 1                        ;               ....
 1022: 1                        ;     (0b100 th row)    0001:0010 10001000
 1023: 1                        ;
 1024: 1                        ; The first byte is header. The first bit determines whether the
 1025: 1                        ;  drawing HEAD treats RGB 000 as void or black color.
 1026: 1                        ; Next 7bits are number of rows.
 1027: 1                        ; From then, it will start to draw colors by 4bits one by one.
 1028: 1                        ; The constant '10001000' is treated like a null character.
 1029: 1                        ; If the drawing HEAD encounters the null character, it will
 1030: 1                        ;  jump to next line.
 1031: 1                        ; However only fully filled byte with null character will be treated
 1032: 1                        ;  as null. If when the only half of a byte is filled with '0b1000',
 1033: 1                        ;  then it will be treated just like void.
 1034: 1  4120                  rDRAWIMAGE:
 1035: 1        N        02             USING   GAMEBANK/8
 1036: 1        R        R1     HEAD    SET     R1
 1037: 1        R        R2     LINELEFT        SET     R2
 1038: 1        B      0000     SCRNSELEC       SET     BR0.0
 1039: 1        R        R3     CACHE   SET     R3
 1040: 1        R        R4     C_HEAD  SET     R4
 1041: 1        B      00D5     BLTOVOID        SET     F0
 1042: 1
 1043: 1  4120  C0 E0                   PUSH    ACC
 1044: 1  4122  C0 12                   PUSH    AR2
 1045: 1  4124  C0 13                   PUSH    AR3
 1046: 1  4126  C0 14                   PUSH    AR4
 1047: 1  4128  C0 20                   PUSH    BR0
 1048: 1                                ; >>>>>
 1049: 1                                ; cache screen selection
 1050: 1  412A  92 00                   MOV     SCRNSELEC,      C
 1051: 1
 1052: 1                                ; parse header
 1053: 1  412C  74 00                   MOV     A,      #0
 1054: 1  412E  93                      MOVC    A,      @A+DPTR
 1055: 1  412F  A2 E7                   MOV     C,      ACC.7
 1056: 1  4131  92 D5                   MOV     BLTOVOID,       C
 1057: 1  4133  54 7F                   ANL     A,      #01111111B
 1058: 1  4135  FA                      MOV     LINELEFT,       A
 1059: 1
 1060: 1                                ; move head forward.
 1061: 1  4136  A3                      INC     DPTR
 1062: 1
 1063: 1                                ; .start draw image
 1064: 1  4137                  DRAWIMAGE_LINE_ENTRY:
 1065: 1                        ; This outer loop indicates starting draw the first position of an image.
 1066: 1                                ; cache current HEAD location
 1067: 1  4137  89 14                   MOV     AR4,    HEAD
 1068: 1  4139                  DRAWIMAGE_DRAW_LINE:
 1069: 1                        ; This inner loop indicates drawing two dots per tick.
 1070: 1                                ; get two dots contained in a byte of data from external memory.
 1071: 1  4139  74 00                   MOV     A,      #0
 1072: 1  413B  93                      MOVC    A,      @A+DPTR
 1073: 1  413C  FB                      MOV     CACHE,  A
 1074: 1  413D  A3                      INC     DPTR
 1075: 1                                ; checks if head is on the end of the line.
 1076: 1  413E  B4 88 0E                CJNE    A,      #10001000B,     DRAWIMAGE_DRAW_DOT
 1077: 1
 1078: 1                                ; .if end of line ...
 1079: 1                                ; rolls back HEAD to the beginning point of current line.
 1080: 1  4141  8C 11                   MOV     AR1,    C_HEAD
 1081: 1                                ; shifts HEAD downward
 1082: 1  4143  74 20                   MOV     A,      #20H
 1083: 1  4145  29                      ADD     A,      HEAD
 1084: 1  4146  F9                      MOV     HEAD,   A
 1085: 1  4147  72 00                   ORL     C,      SCRNSELEC
 1086: 1  4149  92 00                   MOV     SCRNSELEC,      C
 1087: 1                                ; go to draw next line.
 1088: 1  414B  DA EA                   DJNZ    LINELEFT,       DRAWIMAGE_LINE_ENTRY
 1089: 1  414D  80 22                   SJMP    DRAWIMAGE_DONE
 1090: 1
 1091: 1  414F                  DRAWIMAGE_DRAW_DOT:
 1092: 1                        ; upper 4 bits precedes.
 1093: 1                                ; masks upper 4bits.
 1094: 1  414F  C4                      SWAP    A
 1095: 1  4150  54 0F                   ANL     A,      #0FH
 1096: 1                                ; if A is zero(=RGB000) and BLTOVOID is 1, skip this dot
 1097: 1  4152  70 03                   JNZ     DRAWIMAGE_0
 1098: 1  4154  20 D5 07                JB      BLTOVOID,       DRAWIMAGE_1
 1099: 1  4157                  DRAWIMAGE_0:
 1100: 1                        ; draws upper 4bits
 1101: 1  4157  F5 F0                   MOV     B,      A
 1102: 1  4159  A2 00                   MOV     C,      SCRNSELEC
 1103: 1  415B  12 42 68                CALL    rDRAWDOTB
 1104: 1  415E                  DRAWIMAGE_1:
 1105: 1                        ; lower 4bits follows.
 1106: 1                                ; extract lower 4bits
 1107: 1  415E  EB                      MOV     A,      CACHE
 1108: 1  415F  54 0F                   ANL     A,      #0FH
 1109: 1                                ; moves HEAD forward.
 1110: 1  4161  09                      INC     HEAD
 1111: 1                                ; if A is zero(=RGB000) and BLTOVOID is 1, skip this dot
 1112: 1  4162  70 03                   JNZ     DRAWIMAGE_2
 1113: 1  4164  20 D5 07                JB      BLTOVOID,       DRAWIMAGE_NEXTDOT
 1114: 1  4167                  DRAWIMAGE_2:
 1115: 1                        ; draws lower 4bits
 1116: 1  4167  F5 F0                   MOV     B,      A
 1117: 1  4169  A2 00                   MOV     C,      SCRNSELEC
 1118: 1  416B  12 42 68                CALL    rDRAWDOTB
 1119: 1
 1120: 1  416E                  DRAWIMAGE_NEXTDOT:
 1121: 1                                ; moves HEAD forward.
 1122: 1  416E  09                      INC     HEAD
 1123: 1  416F  80 C8                   SJMP    DRAWIMAGE_DRAW_LINE
 1124: 1  4171                  DRAWIMAGE_DONE:
 1125: 1
 1126: 1                                ; <<<<<
 1127: 1  4171  D0 20                   POP     BR0
 1128: 1  4173  D0 14                   POP     AR4
 1129: 1  4175  D0 13                   POP     AR3
 1130: 1  4177  D0 12                   POP     AR2
 1131: 1  4179  D0 E0                   POP     ACC
 1132: 1  417B  22                      RET
 1133: 1
 1134: 1                        ; --------------------------------------------------------------------
 1135: 1                        ;
 1136: 1                        ; @PROC DRAWSTRING
 1137: 1                        ;
 1138: 1                        ; I  B  F0      Screen selection
 1139: 1                        ; I     P2      Current back buffer
 1140: 1                        ; I     R1      [X3:Y5] Drawing HEAD
 1141: 1                        ; IX    DPTR    String begin address
 1142: 1                        ; I     B       Color
 1143: 1                        ;
 1144: 1                        ; X     A
 1145: 1                        ;
 1146: 1                        ; --------------------------------------------------------------------
 1147: 1                        ; Draw string on given locaiton. 8 letters maximum per line.
 1148: 1  417C                  rDRAWSTRING:
 1149: 1        N        02             USING   GAMEBANK/8
 1150: 1        B      0000     IS_SPACE        SET     BR0.0
 1151: 1        B      0001     F0CACHE SET     BR0.1
 1152: 1  417C  C0 11                   PUSH    AR1
 1153: 1  417E  C0 20                   PUSH    BR0
 1154: 1                                ; >>>>>
 1155: 1  4180  C2 00                   CLR     IS_SPACE
 1156: 1  4182  A2 D5                   MOV     C,      F0
 1157: 1  4184  92 01                   MOV     F0CACHE,        C
 1158: 1  4186                  DRAWSTRING_DRAW:
 1159: 1                        ; Loop sustains until the HEAD found '\0'
 1160: 1                                ; Get ASCII on pointing location
 1161: 1  4186  74 00                   MOV     A,      #0
 1162: 1  4188  93                      MOVC    A,      @A+DPTR
 1163: 1
 1164: 1                                ; If it is space, the cursor will only shift two lines right.
 1165: 1  4189  B4 20 02                CJNE    A,      #' ',   DRAWSTRING_NOSPACE
 1166: 1  418C  D2 00                   SETB    IS_SPACE
 1167: 1  418E                  DRAWSTRING_NOSPACE:
 1168: 1
 1169: 1                                ; If it is null letter, end drawing sequence.
 1170: 1  418E  60 19                   JZ      DRAWSTRING_DONE
 1171: 1
 1172: 1                                ; Cache current DPTR location
 1173: 1  4190  C0 83                   PUSH    DPH
 1174: 1  4192  C0 82                   PUSH    DPL
 1175: 1
 1176: 1                                ; Draw character on given location
 1177: 1  4194  12 41 AE                CALL    rDRAWASCII
 1178: 1
 1179: 1                                ; Adjust R1 location to right.
 1180: 1  4197  74 04                   MOV     A,      #4
 1181: 1  4199  30 00 02                JNB     IS_SPACE,       DRAWSTRING_STEP
 1182: 1  419C  74 02                   MOV     A,      #2
 1183: 1  419E                  DRAWSTRING_STEP:
 1184: 1  419E  C2 00                   CLR     IS_SPACE
 1185: 1                        ; To jump half when it is space ...
 1186: 1  41A0  29                      ADD     A,      R1
 1187: 1  41A1  F9                      MOV     R1,     A
 1188: 1
 1189: 1                                ; Restores DPTR location
 1190: 1  41A2  D0 82                   POP     DPL
 1191: 1  41A4  D0 83                   POP     DPH
 1192: 1
 1193: 1                                ; Targets next character
 1194: 1  41A6  A3                      INC     DPTR
 1195: 1  41A7  80 DD                   SJMP    DRAWSTRING_DRAW
 1196: 1  41A9                  DRAWSTRING_DONE:
 1197: 1                                ; <<<<<
 1198: 1  41A9  D0 20                   POP     BR0
 1199: 1  41AB  D0 11                   POP     AR1
 1200: 1  41AD  22                      RET
 1201: 1                        ; --------------------------------------------------------------------
 1202: 1                        ;
 1203: 1                        ; @PROC DRAWASCII
 1204: 1                        ;
 1205: 1                        ; I  B  F0      Screen seleciton
 1206: 1                        ; I     P2      Current buffer
 1207: 1                        ; I     R1      [X3:Y5] Drawing HEAD
 1208: 1                        ; IX    A       Target ASCII character.
 1209: 1                        ; I     B       Color
 1210: 1                        ;
 1211: 1                        ; X  2  DPTR
 1212: 1                        ; X/BANK2       R0, R2, R3, R5
 1213: 1                        ;
 1214: 1                        ; --------------------------------------------------------------------
 1215: 1                        ; ASCII code will be drawn in X4*Y8 boundary. Its format on external
 1216: 1                        ;  memory will be defined with 4 bytes of continuous data.
 1217: 1                        ; A single bit indicates whether the dot should be drawn or not.
 1218: 1                        ; @see file     RES.ASCII.INC
 1219: 1  41AE                  rDRAWASCII:
 1220: 1                        ; ASCII drawing format is consist of continuous 3bytes.
 1221: 1                        ; A byte will be seperated by 4bits, each half byte will indicate a
 1222: 1                        ;  horizontal data.
 1223: 1                        ; For example, a character '0' will be represented like this.
 1224: 1                        ;       . 0 0 .   }
 1225: 1                        ;       0 . . 0   } first byte
 1226: 1                        ;       0 . 0 0   ]
 1227: 1                        ;       0 0 . 0   ] second byte
 1228: 1                        ;       0 . . 0   )
 1229: 1                        ;       . 0 0 .   ) third byte
 1230: 1        N        03             USING   BANK2/8
 1231: 1        R        R5     COLOR   SET     R5
 1232: 1
 1233: 1  41AE  C0 D0                   PUSH    PSW
 1234: 1                                ; get parameter, R1 indicates current bank's parameter,
 1235: 1                                ;  AR1 indicates temporary bank's address.
 1236: 1                                ; by this, the original input parameter R1 won't be
 1237: 1                                ;  changed as long as caller procedure does not use BANK2.
 1238: 1  41B0  89 19                   MOV     AR1,    R1
 1239: 1
 1240: 1                                ; now switch the bank.
 1241: 1  41B2  D2 D4                   SETB    RS1
 1242: 1  41B4  D2 D3                   SETB    RS0
 1243: 1
 1244: 1                                ; >>>>>
 1245: 1                                ; .Moves DPTR offset as three times of input ASCII.
 1246: 1                                ; to do this...
 1247: 1                                ; cache color B
 1248: 1  41B6  AD F0                   MOV     COLOR,  B
 1249: 1                                ; subtract ' ' from input ascii
 1250: 1  41B8  C3                      CLR     C
 1251: 1  41B9  94 20                   SUBB    A,      #' '
 1252: 1                                ; do A * 3, since a character occupies 3 byte offset...
 1253: 1  41BB  75 F0 03                MOV     B,      #3
 1254: 1  41BE  A4                      MUL     AB
 1255: 1                                ; add this to DPTR
 1256: 1  41BF  90 4D E7                MOV     DPTR,   #ASCII
 1257: 1  41C2  25 82                   ADD     A,      DPL
 1258: 1  41C4  F5 82                   MOV     DPL,    A
 1259: 1  41C6  E5 F0                   MOV     A,      B
 1260: 1  41C8  35 83                   ADDC    A,      DPH
 1261: 1  41CA  F5 83                   MOV     DPH,    A
 1262: 1
 1263: 1                                ; draw ASCII on given location
 1264: 1  41CC  8D F0                   MOV     B,      COLOR
 1265: 1  41CE  12 41 D7                CALL    r__DRAWASCII
 1266: 1
 1267: 1                                ; <<<<<
 1268: 1  41D1  D0 D0                   POP     PSW
 1269: 1
 1270: 1                                ; output values to allow continuous call.
 1271: 1  41D3  85 1D F0                MOV     B,      AR5     ; since the address still
 1272: 1                                                        ;  indicates BANK2's...
 1273: 1  41D6  22                      RET
 1274: 1                        ; --------------------------------------------------------------------
 1275: 1                        ;
 1276: 1                        ; @SPECTMP      __DRAWASCII
 1277: 1                        ;
 1278: 1                        ; IX    F0      Screen selection
 1279: 1                        ; I     P2      Current buffer
 1280: 1                        ; IX    R1      [X3:Y5] Drawing HEAD
 1281: 1                        ; IX    DPTR    Target ASCII byte begin location
 1282: 1                        ; IX  3:0       B       Input color
 1283: 1                        ;
 1284: 1                        ; X     ACC, R7, R6, R5, R4, R3
 1285: 1                        ;
 1286: 1                        ; --------------------------------------------------------------------
 1287: 1                        ; Internal function which draws given single ASCII character into
 1288: 1                        ;  given location.
 1289: 1  41D7                  r__DRAWASCII:
 1290: 1        N        03             USING   BANK2/8
 1291: 1        R        R1     HEAD    SET     R1
 1292: 1        R        R5     COLOR   SET     R5
 1293: 1        R        R7     COUNT   SET     R7
 1294: 1        D      001C     HEAD_C  SET     AR4
 1295: 1        R        R4     HEAD_C0 SET     R4
 1296: 1
 1297: 1                                ; >>>>>
 1298: 1  41D7  AD F0                   MOV     COLOR,  B       ; cache input color.
 1299: 1  41D9  7F 03                   MOV     COUNT,  #3      ; count of bytes.
 1300: 1  41DB                  __DRAWASCII_0:
 1301: 1                                ; caches HEAD location
 1302: 1  41DB  89 1C                   MOV     HEAD_C, HEAD
 1303: 1                                ; extracts byte from program memory
 1304: 1  41DD  74 00                   MOV     A,      #0
 1305: 1  41DF  93                      MOVC    A,      @A+DPTR
 1306: 1                                ; to read next byte...
 1307: 1  41E0  A3                      INC     DPTR
 1308: 1                                ; cache
 1309: 1  41E1  FB                      MOV     R3,     A
 1310: 1                        ; .Each bit in A indicates if a dot should be drawn on
 1311: 1                        ;  given location or not.
 1312: 1                        __DRAWASCII_DRAWDOT     MACRO   BT
 1313: 1                                LOCAL   NODRAW
 1314: 1                                ; >>>>>> MACRO BEGIN >>>>>>
 1315: 1                                ;; IF BT == 7, [MOV A, R3] IS NOT REQUIRED.
 1316: 1                                IFN     BT-7
 1317: 1                                ELSE
 1318: 1                                MOV     A,      R3
 1319: 1                                ENDIF
 1320: 1                                ;; if current bit indicates 0, skip to next dot.
 1321: 1                                JNB     ACC.&BT,        NODRAW
 1322: 1                                MOV     B,      COLOR
 1323: 1                                MOV     C,      F0
 1324: 1                                CALL    RDRAWDOTB
 1325: 1                        NODRAW: ;; IF BT == 0 OR BT == 4, R1 SHOULD BE SHIFTED DOWNWARD.
 1326: 1                                IFN     BT*(BT-4)
 1327: 1                                ;; rolls back HEAD location onto leftmost point.
 1328: 1                                ;; shifts HEAD downward.
 1329: 1                                MOV     A,      #20H
 1330: 1                                ADD     A,      HEAD_C0
 1331: 1                                MOV     HEAD_C0,        A
 1332: 1                                ORL     C,      F0
 1333: 1                                MOV     F0,     C
 1334: 1                                MOV     HEAD,   HEAD_C
 1335: 1                                ;ELSEIFN        BT
 1336: 1                                ;;; rolls back HEAD location onto leftmost point.
 1337: 1                                ;;; shifts HEAD downward.
 1338: 1                                ;MOV    A,      #20H
 1339: 1                                ;ADD    A,      HEAD_C0
 1340: 1                                ;MOV    HEAD_C0,        A
 1341: 1                                ;ORL    C,      F0
 1342: 1                                ;MOV    F0,     C
 1343: 1                                ;MOV    HEAD,   HEAD_C
 1344: 1                                ELSE
 1345: 1                                INC     HEAD
 1346: 1                                ENDIF
 1347: 1                                ; <<<<<< MACRO END   <<<<<<
 1348: 1                                ENDM
 1349: 1                                ; draw bits.
 1350: 1                                __DRAWASCII_DRAWDOT 7
 1351+ 2                                ; >>>>>> MACRO BEGIN >>>>>>
 1352+ 2
 1353+ 2        N      0000             IFN     7-7
 1354+ 2                                ELSE
 1355+ 2                                MOV     A,      R3
 1356+ 2                                ENDIF
 1357+ 2
 1358+ 2  41E2  30 E7 07                JNB     ACC.7,  ??0009
 1359+ 2  41E5  8D F0                   MOV     B,      COLOR
 1360+ 2  41E7  A2 D5                   MOV     C,      F0
 1361+ 2  41E9  12 42 68                CALL    RDRAWDOTB
 1362+ 2  41EC                  ??0009:
 1363+ 2        N      0015             IFN     7*(7-4)
 1364+ 2
 1365+ 2
 1366+ 2                                MOV     A,      #20H
 1367+ 2                                ADD     A,      HEAD_C0
 1368+ 2                                MOV     HEAD_C0,        A
 1369+ 2                                ORL     C,      F0
 1370+ 2                                MOV     F0,     C
 1371+ 2                                MOV     HEAD,   HEAD_C
 1372+ 2                                ;ELSEIFN        BT
 1373+ 2
 1374+ 2
 1375+ 2                                ;MOV    A,      #20H
 1376+ 2                                ;ADD    A,      HEAD_C0
 1377+ 2                                ;MOV    HEAD_C0,        A
 1378+ 2                                ;ORL    C,      F0
 1379+ 2                                ;MOV    F0,     C
 1380+ 2                                ;MOV    HEAD,   HEAD_C
 1381+ 2                                ELSE
 1382+ 2  41EC  09                      INC     HEAD
 1383+ 2                                ENDIF
 1384+ 2                                ; <<<<<< MACRO END   <<<<<<
 1385: 1                                __DRAWASCII_DRAWDOT 6
 1386+ 2                                ; >>>>>> MACRO BEGIN >>>>>>
 1387+ 2
 1388+ 2        N      FFFF             IFN     6-7
 1389+ 2                                ELSE
 1390+ 2  41ED  EB                      MOV     A,      R3
 1391+ 2                                ENDIF
 1392+ 2
 1393+ 2  41EE  30 E6 07                JNB     ACC.6,  ??0010
 1394+ 2  41F1  8D F0                   MOV     B,      COLOR
 1395+ 2  41F3  A2 D5                   MOV     C,      F0
 1396+ 2  41F5  12 42 68                CALL    RDRAWDOTB
 1397+ 2  41F8                  ??0010:
 1398+ 2        N      000C             IFN     6*(6-4)
 1399+ 2
 1400+ 2
 1401+ 2                                MOV     A,      #20H
 1402+ 2                                ADD     A,      HEAD_C0
 1403+ 2                                MOV     HEAD_C0,        A
 1404+ 2                                ORL     C,      F0
 1405+ 2                                MOV     F0,     C
 1406+ 2                                MOV     HEAD,   HEAD_C
 1407+ 2                                ;ELSEIFN        BT
 1408+ 2
 1409+ 2
 1410+ 2                                ;MOV    A,      #20H
 1411+ 2                                ;ADD    A,      HEAD_C0
 1412+ 2                                ;MOV    HEAD_C0,        A
 1413+ 2                                ;ORL    C,      F0
 1414+ 2                                ;MOV    F0,     C
 1415+ 2                                ;MOV    HEAD,   HEAD_C
 1416+ 2                                ELSE
 1417+ 2  41F8  09                      INC     HEAD
 1418+ 2                                ENDIF
 1419+ 2                                ; <<<<<< MACRO END   <<<<<<
 1420: 1                                __DRAWASCII_DRAWDOT 5
 1421+ 2                                ; >>>>>> MACRO BEGIN >>>>>>
 1422+ 2
 1423+ 2        N      FFFE             IFN     5-7
 1424+ 2                                ELSE
 1425+ 2  41F9  EB                      MOV     A,      R3
 1426+ 2                                ENDIF
 1427+ 2
 1428+ 2  41FA  30 E5 07                JNB     ACC.5,  ??0011
 1429+ 2  41FD  8D F0                   MOV     B,      COLOR
 1430+ 2  41FF  A2 D5                   MOV     C,      F0
 1431+ 2  4201  12 42 68                CALL    RDRAWDOTB
 1432+ 2  4204                  ??0011:
 1433+ 2        N      0005             IFN     5*(5-4)
 1434+ 2
 1435+ 2
 1436+ 2                                MOV     A,      #20H
 1437+ 2                                ADD     A,      HEAD_C0
 1438+ 2                                MOV     HEAD_C0,        A
 1439+ 2                                ORL     C,      F0
 1440+ 2                                MOV     F0,     C
 1441+ 2                                MOV     HEAD,   HEAD_C
 1442+ 2                                ;ELSEIFN        BT
 1443+ 2
 1444+ 2
 1445+ 2                                ;MOV    A,      #20H
 1446+ 2                                ;ADD    A,      HEAD_C0
 1447+ 2                                ;MOV    HEAD_C0,        A
 1448+ 2                                ;ORL    C,      F0
 1449+ 2                                ;MOV    F0,     C
 1450+ 2                                ;MOV    HEAD,   HEAD_C
 1451+ 2                                ELSE
 1452+ 2  4204  09                      INC     HEAD
 1453+ 2                                ENDIF
 1454+ 2                                ; <<<<<< MACRO END   <<<<<<
 1455: 1                                __DRAWASCII_DRAWDOT 4
 1456+ 2                                ; >>>>>> MACRO BEGIN >>>>>>
 1457+ 2
 1458+ 2        N      FFFD             IFN     4-7
 1459+ 2                                ELSE
 1460+ 2  4205  EB                      MOV     A,      R3
 1461+ 2                                ENDIF
 1462+ 2
 1463+ 2  4206  30 E4 07                JNB     ACC.4,  ??0012
 1464+ 2  4209  8D F0                   MOV     B,      COLOR
 1465+ 2  420B  A2 D5                   MOV     C,      F0
 1466+ 2  420D  12 42 68                CALL    RDRAWDOTB
 1467+ 2  4210                  ??0012:
 1468+ 2        N      0000             IFN     4*(4-4)
 1469+ 2
 1470+ 2
 1471+ 2  4210  74 20                   MOV     A,      #20H
 1472+ 2  4212  2C                      ADD     A,      HEAD_C0
 1473+ 2  4213  FC                      MOV     HEAD_C0,        A
 1474+ 2  4214  72 D5                   ORL     C,      F0
 1475+ 2  4216  92 D5                   MOV     F0,     C
 1476+ 2  4218  A9 1C                   MOV     HEAD,   HEAD_C
 1477+ 2                                ;ELSEIFN        BT
 1478+ 2
 1479+ 2
 1480+ 2                                ;MOV    A,      #20H
 1481+ 2                                ;ADD    A,      HEAD_C0
 1482+ 2                                ;MOV    HEAD_C0,        A
 1483+ 2                                ;ORL    C,      F0
 1484+ 2                                ;MOV    F0,     C
 1485+ 2                                ;MOV    HEAD,   HEAD_C
 1486+ 2                                ELSE
 1487+ 2                                INC     HEAD
 1488+ 2                                ENDIF
 1489+ 2                                ; <<<<<< MACRO END   <<<<<<
 1490: 1                                __DRAWASCII_DRAWDOT 3
 1491+ 2                                ; >>>>>> MACRO BEGIN >>>>>>
 1492+ 2
 1493+ 2        N      FFFC             IFN     3-7
 1494+ 2                                ELSE
 1495+ 2  421A  EB                      MOV     A,      R3
 1496+ 2                                ENDIF
 1497+ 2
 1498+ 2  421B  30 E3 07                JNB     ACC.3,  ??0013
 1499+ 2  421E  8D F0                   MOV     B,      COLOR
 1500+ 2  4220  A2 D5                   MOV     C,      F0
 1501+ 2  4222  12 42 68                CALL    RDRAWDOTB
 1502+ 2  4225                  ??0013:
 1503+ 2        N      FFFD             IFN     3*(3-4)
 1504+ 2
 1505+ 2
 1506+ 2                                MOV     A,      #20H
 1507+ 2                                ADD     A,      HEAD_C0
 1508+ 2                                MOV     HEAD_C0,        A
 1509+ 2                                ORL     C,      F0
 1510+ 2                                MOV     F0,     C
 1511+ 2                                MOV     HEAD,   HEAD_C
 1512+ 2                                ;ELSEIFN        BT
 1513+ 2
 1514+ 2
 1515+ 2                                ;MOV    A,      #20H
 1516+ 2                                ;ADD    A,      HEAD_C0
 1517+ 2                                ;MOV    HEAD_C0,        A
 1518+ 2                                ;ORL    C,      F0
 1519+ 2                                ;MOV    F0,     C
 1520+ 2                                ;MOV    HEAD,   HEAD_C
 1521+ 2                                ELSE
 1522+ 2  4225  09                      INC     HEAD
 1523+ 2                                ENDIF
 1524+ 2                                ; <<<<<< MACRO END   <<<<<<
 1525: 1                                __DRAWASCII_DRAWDOT 2
 1526+ 2                                ; >>>>>> MACRO BEGIN >>>>>>
 1527+ 2
 1528+ 2        N      FFFB             IFN     2-7
 1529+ 2                                ELSE
 1530+ 2  4226  EB                      MOV     A,      R3
 1531+ 2                                ENDIF
 1532+ 2
 1533+ 2  4227  30 E2 07                JNB     ACC.2,  ??0014
 1534+ 2  422A  8D F0                   MOV     B,      COLOR
 1535+ 2  422C  A2 D5                   MOV     C,      F0
 1536+ 2  422E  12 42 68                CALL    RDRAWDOTB
 1537+ 2  4231                  ??0014:
 1538+ 2        N      FFFC             IFN     2*(2-4)
 1539+ 2
 1540+ 2
 1541+ 2                                MOV     A,      #20H
 1542+ 2                                ADD     A,      HEAD_C0
 1543+ 2                                MOV     HEAD_C0,        A
 1544+ 2                                ORL     C,      F0
 1545+ 2                                MOV     F0,     C
 1546+ 2                                MOV     HEAD,   HEAD_C
 1547+ 2                                ;ELSEIFN        BT
 1548+ 2
 1549+ 2
 1550+ 2                                ;MOV    A,      #20H
 1551+ 2                                ;ADD    A,      HEAD_C0
 1552+ 2                                ;MOV    HEAD_C0,        A
 1553+ 2                                ;ORL    C,      F0
 1554+ 2                                ;MOV    F0,     C
 1555+ 2                                ;MOV    HEAD,   HEAD_C
 1556+ 2                                ELSE
 1557+ 2  4231  09                      INC     HEAD
 1558+ 2                                ENDIF
 1559+ 2                                ; <<<<<< MACRO END   <<<<<<
 1560: 1                                __DRAWASCII_DRAWDOT 1
 1561+ 2                                ; >>>>>> MACRO BEGIN >>>>>>
 1562+ 2
 1563+ 2        N      FFFA             IFN     1-7
 1564+ 2                                ELSE
 1565+ 2  4232  EB                      MOV     A,      R3
 1566+ 2                                ENDIF
 1567+ 2
 1568+ 2  4233  30 E1 07                JNB     ACC.1,  ??0015
 1569+ 2  4236  8D F0                   MOV     B,      COLOR
 1570+ 2  4238  A2 D5                   MOV     C,      F0
 1571+ 2  423A  12 42 68                CALL    RDRAWDOTB
 1572+ 2  423D                  ??0015:
 1573+ 2        N      FFFD             IFN     1*(1-4)
 1574+ 2
 1575+ 2
 1576+ 2                                MOV     A,      #20H
 1577+ 2                                ADD     A,      HEAD_C0
 1578+ 2                                MOV     HEAD_C0,        A
 1579+ 2                                ORL     C,      F0
 1580+ 2                                MOV     F0,     C
 1581+ 2                                MOV     HEAD,   HEAD_C
 1582+ 2                                ;ELSEIFN        BT
 1583+ 2
 1584+ 2
 1585+ 2                                ;MOV    A,      #20H
 1586+ 2                                ;ADD    A,      HEAD_C0
 1587+ 2                                ;MOV    HEAD_C0,        A
 1588+ 2                                ;ORL    C,      F0
 1589+ 2                                ;MOV    F0,     C
 1590+ 2                                ;MOV    HEAD,   HEAD_C
 1591+ 2                                ELSE
 1592+ 2  423D  09                      INC     HEAD
 1593+ 2                                ENDIF
 1594+ 2                                ; <<<<<< MACRO END   <<<<<<
 1595: 1                                __DRAWASCII_DRAWDOT 0
 1596+ 2                                ; >>>>>> MACRO BEGIN >>>>>>
 1597+ 2
 1598+ 2        N      FFF9             IFN     0-7
 1599+ 2                                ELSE
 1600+ 2  423E  EB                      MOV     A,      R3
 1601+ 2                                ENDIF
 1602+ 2
 1603+ 2  423F  30 E0 07                JNB     ACC.0,  ??0016
 1604+ 2  4242  8D F0                   MOV     B,      COLOR
 1605+ 2  4244  A2 D5                   MOV     C,      F0
 1606+ 2  4246  12 42 68                CALL    RDRAWDOTB
 1607+ 2  4249                  ??0016:
 1608+ 2        N      0000             IFN     0*(0-4)
 1609+ 2
 1610+ 2
 1611+ 2  4249  74 20                   MOV     A,      #20H
 1612+ 2  424B  2C                      ADD     A,      HEAD_C0
 1613+ 2  424C  FC                      MOV     HEAD_C0,        A
 1614+ 2  424D  72 D5                   ORL     C,      F0
 1615+ 2  424F  92 D5                   MOV     F0,     C
 1616+ 2  4251  A9 1C                   MOV     HEAD,   HEAD_C
 1617+ 2                                ;ELSEIFN        BT
 1618+ 2
 1619+ 2
 1620+ 2                                ;MOV    A,      #20H
 1621+ 2                                ;ADD    A,      HEAD_C0
 1622+ 2                                ;MOV    HEAD_C0,        A
 1623+ 2                                ;ORL    C,      F0
 1624+ 2                                ;MOV    F0,     C
 1625+ 2                                ;MOV    HEAD,   HEAD_C
 1626+ 2                                ELSE
 1627+ 2                                INC     HEAD
 1628+ 2                                ENDIF
 1629+ 2                                ; <<<<<< MACRO END   <<<<<<
 1630: 1  4253  DF 86                   DJNZ    COUNT,  __DRAWASCII_0
 1631: 1
 1632: 1                        ; ~__DRAWASCII_0
 1633: 1                                ; <<<<<
 1634: 1  4255  22                      RET
 1635: 1                        ; --------------------------------------------------------------------
 1636: 1                        ;
 1637: 1                        ; @PROC DRAWDOT
 1638: 1                        ; $MC 14
 1639: 1                        ;
 1640: 1                        ; I     DPH     BACK BUFFER
 1641: 1                        ; I     DPL     [3(Y):5(X)]
 1642: 1                        ; IX    CY      SCREEN_SELECTION
 1643: 1                        ; IX  3:0       B       COLOR. should only be lower 4bit value
 1644: 1                        ;
 1645: 1                        ; X     ACC
 1646: 1                        ;
 1647: 1                        ; --------------------------------------------------------------------
 1648: 1                        ; Draws a dot on given location.
 1649: 1  4256                  rDRAWDOT:
 1650: 1                                ; get original value to adapt input value only into lower
 1651: 1                                ;  or higher 4 bit.
 1652: 1  4256  E0                      MOVX    A,      @DPTR
 1653: 1
 1654: 1                                ; if F0 is 1, then the pixel should be drawn on lower
 1655: 1                                ;  screen, which is indicated by lower 4bit RGB value.
 1656: 1  4257  50 06                   JNC     DRAWDOT_LOW
 1657: 1  4259  54 F0                   ANL     A,      #0F0H
 1658: 1  425B  25 F0                   ADD     A,      B
 1659: 1  425D  80 07                   SJMP    DRAWDOT_END
 1660: 1  425F                  DRAWDOT_LOW:
 1661: 1  425F  54 0F                   ANL     A,      #00FH
 1662: 1  4261  C5 F0                   XCH     A,      B
 1663: 1  4263  C4                      SWAP    A
 1664: 1  4264  25 F0                   ADD     A,      B
 1665: 1  4266                  DRAWDOT_END:
 1666: 1  4266  F0                      MOVX    @DPTR,  A
 1667: 1  4267  22                      RET
 1668: 1                        ; --------------------------------------------------------------------
 1669: 1                        ;
 1670: 1                        ; @PROC DRAWDOTB
 1671: 1                        ; $MC 14
 1672: 1                        ;
 1673: 1                        ; I     P2      BACK BUFFER
 1674: 1                        ; I     R1      [3(Y):5(X)]
 1675: 1                        ; IX    CY      SCREEN_SELECTION
 1676: 1                        ; IX [3:0]      B       COLOR. should only be lower 4bit value
 1677: 1                        ;
 1678: 1                        ; X     ACC
 1679: 1                        ;
 1680: 1                        ; --------------------------------------------------------------------
 1681: 1                        ; Draws a dot on given location. Uses P2 and R1 register instead of DPTR.
 1682: 1  4268                  rDRAWDOTB:
 1683: 1                                ; get original value to adapt input value only into lower
 1684: 1                                ;  or higher 4 bit.
 1685: 1  4268  E3                      MOVX    A,      @R1
 1686: 1
 1687: 1                                ; if F0 is 1, then the pixel should be drawn on lower
 1688: 1                                ;  screen, which is indicated by lower 4bit RGB value.
 1689: 1  4269  50 06                   JNC     DRAWDOTB_LOW
 1690: 1  426B  54 F0                   ANL     A,      #0F0H
 1691: 1  426D  25 F0                   ADD     A,      B
 1692: 1  426F  80 07                   SJMP    DRAWDOTB_END
 1693: 1  4271                  DRAWDOTB_LOW:
 1694: 1  4271  54 0F                   ANL     A,      #00FH
 1695: 1  4273  C5 F0                   XCH     A,      B
 1696: 1  4275  C4                      SWAP    A
 1697: 1  4276  25 F0                   ADD     A,      B
 1698: 1  4278                  DRAWDOTB_END:
 1699: 1  4278  F3                      MOVX    @R1,    A
 1700: 1  4279  22                      RET
 1701: 1                        ; --------------------------------------------------------------------
 1702: 1                        ;
 1703: 1                        ; @PROC BUFFER_FRONT
 1704: 1                        ; $MC 7
 1705: 1                        ;
 1706: 1                        ; OUT   ACC     Returns higher byte of current front buffer's
 1707: 1                                        ; address.
 1708: 1                        ;
 1709: 1                        ; -------------------------------------------------------------------
 1710: 1                        ; This interface returns higher byte of current graphics front buffer
 1711: 1                        ;  which is mainly used on display update.
 1712: 1  427A                  rBUFFER_FRONT:
 1713: 1                                ; Loads current buffer value directly onto return value
 1714: 1  427A  30 7F 03                JNB     CURBUFF,        BUFFER_FRONT_0
 1715: 1  427D  74 10                   MOV     A,      #HIGH(GBUFFER1)
 1716: 1  427F  22                      RET
 1717: 1  4280                  BUFFER_FRONT_0:
 1718: 1  4280  74 11                   MOV     A,      #HIGH(GBUFFER2)
 1719: 1  4282  22                      RET
 1720: 1                        ; -------------------------------------------------------------------
 1721: 1                        ;
 1722: 1                        ; @PROC BUFFER_BACK
 1723: 1                        ; $MC 7
 1724: 1                        ;
 1725: 1                        ; 0     ACC     Returns higher byte of current back buffer's
 1726: 1                                        ; address.
 1727: 1                        ;
 1728: 1                        ; --------------------------------------------------------------------
 1729: 1                        ; This interface returns higher byte of current graphics back buffer
 1730: 1                        ;  which is mainly used on gameplay routine's draw call.
 1731: 1  4283                  rBUFFER_BACK:
 1732: 1                                ; Loads flipped current buffer value onto return value.
 1733: 1  4283  30 7F 03                JNB     CURBUFF,        BUFFER_BACK_0
 1734: 1  4286  74 11                   MOV     A,      #HIGH(GBUFFER2)
 1735: 1  4288  22                      RET
 1736: 1  4289                  BUFFER_BACK_0:
 1737: 1  4289  74 10                   MOV     A,      #HIGH(GBUFFER1)
 1738: 1  428B  22                      RET
 1739: 1                        ; --------------------------------------------------------------------
 1740: 1                        ;
 1741: 1                        ; @SPECINT      UPDATE_DISPLAY(void)
 1742: 1                        ; $MC 275~339(OPT_SIZE)
 1743: 1                        ;
 1744: 1                        ; --------------------------------------------------------------------
 1745: 1                        ; This interruption subroutine displays a line onto LED dot matrix per call.
 1746: 1                        ; To enable seamless and light operation, this procedure uses separated register bank.
 1747: 1                        ; This procedure is called per 1840 ticks, and costs 275 ticks for
 1748: 1                        ;  itself, therefore (1840 - 275) * 8 = 12520 ticks can be used for
 1749: 1                        ;  gameplay sequence per frame.
 1750: 1  428C                  iUPDATE_DISPLAY:
 1751: 1        N        01             USING   GPUBANK/8
 1752: 1        B      0090     DP_CLK  SET     P1.0
 1753: 1        B      0091     DP_LAT  SET     P1.1
 1754: 1        B      0092     DP_A    SET     P1.2 ; @notice. this subroutine does not use this.
 1755: 1        B      0093     DP_B    SET     P1.3
 1756: 1        B      0094     DP_C    SET     P1.4
 1757: 1        B      0095     DP_D    SET     P1.5
 1758: 1        R        R1     DP_RGBHL        SET     R1
 1759: 1                                ; Reset timer period
 1760: 1                                ; To keep 60Hz ... 16 ms per frame, 16ms/8 per line,
 1761: 1                                ;  ... 2ms/1.085us ticks per line ==> 1840 ticks per line.
 1762: 1                                ; Therefore the timer register value should be reset as
 1763: 1                                ;        0xffff - 1840 = 0xf8cf
 1764: 1  428C  75 8C F8                MOV     TH0,    #0F8H
 1765: 1  428F  75 8A CF                MOV     TL0,    #0cfH
 1766: 1
 1767: 1  4292  C0 D0                   PUSH    PSW
 1768: 1  4294  75 D0 08                MOV     PSW,    #GPUBANK
 1769: 1
 1770: 1  4297  C0 E0                   PUSH    ACC
 1771: 1  4299  C0 F0                   PUSH    B
 1772: 1  429B  C0 82                   PUSH    DPL
 1773: 1  429D  C0 83                   PUSH    DPH
 1774: 1                                ; >>> >>> >>>
 1775: 1
 1776: 1                                ; Targets OUTPUT port.
 1777: 1  429F  90 C0 00                MOV     DPTR,   #0C000H
 1778: 1                                ; P2 indicates back buffer.
 1779: 1  42A2  51 7A                   CALL    rBUFFER_FRONT
 1780: 1  42A4  F5 A0                   MOV     P2,     A
 1781: 1
 1782: 1                                ; Clear latch
 1783: 1  42A6  C2 91                   CLR     DP_LAT
 1784: 1
 1785: 1                                ; cache current R1 value to keep display line value
 1786: 1  42A8  89 0B                   MOV     AR3,    R1
 1787: 1
 1788: 1                                ; Uses macro to reduce cost from jump command.
 1789: 1                                ; Since the R1 register is holding the latest reading index
 1790: 1                                ;  information and this routine uses separated register
 1791: 1                                ;  bank, any other additional process to ensure its purence
 1792: 1                                ;  doesn't required.
 1793: 1        N      0001     IF      __OPT_SIZE__
 1794: 1  42AA  7A 20                   MOV     R2,     #32
 1795: 1  42AC                  UPDATE_DISPLAY_LINE:
 1796: 1                        ELSE
 1797: 1                                REPT    32
 1798: 1                        ENDIF
 1799: 1                                ;; read data from current address
 1800: 1  42AC  E3                      MOVX    A,      @R1
 1801: 1                                ;; load data onto output RGB port
 1802: 1  42AD  F0                      MOVX    @DPTR,  A
 1803: 1                                ;; prepare to read next data ..
 1804: 1  42AE  09                      INC     R1
 1805: 1  42AF  C2 90                   CLR     DP_CLK
 1806: 1  42B1  D2 90                   SETB    DP_CLK
 1807: 1        N      0001     IF      __OPT_SIZE__
 1808: 1  42B3  DA F7                   DJNZ    R2,     UPDATE_DISPLAY_LINE
 1809: 1                        ELSE
 1810: 1                                ENDM
 1811: 1                        ENDIF
 1812: 1
 1813: 1                                ; Select line which will be rendered
 1814: 1  42B5  EB                      MOV     A,      R3
 1815: 1  42B6  A2 E7                   MOV     C,      ACC.7
 1816: 1  42B8  92 93                   MOV     DP_B,   C
 1817: 1  42BA  A2 E6                   MOV     C,      ACC.6
 1818: 1  42BC  92 94                   MOV     DP_C,   C
 1819: 1  42BE  A2 E5                   MOV     C,      ACC.5
 1820: 1  42C0  92 95                   MOV     DP_D,   C
 1821: 1
 1822: 1                                ; Sets latch to display a RGB line sent.
 1823: 1  42C2  D2 91                   SETB    DP_LAT
 1824: 1
 1825: 1                                ; .When the register R1 is reaches 0, which can notify a
 1826: 1                                ;  frame boundary.
 1827: 1                                ; since A is holding the latest R1 value...
 1828: 1  42C4  70 07                   JNZ     UPDATE_DISPLAY_FRAME_BOUNDARY
 1829: 1  42C6  B2 7E                   CPL     FRAMEBOUND60
 1830: 1  42C8  30 7E 02                JNB     FRAMEBOUND60, UPDATE_DISPLAY_FRAME_BOUNDARY
 1831: 1  42CB  D2 7D                   SETB    FRAMEBOUND30
 1832: 1  42CD                  UPDATE_DISPLAY_FRAME_BOUNDARY:
 1833: 1
 1834: 1                                ; <<< <<< <<<
 1835: 1  42CD  D0 83                   POP     DPH
 1836: 1  42CF  D0 82                   POP     DPL
 1837: 1  42D1  D0 F0                   POP     B
 1838: 1  42D3  D0 E0                   POP     ACC
 1839: 1
 1840: 1  42D5  D0 D0                   POP     PSW
 1841: 1
 1842: 1                                ; Restore P2 value
 1843: 1                                PEAKP2  P2
 1844+ 2  42D7  85 36 A0                MOV     P2,     GLB_P2CACHE
 1845: 1
 1846: 1                                ;INC    RANDNUM
 1847: 1
 1848: 1  42DA  32                      RETI
 1849: 1                        ; --------------------------------------------------------------------
 1850: 1                        ;; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1851: 1
 1852: 1                        ENDIF
 1853:                          $INCLUDE        (UTILS.INC)
 1854: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1855: 1                        DEFINE_MODULE   UTILS ; Change this as you want.
 1856+ 2        N      0001             IFN     ____UTILS
 1857+ 2                        ____UTILS       SET     1
 1858: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1859: 1                        ;
 1860: 1                        ;       TemplateModule
 1861: 1                        ;
 1862: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1863: 1                        ;       DESCRIPTION
 1864: 1                        ; Write down the description of this module.
 1865: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 1866: 1                        ; ######### SUBROUTINES & MACROS #####################################
 1867: 1                        ;
 1868: 1                        ; ¬ß LIST OF PREFIXES:: PROC, SPEC[0-9a-zA-Z_]*, CALBAK
 1869: 1                        ;
 1870: 1                        ;       Prefix PROC indicates a general callable procedure which
 1871: 1                        ;        indicates an interface function.
 1872: 1                        ;
 1873: 1                        ;       Prefix SPEC[..] indicates a special purpose function which
 1874: 1                        ;        should be called only in specific sequence.
 1875: 1                        ;        All of the rules about prefix words and procedure concepts
 1876: 1                        ;        should be concretely defined.
 1877: 1                        ;
 1878: 1                        ;       Prefix CALBAK indicates a procedure is callback which fits
 1879: 1                        ;        in specific calling protocol.
 1880: 1                        ;
 1881: 1                        ; --------------------------------------------------------------------
 1882: 1                        ; #MACRO        STRING  LITERAL
 1883: 1                        ; --------------------------------------------------------------------
 1884: 1                        STRING  MACRO   LBL, LTRL
 1885: 1                                LOCAL   ECC
 1886: 1                                SJMP    ECC
 1887: 1                        LBL:    DB      LTRL, 0
 1888: 1                        ECC:
 1889: 1                        ENDM
 1890: 1                        ; --------------------------------------------------------------------
 1891: 1                        ; #MACRO        NEG     A
 1892: 1                        ; --------------------------------------------------------------------
 1893: 1                        ; Negates A
 1894: 1                        NEG     MACRO   _A
 1895: 1                                CPL     _A
 1896: 1                                INC     _A
 1897: 1                        ENDM
 1898: 1                        ; --------------------------------------------------------------------
 1899: 1                        ; --------------------------------------------------------------------
 1900: 1                        ; #MACRO        MOVP2   VAL
 1901: 1                        ; --------------------------------------------------------------------
 1902: 1                        MOVP2   MACRO   VAL
 1903: 1                                MOV     GLB_P2CACHE,VAL
 1904: 1                                MOV     P2,     VAL
 1905: 1                                ENDM
 1906: 1                        ; --------------------------------------------------------------------
 1907: 1                        ; #MACRO        LDP2CDW P2, RN, CONSTDW
 1908: 1                        ; --------------------------------------------------------------------
 1909: 1                        LDCDWP2 MACRO   _RN, CONSTDW
 1910: 1                                MOVP2           #HIGH(CONSTDW)
 1911: 1                                MOV     _RN,    #LOW(CONSTDW)
 1912: 1                                ENDM
 1913: 1                        ; --------------------------------------------------------------------
 1914: 1                        ; #MACRO        LOADCDW HI, LO, CONSTDW
 1915: 1                        ; --------------------------------------------------------------------
 1916: 1                        LDCDW   MACRO   HI, LO, CONSTDW
 1917: 1                                MOV     HI,     #HIGH(CONSTDW)
 1918: 1                                MOV     LO,     #LOW(CONSTDW)
 1919: 1                                ENDM
 1920: 1                        ; --------------------------------------------------------------------
 1921: 1                        ; #MACRO        PEAKP2  TGET
 1922: 1                        ; --------------------------------------------------------------------
 1923: 1                        PEAKP2  MACRO   TGET
 1924: 1                                MOV     TGET,   GLB_P2CACHE
 1925: 1                                ENDM
 1926: 1                        ; --------------------------------------------------------------------
 1927: 1                        ; #MACRO        PUSHP2
 1928: 1                        ; --------------------------------------------------------------------
 1929: 1                        PUSHP2  MACRO
 1930: 1                                PUSH    GLB_P2CACHE
 1931: 1                                ENDM
 1932: 1                        ; --------------------------------------------------------------------
 1933: 1                        ; #MACRO        POPP2
 1934: 1                        ; --------------------------------------------------------------------
 1935: 1                        POPP2   MACRO
 1936: 1                                POP     GLB_P2CACHE
 1937: 1                                PEAKP2  P2
 1938: 1                                ENDM
 1939: 1                        ; --------------------------------------------------------------------
 1940: 1                        ; #MACRO        DCALL   IDPTR
 1941: 1                        ;       X A, DPTR
 1942: 1                        ; --------------------------------------------------------------------
 1943: 1                        ; Calls function dynamically on dptr
 1944: 1                        DCALL   MACRO   IDPTR
 1945: 1                                LOCAL   BACK
 1946: 1                                MOV     A,      #LOW(BACK)
 1947: 1                                PUSH    ACC
 1948: 1                                MOV     A,      #HIGH(BACK)
 1949: 1                                PUSH    ACC
 1950: 1                                MOV     A,      #0
 1951: 1                                JMP     @A+IDPTR
 1952: 1                        BACK:
 1953: 1                                ENDM
 1954: 1                        ; --------------------------------------------------------------------
 1955: 1                        ; #MACRO        MOVW    OP1(W), OP2(DW)
 1956: 1                        ; --------------------------------------------------------------------
 1957: 1                        ; Moves a word from op2 to op1. Operand should be directly addressed.
 1958: 1                        MOVW    MACRO   OP1, OP2
 1959: 1                                MOV     OP1,    OP2
 1960: 1                                MOV     OP1+1,  OP2+1
 1961: 1                                ENDM
 1962: 1                        ; --------------------------------------------------------------------
 1963: 1                        ;
 1964: 1                        ; @PROC ADDSEP
 1965: 1                        ;
 1966: 1                        ; I     R1      OPERAND 1
 1967: 1                        ; I     R2      OPERAND 2
 1968: 1                        ; OUT   A       RESULT
 1969: 1                        ;
 1970: 1                        ; X     B
 1971: 1                        ;
 1972: 1                        ; --------------------------------------------------------------------
 1973: 1                        ; Performs signed addition operation, seprately upper and lower 4bits
 1974: 1                        rADDSEP:        MOV     A,      R1
 1975: 1                                ADD     A,      R2
 1976: 1                                PUSH    ACC
 1977: 1                                MOV     A,      R1
 1978: 1                                ANL     A,      #0F0H
 1979: 1                                ADD     A,      R2
 1980: 1                                ANL     A,      #0F0H
 1981: 1                                MOV     B,      A
 1982: 1                                POP     ACC
 1983: 1                                ANL     A,      #00FH
 1984: 1                                ADD     A,      B
 1985: 1                                RET
 1986: 1                        ; --------------------------------------------------------------------
 1987: 1                        ;
 1988: 1                        ; @PROC MEMSET
 1989: 1                        ;
 1990: 1                        ; I     B       MEM TO SET
 1991: 1                        ; IX    DPTR    BEGIN
 1992: 1                        ; IX    R1:R0   SIZE TO CLEAR
 1993: 1                        ;
 1994: 1                        ; X     A
 1995: 1                        ;
 1996: 1                        ; --------------------------------------------------------------------
 1997: 1                        rMEMSET:        ; Set memory
 1998: 1                                MOV     A,      B
 1999: 1                                MOVX    @DPTR,  A
 2000: 1                                INC     DPTR
 2001: 1                                ; To next index
 2002: 1                                MOV     A,      R0
 2003: 1                                CLR     C
 2004: 1                                SUBB    A,      #1
 2005: 1                                MOV     R0,     A
 2006: 1                                MOV     A,      R1
 2007: 1                                SUBB    A,      #0
 2008: 1                                MOV     R1,     A
 2009: 1                                ; Check if done
 2010: 1                                JNZ     rMEMSET
 2011: 1                                MOV     A,      R0
 2012: 1                                JNZ     rMEMSET
 2013: 1                                ; If input size has turned to zero, return.
 2014: 1                                RET
 2015: 1                        ; --------------------------------------------------------------------
 2016: 1                        ;
 2017: 1                        ; @PROC DTOA
 2018: 1                        ;
 2019: 1                        ; I     B       Input BCD
 2020: 1                        ; I     DPTR    String location
 2021: 1                        ; OUT   DPTR    New string location, '\0' stored.
 2022: 1                        ;
 2023: 1                        ; X     ACC
 2024: 1                        ;
 2025: 1                        ; -------------------------------------------------------------------
 2026: 1                        ; Appends decimal to ascii result into given string location.
 2027: 1                        ; Behavior is undefined if given B value is not a BCD number.
 2028: 1                        rDTOA:  MOV     A,      B
 2029: 1                                ; First, masks upper 4bit and draw it to lower place.
 2030: 1                                ANL     A,      #0F0H
 2031: 1                                SWAP    A
 2032: 1                                ; Then makes it a ASCII code
 2033: 1                                ADD     A,      #'0'
 2034: 1                                ; Store it
 2035: 1                                MOVX    @DPTR,  A
 2036: 1                                ; Repeat this to lower 4bits
 2037: 1                                INC     DPTR
 2038: 1                                MOV     A,      B
 2039: 1                                ANL     A,      #0FH
 2040: 1                                ADD     A,      #'0'
 2041: 1                                MOVX    @DPTR,  A
 2042: 1                                ; Append null character at the end of the string.
 2043: 1                                INC     DPTR
 2044: 1                                MOV     A,      #0
 2045: 1                                MOVX    @DPTR,  A
 2046: 1                                RET
 2047: 1                        ; --------------------------------------------------------------------
 2048: 1                        ;
 2049: 1                        ; @PROC ADDBLKSEP
 2050: 1                        ;
 2051: 1                        ; IX    A       OP1
 2052: 1                        ; I     R2      OP2
 2053: 1                        ; OUT   A       RESULT
 2054: 1                        ;
 2055: 1                        ; X     B
 2056: 1                        ;
 2057: 1                        ; --------------------------------------------------------------------
 2058: 1                        ; Adds two signed number, which are the 4bit-4bit separated format.
 2059: 1                        rADDBLKSEP:
 2060: 1                                PUSH    ACC
 2061: 1                                ; Adds upper 4bit first.
 2062: 1                                ANL     A,      #0F0H
 2063: 1                                ADD     A,      R2
 2064: 1                                ANL     A,      #0F0H
 2065: 1                                ; Adds lower 4bit
 2066: 1                                MOV     B,      A
 2067: 1                                POP     ACC
 2068: 1                                ADD     A,      R2
 2069: 1                                ANL     A,      #00FH
 2070: 1                                ; Adds each value other.
 2071: 1                                ADD     A,      B
 2072: 1                                RET
 2073: 1                        ; --------------------------------------------------------------------
 2074: 1                        ;
 2075: 1                        ; @PROC DELAY
 2076: 1                        ;
 2077: 1                        ; I     A       Milliseconds to delay
 2078: 1                        ; XX    B
 2079: 1                        ;
 2080: 1                        ; --------------------------------------------------------------------
 2081: 1                        rDELAY: MOV     B,      #230
 2082: 1                        DELAY_0:        NOP
 2083: 1                                NOP
 2084: 1                                DJNZ    B,      DELAY_0
 2085: 1                                DJNZ    ACC,    rDELAY
 2086: 1                                RET
 2087: 1                        ; --------------------------------------------------------------------
 2088: 1                        ;
 2089: 1                        ; @PROC ITOA
 2090: 1                        ;
 2091: 1                        ; --------------------------------------------------------------------
 2092: 1
 2093: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2094: 1
 2095: 1                        ENDIF
 2096:                          $INCLUDE        (RANKING.INC)
 2097: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2098: 1                        ; DEFINE_MODULE SSN_TMPLT??? ; This isn't required on session definition
 2099: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2100: 1                        LOCMEM_PVT
 2101+ 2        N      2000     LOCAL_MEMORY SET        2000H
 2102: 1                        LBIT_PVT
 2103+ 2  42DB                  ??0017:
 2104+ 2        N      0000     IF      ??0017 < 4000H
 2105+ 2                        $ERROR  ("LBIT should be placed after code segment.")
 2106+ 2                        ENDIF
 2107+ 2        N      007B     __LB_PIVOT      SET     __INTB_OFST
 2108: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2109: 1                        ;
 2110: 1                        ;       SSN_TMPLT
 2111: 1                        ;
 2112: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2113: 1                        ;       DESCRIPTION
 2114: 1                        ; This is ranking session which will be used for recording final score
 2115: 1                        ;of any game. Transition to this session will be occured when the end
 2116: 1                        ;of any game session or pressing home button. It transites to title
 2117: 1                        ;session when the home button pressed, with or without recording score
 2118: 1                        ;by recording flag.
 2119: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2120: 1                        ; ######### SUBROUTINES & MACROS #####################################
 2121: 1                        ;
 2122: 1                        ; ¬ß LIST OF PREFIXES:: PROC, SPEC[0-9a-zA-Z_]*, CALBAK
 2123: 1                        ;
 2124: 1                        ;       Prefix PROC indicates a general callable procedure which
 2125: 1                        ;        indicates an interface function.
 2126: 1                        ;
 2127: 1                        ;       Prefix SPEC[..] indicates a special purpose function which
 2128: 1                        ;        should be called only in specific sequence.
 2129: 1                        ;        All of the rules about prefix words and procedure concepts
 2130: 1                        ;        should be concretely defined.
 2131: 1                        ;
 2132: 1                        ;       Prefix CALBAK indicates a procedure is callback which fits
 2133: 1                        ;        in specific calling protocol.
 2134: 1                        ;
 2135: 1                        ; --------------------------------------------------------------------
 2136: 1                        ; @NOTE LOADCDW HI, LO, CONST
 2137: 1                        ; @NOTE MOVP2   VAL
 2138: 1                        ; --------------------------------------------------------------------
 2139: 1                        ;
 2140: 1                        ;       LOCAL MEMORY ALLOCATIONS
 2141: 1                        ;
 2142: 1                        ; TYPE     |IDENTIFIER |SIZE/DESCRIPTION
 2143: 1                        ; ---------|-----------|----------------------------------------------
 2144: 1
 2145: 1                        ; --------------------------------------------------------------------
 2146: 1                        ;
 2147: 1                        ; @PROC SESSION_INIT
 2148: 1                        ; @note It is recommended to define a general purpose session initializer
 2149: 1                        ;        to easy access to different session.
 2150: 1                        ;       This procedure should contain the code segment calling TRANSITION
 2151: 1                        ;        procedure, which requires following CALLBACK arguments:
 2152: 1                        ;
 2153: 1                        ;       I X     DPH:DPL INPUT
 2154: 1                        ;       I X     R1:R0   UPDATE
 2155: 1                        ;       I X     R3:R2   DYNAMIC DRAW CALL
 2156: 1                        ;       I X     R5:R4   SESSION INITIALIZER
 2157: 1                        ;       I X     R7:R6   STATIC DRAW CALL
 2158: 1                        ;
 2159: 1                        ; --------------------------------------------------------------------
 2160: 1  42DB                  rTORANKING:
 2161: 1                        ; Ranking initialize ... if score is lower than current max, does nothing.
 2162: 1                                ; <> Check given game score is larger than current highst score.
 2163: 1                        ; ++++ compares RANKING_SCORE and SCORES + RANKING_GAMEINFO*4
 2164: 1                                ; Gets current highst score's address
 2165: 1                                LDCDWP2 R1,     RANKING_HIGHST
 2166+ 2                                MOVP2           #HIGH(RANKING_HIGHST)
 2167+ 3  42DB  75 36 12                MOV     GLB_P2CACHE,#HIGH(RANKING_HIGHST)
 2168+ 3  42DE  75 A0 12                MOV     P2,     #HIGH(RANKING_HIGHST)
 2169+ 2  42E1  79 25                   MOV     R1,     #LOW(RANKING_HIGHST)
 2170: 1  42E3  90 12 20                MOV     DPTR,   #RANKING_GAMEINFO
 2171: 1  42E6  E0                      MOVX    A,      @DPTR
 2172: 1                                ; A << 2 = A * 4
 2173: 1  42E7  23                      RL      A
 2174: 1  42E8  23                      RL      A
 2175: 1                                ; Add this to R1, which indicates lower word of ext. address
 2176: 1  42E9  29                      ADD     A,      R1
 2177: 1  42EA  F9                      MOV     R1,     A
 2178: 1  42EB  FC                      MOV     R4,     A
 2179: 1                                ; Get current score
 2180: 1  42EC  90 12 21                MOV     DPTR,   #RANKING_SCORE
 2181: 1
 2182: 1                                ; for 4 bytes integer...
 2183: 1  42EF  7A 04                   MOV     R2,     #4
 2184: 1  42F1  C3                      CLR     C
 2185: 1  42F2                  TORANKING_0:
 2186: 1                                ; Game info score - incoming score... C ? HIGHST : NOP
 2187: 1  42F2  E0                      MOVX    A,      @DPTR
 2188: 1  42F3  F5 F0                   MOV     B,      A
 2189: 1  42F5  E3                      MOVX    A,      @R1
 2190: 1  42F6  95 F0                   SUBB    A,      B
 2191: 1
 2192: 1  42F8  09                      INC     R1
 2193: 1  42F9  05 82                   INC     DPL
 2194: 1
 2195: 1  42FB  DA F5                   DJNZ    R2,     TORANKING_0
 2196: 1                        ; ~~TORANKING_0
 2197: 1                                ; If carry bit is activated, assign incoming score as new value.
 2198: 1  42FD  40 04                   JC      TORANKING_DISP
 2199: 1                                ; f.    calls return callback.
 2200: 1  42FF  12 43 80                CALL    cRETURNTOSESSION
 2201: 1  4302  22                      RET
 2202: 1  4303                  TORANKING_DISP:
 2203: 1                                ; t.    [] sets given score as new highst score.
 2204: 1  4303  EC                      MOV     A,      R4
 2205: 1  4304  F9                      MOV     R1,     A
 2206: 1  4305  90 12 21                MOV     DPTR,   #RANKING_SCORE
 2207: 1
 2208: 1  4308  7A 04                   MOV     R2,     #4
 2209: 1  430A                  TORANKING_1:
 2210: 1                                ; Copies new value into ranking.
 2211: 1  430A  E0                      MOVX    A,      @DPTR
 2212: 1  430B  F3                      MOVX    @R1,    A
 2213: 1
 2214: 1  430C  09                      INC     R1
 2215: 1  430D  05 82                   INC     DPL
 2216: 1
 2217: 1  430F  DA F9                   DJNZ    R2,     TORANKING_1
 2218: 1                        ; ~~TORANKING_1
 2219: 1                                ; Display "NEW HIGHST SCORE" screen for 3 secs.
 2220: 1                                ; Clear memory
 2221: 1                                ;MOV    DPTR,   #2000H
 2222: 1                                ;LDCDW  R1,R0,  2000H
 2223: 1                                ;MOV    B,      #0
 2224: 1                                ;CALL   rMEMSET
 2225: 1                                ; Assign input procedure
 2226: 1  4311  90 4B 16                MOV     DPTR,   #NULLF
 2227: 1                                ; Assign update procedure
 2228: 1                                LDCDW   R1,R0,  NULLF
 2229+ 2  4314  79 4B                   MOV     R1,     #HIGH(NULLF)
 2230+ 2  4316  78 16                   MOV     R0,     #LOW(NULLF)
 2231: 1                                ; Assign draw call procedure
 2232: 1                                LDCDW   R3,R2,  NULLF
 2233+ 2  4318  7B 4B                   MOV     R3,     #HIGH(NULLF)
 2234+ 2  431A  7A 16                   MOV     R2,     #LOW(NULLF)
 2235: 1                                ; Assign session initializer
 2236: 1                                LDCDW   R5,R4,  cRANKINIT
 2237+ 2  431C  7D 43                   MOV     R5,     #HIGH(cRANKINIT)
 2238+ 2  431E  7C 29                   MOV     R4,     #LOW(cRANKINIT)
 2239: 1                                ; Assign static draw call
 2240: 1                                LDCDW   R7,R6,  cRANKDRAW
 2241+ 2  4320  7F 43                   MOV     R7,     #HIGH(cRANKDRAW)
 2242+ 2  4322  7E 42                   MOV     R6,     #LOW(cRANKDRAW)
 2243: 1                                ; Clear if the timer should not be reset.
 2244: 1  4324  D3                      SETB    C
 2245: 1                                ; Calls the transition function.
 2246: 1                                ; It is recommended to place this line last.
 2247: 1  4325  12 4B 44                CALL    rTRANSITION
 2248: 1  4328  22                      RET
 2249: 1                        ; --------------------------------------------------------------------
 2250: 1                        ; @CALBAK       RANKINIT
 2251: 1                        ; --------------------------------------------------------------------
 2252: 1                        ; Initializes return timer.
 2253: 1  4329                  cRANKINIT:
 2254: 1                                LDCDW   BR1,    BR0,    60
 2255+ 2  4329  75 21 00                MOV     BR1,    #HIGH(60)
 2256+ 2  432C  75 20 3C                MOV     BR0,    #LOW(60)
 2257: 1                                LDCDW   R1,     R0,     cRETURNTOSESSION
 2258+ 2  432F  79 43                   MOV     R1,     #HIGH(cRETURNTOSESSION)
 2259+ 2  4331  78 80                   MOV     R0,     #LOW(cRETURNTOSESSION)
 2260: 1  4333  12 4B 17                CALL    rSET_TIMER
 2261: 1  4336  22                      RET
 2262: 1                        ; --------------------------------------------------------------------
 2263: 1                        ; @CALBAK       RANKDRAW
 2264: 1                        ; --------------------------------------------------------------------
 2265: 1                        ; Displays new highscore
 2266: 1                        STRING  RANKSTR,        'HISCORE!'
 2267+ 2  4337  80 09                   SJMP    ??0018
 2268+ 2  4339  48 49 53 43     RANKSTR:        DB      'HISCORE!', 0
       2  433D  4F 52 45 21
       2  4341  00
 2269+ 2  4342                  ??0018:
 2270: 1                        LOCMEM  STRCACHE,       10
 2271+ 2        N      2000     STRCACHE        SET     LOCAL_MEMORY
 2272+ 2        N      200A     LOCAL_MEMORY SET        LOCAL_MEMORY+10
 2273+ 2        N      0000     IF      LOCAL_MEMORY>=4000H
 2274+ 2                        $ERROR  ("EXTERNAL MEMORY OVERFLOW")
 2275+ 2                        ENDIF
 2276: 1  4342                  cRANKDRAW:
 2277: 1                                ; Clears screen
 2278: 1  4342  74 00                   MOV     A,      #0
 2279: 1  4344  11 73                   CALL    rFILLBUFFER
 2280: 1
 2281: 1                                ; Draws 'HISCORE' string.
 2282: 1  4346  C2 D5                   CLR     F0
 2283: 1  4348  51 83                   CALL    rBUFFER_BACK
 2284: 1                                MOVP2   A
 2285+ 2  434A  F5 36                   MOV     GLB_P2CACHE,A
 2286+ 2  434C  F5 A0                   MOV     P2,     A
 2287: 1
 2288: 1  434E  79 20                   MOV     R1,     #00100000B
 2289: 1  4350  90 43 39                MOV     DPTR,   #RANKSTR
 2290: 1  4353  75 F0 07                MOV     B,      #111B
 2291: 1
 2292: 1  4356  31 7C                   CALL    rDRAWSTRING
 2293: 1
 2294: 1                                ; Draws current score.
 2295: 1                                ; Make current score to string
 2296: 1  4358  90 20 00                MOV     DPTR,   #STRCACHE
 2297: 1                                LDCDWP2 R1,     RANKING_SCORE+3
 2298+ 2                                MOVP2           #HIGH(RANKING_SCORE+3)
 2299+ 3  435B  75 36 12                MOV     GLB_P2CACHE,#HIGH(RANKING_SCORE+3)
 2300+ 3  435E  75 A0 12                MOV     P2,     #HIGH(RANKING_SCORE+3)
 2301+ 2  4361  79 24                   MOV     R1,     #LOW(RANKING_SCORE+3)
 2302: 1
 2303: 1  4363  7B 04                   MOV     R3,     #4
 2304: 1  4365                  RANKDRAW_DTOA:
 2305: 1                                ; Get number
 2306: 1  4365  E3                      MOVX    A,      @R1
 2307: 1  4366  F5 F0                   MOV     B,      A
 2308: 1  4368  19                      DEC     R1
 2309: 1                                ; to string
 2310: 1  4369  11 41                   CALL    rDTOA
 2311: 1  436B  DB F8                   DJNZ    R3,     RANKDRAW_DTOA
 2312: 1                        ; ~~RANKDRAW_DTOA
 2313: 1
 2314: 1                                ; print string
 2315: 1  436D  D2 D5                   SETB    F0
 2316: 1  436F  51 83                   CALL    rBUFFER_BACK
 2317: 1                                MOVP2   A
 2318+ 2  4371  F5 36                   MOV     GLB_P2CACHE,A
 2319+ 2  4373  F5 A0                   MOV     P2,     A
 2320: 1
 2321: 1  4375  79 20                   MOV     R1,     #00100000B
 2322: 1  4377  90 20 00                MOV     DPTR,   #STRCACHE
 2323: 1  437A  75 F0 06                MOV     B,      #110B
 2324: 1
 2325: 1  437D  31 7C                   CALL    rDRAWSTRING
 2326: 1
 2327: 1                                ; done.
 2328: 1  437F  22                      RET
 2329: 1                        ; --------------------------------------------------------------------
 2330: 1                        ; @CALBAK       RETURN_ORG
 2331: 1                        ; --------------------------------------------------------------------
 2332: 1  4380                  cRETURNTOSESSION:
 2333: 1                                ; CLEAR SCORE.
 2334: 1  4380  7A 04                   MOV     R2,     #4
 2335: 1  4382  90 12 21                MOV     DPTR,   #RANKING_SCORE
 2336: 1  4385  74 00                   MOV     A,      #0
 2337: 1  4387                  RETURNTOSESSION_FINALIZE:
 2338: 1  4387  F0                      MOVX    @DPTR,  A
 2339: 1  4388  05 82                   INC     DPL
 2340: 1  438A  DA FB                   DJNZ    R2,     RETURNTOSESSION_FINALIZE
 2341: 1                        ; ~~ RETURNTOSESSION_FINALIZE
 2342: 1
 2343: 1                                LDCDWP2 R1,     RANKING_RETURN
 2344+ 2                                MOVP2           #HIGH(RANKING_RETURN)
 2345+ 3  438C  75 36 12                MOV     GLB_P2CACHE,#HIGH(RANKING_RETURN)
 2346+ 3  438F  75 A0 12                MOV     P2,     #HIGH(RANKING_RETURN)
 2347+ 2  4392  79 0A                   MOV     R1,     #LOW(RANKING_RETURN)
 2348: 1                                ; Load returning session to DPTR
 2349: 1  4394  E3                      MOVX    A,      @R1
 2350: 1  4395  F5 82                   MOV     DPL,    A
 2351: 1  4397  09                      INC     R1
 2352: 1  4398  E3                      MOVX    A,      @R1
 2353: 1  4399  F5 83                   MOV     DPH,    A
 2354: 1                                ; DCALL
 2355: 1                                DCALL   DPTR
 2356+ 2  439B  74 A6                   MOV     A,      #LOW(??0019)
 2357+ 2  439D  C0 E0                   PUSH    ACC
 2358+ 2  439F  74 43                   MOV     A,      #HIGH(??0019)
 2359+ 2  43A1  C0 E0                   PUSH    ACC
 2360+ 2  43A3  74 00                   MOV     A,      #0
 2361+ 2  43A5  73                      JMP     @A+DPTR
 2362+ 2  43A6                  ??0019:
 2363: 1  43A6  22                      RET
 2364: 1                        ; --------------------------------------------------------------------
 2365: 1                        ;
 2366: 1                        ; @PROC InitScore
 2367: 1                        ;
 2368: 1                        ; X     DPTR, ACC
 2369: 1                        ;
 2370: 1                        ; --------------------------------------------------------------------
 2371: 1  43A7                  rINITSCORE:
 2372: 1  43A7  C0 20                   PUSH    BR0
 2373: 1
 2374: 1                                ; >>>>>>
 2375: 1  43A9  90 12 21                MOV     DPTR,   #RANKING_SCORE
 2376: 1  43AC  75 20 04                MOV     BR0,    #4
 2377: 1  43AF  74 00                   MOV     A,      #0
 2378: 1
 2379: 1  43B1  F0              INITSCORE0:     MOVX    @DPTR,  A
 2380: 1  43B2  05 82                   INC     DPL
 2381: 1  43B4  D5 20 FA                DJNZ    BR0,    INITSCORE0
 2382: 1
 2383: 1                                ; <<<<<<
 2384: 1  43B7  D0 20                   POP     BR0
 2385: 1  43B9  22                      RET
 2386: 1                        ; --------------------------------------------------------------------
 2387: 1                        ;
 2388: 1                        ; @PROC AddScore
 2389: 1                        ;
 2390: 1                        ; I     B       SCORE_BCD
 2391: 1                        ;
 2392: 1                        ; X     A, DPTR
 2393: 1                        ;
 2394: 1                        ; --------------------------------------------------------------------\
 2395: 1                        ; Adds score to ranking_score cache.
 2396: 1  43BA  C0 20           rADDSCORE:      PUSH    BR0
 2397: 1
 2398: 1                                ; >>>>>>
 2399: 1                                ; Set memory location
 2400: 1  43BC  90 12 21                MOV     DPTR,   #RANKING_SCORE
 2401: 1
 2402: 1                                ; 1st byte
 2403: 1  43BF  E0                      MOVX    A,      @DPTR
 2404: 1  43C0  25 F0                   ADD     A,      B
 2405: 1  43C2  D4                      DA      A
 2406: 1  43C3  F0                      MOVX    @DPTR,  A
 2407: 1
 2408: 1                                ; 2nd-4th byte
 2409: 1  43C4  75 20 03                MOV     BR0,    #3
 2410: 1  43C7                  ADDSCORE_LP:
 2411: 1                        ; Adds score by repeatation.
 2412: 1                                ; Next addres
 2413: 1  43C7  A3                      INC     DPTR
 2414: 1  43C8  E0                      MOVX    A,      @DPTR
 2415: 1                                ; Adds carry
 2416: 1  43C9  34 00                   ADDC    A,      #0
 2417: 1                                ; BCD correction
 2418: 1  43CB  D4                      DA      A
 2419: 1                                ; Load to memory
 2420: 1  43CC  F0                      MOVX    @DPTR,  A
 2421: 1  43CD  D5 20 F7                DJNZ    BR0,    ADDSCORE_LP
 2422: 1
 2423: 1                                ; <<<<<<
 2424: 1  43D0  D0 20                   POP     BR0
 2425: 1  43D2  22                      RET
 2426: 1                        ; --------------------------------------------------------------------
 2427: 1                        ; @CALBAK       INPUTCALLBACK
 2428: 1                        ; @NOTE         BUTTON.6        L
 2429: 1                        ;       BUTTON.5        D
 2430: 1                        ;       BUTTON.4        U
 2431: 1                        ;       BUTTON.3        R
 2432: 1                        ;       BUTTON.2        ACTA
 2433: 1                        ;       BUTTON.1        ACTB
 2434: 1                        ;       BUTTON.0        HOME
 2435: 1                        ;
 2436: 1                        ; I     R0      KEYDOWN
 2437: 1                        ; I     R1      KEYUP
 2438: 1                        ; I     R2      KEYHOLD
 2439: 1                        ; --------------------------------------------------------------------
 2440: 1                        ; @CALBAK       UPDATECALLBACK(VOID)
 2441: 1                        ; --------------------------------------------------------------------
 2442: 1                        ; @CALBAK       DYNAMICDRAWCALLBACK
 2443: 1                        ; I     B       BACKBUFFERHI
 2444: 1                        ; --------------------------------------------------------------------
 2445: 1                        ; @CALBAK       INITIALIZERCALLBACK(VOID)
 2446: 1                        ; --------------------------------------------------------------------
 2447: 1                        ; @CALBAK       STATICDRAWCALLBAK
 2448: 1                        ; I     B       BACKBUFFERHI
 2449: 1                        ; --------------------------------------------------------------------
 2450: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2451:                          ; --------------------------------------------------------------------
 2452:                          ; Session inclusions should be placed below this line.
 2453:                          $INCLUDE        (SSN_TITLE.INC)
 2454: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2455: 1                        ; DEFINE_MODULE SSN_TITLE ; Change this as you want.
 2456: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2457: 1                        LOCMEM_PVT
 2458+ 2        N      2000     LOCAL_MEMORY SET        2000H
 2459: 1                        LBIT_PVT
 2460+ 2  43D3                  ??0020:
 2461+ 2        N      0000     IF      ??0020 < 4000H
 2462+ 2                        $ERROR  ("LBIT should be placed after code segment.")
 2463+ 2                        ENDIF
 2464+ 2        N      007B     __LB_PIVOT      SET     __INTB_OFST
 2465: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2466: 1                        ;
 2467: 1                        ;       SSN_TITLE
 2468: 1                        ;
 2469: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2470: 1                        ;       DESCRIPTION
 2471: 1                        ; Write down the description of this module.
 2472: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2473: 1                        ; ######### SUBROUTINES & MACROS #####################################
 2474: 1                        ;
 2475: 1                        ; ¬ß LIST OF PREFIXES:: PROC, SPEC[0-9a-zA-Z_]*, CALBAK
 2476: 1                        ;
 2477: 1                        ;       Prefix PROC indicates a general callable procedure which
 2478: 1                        ;        indicates an interface function.
 2479: 1                        ;
 2480: 1                        ;       Prefix SPEC[..] indicates a special purpose function which
 2481: 1                        ;        should be called only in specific sequence.
 2482: 1                        ;        All of the rules about prefix words and procedure concepts
 2483: 1                        ;        should be concretely defined.
 2484: 1                        ;
 2485: 1                        ;       Prefix CALBAK indicates a procedure is callback which fits
 2486: 1                        ;        in specific calling protocol.
 2487: 1                        ;
 2488: 1                        ; --------------------------------------------------------------------
 2489: 1                        ; @NOTE LOADCDW HI, LO, CONST
 2490: 1                        ; @NOTE MOVP2   VAL
 2491: 1                        ; --------------------------------------------------------------------
 2492: 1                        ;
 2493: 1                        ;       LOCAL MEMORY ALLOCATIONS
 2494: 1                        ;
 2495: 1                        ; TYPE     |IDENTIFIER |SIZE/DESCRIPTION
 2496: 1                        ; ---------|-----------|----------------------------------------------
 2497: 1                        CONST   MAXCURSOR,      2;      .Indicates maximum cursor location.
 2498+ 2        N      0002     MAXCURSOR       EQU     2
 2499: 1
 2500: 1                        LOCMEM  STRCACHE,       0FH;    .Used to cache assembled string
 2501+ 2        N      2000     STRCACHE        SET     LOCAL_MEMORY
 2502+ 2        N      200F     LOCAL_MEMORY SET        LOCAL_MEMORY+0FH
 2503+ 2        N      0000     IF      LOCAL_MEMORY>=4000H
 2504+ 2                        $ERROR  ("EXTERNAL MEMORY OVERFLOW")
 2505+ 2                        ENDIF
 2506: 1                        LOCMEM  CURSOR,         1;      .Indicates current cursor location.
 2507+ 2        N      200F     CURSOR  SET     LOCAL_MEMORY
 2508+ 2        N      2010     LOCAL_MEMORY SET        LOCAL_MEMORY+1
 2509+ 2        N      0000     IF      LOCAL_MEMORY>=4000H
 2510+ 2                        $ERROR  ("EXTERNAL MEMORY OVERFLOW")
 2511+ 2                        ENDIF
 2512: 1                        ; --------------------------------------------------------------------
 2513: 1                        ;
 2514: 1                        ; @PROC SESSION_INIT
 2515: 1                        ; @note It is recommended to define a general purpose session initializer
 2516: 1                        ;        to easy access to different session.
 2517: 1                        ;       This procedure should contain the code segment calling TRANSITION
 2518: 1                        ;        procedure, which requires following CALLBACK arguments:
 2519: 1                        ;
 2520: 1                        ;       I X     DPH:DPL INPUT
 2521: 1                        ;       I X     R1:R0   UPDATE
 2522: 1                        ;       I X     R3:R2   DYNAMIC DRAW CALL
 2523: 1                        ;       I X     R5:R4   SESSION INITIALIZER
 2524: 1                        ;       I X     R7:R6   STATIC DRAW CALL
 2525: 1                        ;
 2526: 1                        ;
 2527: 1                        ; --------------------------------------------------------------------
 2528: 1  43D3                  rTITLE_SESSION:
 2529: 1                                ; Clear memory
 2530: 1  43D3  90 20 00                MOV     DPTR,   #2000H
 2531: 1                                LDCDW   R1,R0,  2000H
 2532+ 2  43D6  79 20                   MOV     R1,     #HIGH(2000H)
 2533+ 2  43D8  78 00                   MOV     R0,     #LOW(2000H)
 2534: 1  43DA  75 F0 00                MOV     B,      #0
 2535: 1  43DD  11 2E                   CALL    rMEMSET
 2536: 1                                ; Assign input procedure
 2537: 1  43DF  90 4B 16                MOV     DPTR,   #NULLF
 2538: 1                                ; Assign update procedure
 2539: 1                                LDCDW   R1,R0,  NULLF
 2540+ 2  43E2  79 4B                   MOV     R1,     #HIGH(NULLF)
 2541+ 2  43E4  78 16                   MOV     R0,     #LOW(NULLF)
 2542: 1                                ; Assign draw call procedure
 2543: 1                                LDCDW   R3,R2,  NULLF
 2544+ 2  43E6  7B 4B                   MOV     R3,     #HIGH(NULLF)
 2545+ 2  43E8  7A 16                   MOV     R2,     #LOW(NULLF)
 2546: 1                                ; Assign session initializer
 2547: 1                                LDCDW   R5,R4,  cTITLE_INIT
 2548+ 2  43EA  7D 44                   MOV     R5,     #HIGH(cTITLE_INIT)
 2549+ 2  43EC  7C FB                   MOV     R4,     #LOW(cTITLE_INIT)
 2550: 1                                ; Assign static draw call
 2551: 1                                LDCDW   R7,R6,  cTITLE_STATIC_DRAW
 2552+ 2  43EE  7F 44                   MOV     R7,     #HIGH(cTITLE_STATIC_DRAW)
 2553+ 2  43F0  7E ED                   MOV     R6,     #LOW(cTITLE_STATIC_DRAW)
 2554: 1                                ; Clear if the timer should not be reset.
 2555: 1  43F2  D3                      SETB    C
 2556: 1                                ; Calls the transition function.
 2557: 1                                ; It is recommended to place this line last.
 2558: 1  43F3  12 4B 44                CALL    rTRANSITION
 2559: 1  43F6  22                      RET
 2560: 1                        ; --------------------------------------------------------------------
 2561: 1  43F7                  rMAIN_MENU:
 2562: 1                                ; Assign input procedure
 2563: 1  43F7  90 44 B7                MOV     DPTR,   #cMAIN_INPUT
 2564: 1                                ; Assign update procedure
 2565: 1                                LDCDW   R1,R0,  NULLF
 2566+ 2  43FA  79 4B                   MOV     R1,     #HIGH(NULLF)
 2567+ 2  43FC  78 16                   MOV     R0,     #LOW(NULLF)
 2568: 1                                ; Assign draw call procedure
 2569: 1                                LDCDW   R3,R2,  RMAIN_DRAW
 2570+ 2  43FE  7B 44                   MOV     R3,     #HIGH(RMAIN_DRAW)
 2571+ 2  4400  7A 0F                   MOV     R2,     #LOW(RMAIN_DRAW)
 2572: 1                                ; Assign session initializer
 2573: 1                                LDCDW   R5,R4,  NULLF
 2574+ 2  4402  7D 4B                   MOV     R5,     #HIGH(NULLF)
 2575+ 2  4404  7C 16                   MOV     R4,     #LOW(NULLF)
 2576: 1                                ; Assign static draw call
 2577: 1                                LDCDW   R7,R6,  NULLF
 2578+ 2  4406  7F 4B                   MOV     R7,     #HIGH(NULLF)
 2579+ 2  4408  7E 16                   MOV     R6,     #LOW(NULLF)
 2580: 1                                ; Clear if the timer should not be reset.
 2581: 1  440A  D3                      SETB    C
 2582: 1                                ; Calls the transition function.
 2583: 1                                ; It is recommended to place this line last.
 2584: 1  440B  12 4B 44                CALL    rTRANSITION
 2585: 1  440E  22                      RET
 2586: 1                        ; --------------------------------------------------------------------
 2587: 1                        ; @CALBAK       MAIN_DRAW
 2588: 1                        ; --------------------------------------------------------------------
 2589: 1                        ; Draw callback of MAIN menu session.
 2590: 1  440F                  rMAIN_DRAW:     ; Get back buffer
 2591: 1  440F  51 83                   CALL    RBUFFER_BACK
 2592: 1                                ; Pushes current back buffer element to stack,
 2593: 1                                ;  will be extracted by @R0 which is containing #SP
 2594: 1  4411  C0 E0                   PUSH    ACC
 2595: 1                                ; >>> >>> >>>
 2596: 1                                ; Clears background with black
 2597: 1  4413  74 00                   MOV     A,      #0
 2598: 1  4415  11 73                   CALL    rFILLBUFFER
 2599: 1
 2600: 1                                ; Get cursor from memory
 2601: 1  4417  90 20 0F                MOV     DPTR,   #CURSOR
 2602: 1  441A  E0                      MOVX    A,      @DPTR
 2603: 1
 2604: 1  441B  B4 00 11                CJNE    A,      #0,     MAIN_DRAW_1
 2605: 1  441E  90 44 26                MOV     DPTR,   #MAIN_DRAW_TETRIS
 2606: 1  4421  75 F0 02                MOV     B,      #010B
 2607: 1                        STRING  MAIN_DRAW_TETRIS, 'TETRIS'
 2608+ 2  4424  80 07                   SJMP    ??0021
 2609+ 2  4426  54 45 54 52     MAIN_DRAW_TETRIS:       DB      'TETRIS', 0
       2  442A  49 53 00
 2610+ 2  442D                  ??0021:
 2611: 1  442D  80 2A                   SJMP    MAIN_DRAW_SWDONE
 2612: 1  442F                  MAIN_DRAW_1:
 2613: 1  442F  B4 01 11                CJNE    A,      #1,     MAIN_DRAW_2
 2614: 1  4432  90 44 3A                MOV     DPTR,   #MAIN_DRAW_JIRUNG
 2615: 1  4435  75 F0 05                MOV     B,      #101B
 2616: 1                        STRING  MAIN_DRAW_JIRUNG, 'JIRUNG'
 2617+ 2  4438  80 07                   SJMP    ??0022
 2618+ 2  443A  4A 49 52 55     MAIN_DRAW_JIRUNG:       DB      'JIRUNG', 0
       2  443E  4E 47 00
 2619+ 2  4441                  ??0022:
 2620: 1  4441  80 16                   SJMP    MAIN_DRAW_SWDONE
 2621: 1  4443                  MAIN_DRAW_2:
 2622: 1  4443  B4 02 05                CJNE    A,      #2,     MAIN_DRAW_DEFAULT
 2623: 1  4446  75 F0 01                MOV     B,      #001B
 2624: 1  4449  80 00                   SJMP    MAIN_DRAW_DEFAULT
 2625: 1                        ;MAIN_DRAW_3:
 2626: 1                        ;       CJNE    A,      #3,     MAIN_DRAW_4
 2627: 1                        ;       MOV     B,      #100B
 2628: 1                        ;       ; FILL
 2629: 1                        ;       SJMP    MAIN_DRAW_DEFAULT
 2630: 1                        ;MAIN_DRAW_4:
 2631: 1                        ;       CJNE    A,      #4,     MAIN_DRAW_5
 2632: 1                        ;       MOV     B,      #010B
 2633: 1                        ;       ; FILL
 2634: 1                        ;       SJMP    MAIN_DRAW_DEFAULT
 2635: 1                        ;MAIN_DRAW_5:
 2636: 1                        ;       CJNE    A,      #5,     MAIN_DRAW_DEFAULT
 2637: 1                        ;       MOV     DPTR,   #MAIN_DRAW_RANKING
 2638: 1                        ;       MOV     B,      #011B
 2639: 1                        ;STRING MAIN_DRAW_RANKING, 'RANKING'
 2640: 1                        ;       SJMP    MAIN_DRAW_SWDONE
 2641: 1  444B                  MAIN_DRAW_DEFAULT:
 2642: 1  444B  90 20 00                MOV     DPTR,   #STRCACHE
 2643: 1  444E  C0 F0                   PUSH    B
 2644: 1  4450  F5 F0                   MOV     B,      A
 2645: 1  4452  11 41                   CALL    rDTOA
 2646: 1  4454  90 20 00                MOV     DPTR,   #STRCACHE
 2647: 1  4457  D0 F0                   POP     B
 2648: 1  4459                  MAIN_DRAW_SWDONE:
 2649: 1                                ; Draw string on location
 2650: 1  4459  A8 81                   MOV     R0,     SP
 2651: 1                                MOVP2   @R0
 2652+ 2  445B  86 36                   MOV     GLB_P2CACHE,@R0
 2653+ 2  445D  86 A0                   MOV     P2,     @R0
 2654: 1  445F  79 02                   MOV     R1,     #00000010B
 2655: 1  4461  D2 D5                   SETB    F0
 2656: 1  4463  C0 F0                   PUSH    B
 2657: 1  4465  31 7C                   CALL    rDRAWSTRING
 2658: 1
 2659: 1                                ; Draw boundary box
 2660: 1                                PEAKP2  DPH
 2661+ 2  4467  85 36 83                MOV     DPH,    GLB_P2CACHE
 2662: 1  446A  75 82 00                MOV     DPL,    #0
 2663: 1  446D  D0 F0                   POP     B
 2664: 1  446F  79 20                   MOV     R1,     #32
 2665: 1  4471  7A 10                   MOV     R2,     #16
 2666: 1  4473  C3                      CLR     C
 2667: 1  4474  11 8F                   CALL    rDRAWBOX
 2668: 1
 2669: 1  4476  75 82 21                MOV     DPL,    #00100001B
 2670: 1  4479  75 F0 07                MOV     B,      #111B
 2671: 1  447C  79 1E                   MOV     R1,     #30
 2672: 1  447E  7A 0E                   MOV     R2,     #14
 2673: 1  4480  C3                      CLR     C
 2674: 1  4481  11 8F                   CALL    rDRAWBOX
 2675: 1
 2676: 1                                ; Print the title's highst score
 2677: 1                                ; Get its highst score
 2678: 1  4483  90 20 0F                MOV     DPTR,   #CURSOR
 2679: 1  4486  E0                      MOVX    A,      @DPTR
 2680: 1  4487  23                      RL      A
 2681: 1  4488  23                      RL      A
 2682: 1
 2683: 1                                ; RANKING_HIGHST + CURSOR*4 = Its highst score location.
 2684: 1                                LDCDWP2 R1,     RANKING_HIGHST
 2685+ 2                                MOVP2           #HIGH(RANKING_HIGHST)
 2686+ 3  4489  75 36 12                MOV     GLB_P2CACHE,#HIGH(RANKING_HIGHST)
 2687+ 3  448C  75 A0 12                MOV     P2,     #HIGH(RANKING_HIGHST)
 2688+ 2  448F  79 25                   MOV     R1,     #LOW(RANKING_HIGHST)
 2689: 1  4491  29                      ADD     A,      R1
 2690: 1  4492  24 02                   ADD     A,      #2; Since it's little endian....
 2691: 1  4494  F9                      MOV     R1,     A
 2692: 1
 2693: 1                                ; String to assemble.
 2694: 1  4495  90 20 00                MOV     DPTR,   #STRCACHE
 2695: 1  4498  7A 03                   MOV     R2,     #3
 2696: 1  449A                  MAIN_DRAW_SCORE:
 2697: 1                                ; Change BCD value to string.
 2698: 1  449A  E3                      MOVX    A,      @R1
 2699: 1  449B  F5 F0                   MOV     B,      A
 2700: 1  449D  19                      DEC     R1
 2701: 1  449E  11 41                   CALL    rDTOA
 2702: 1  44A0  DA F8                   DJNZ    R2,     MAIN_DRAW_SCORE
 2703: 1
 2704: 1                                ; print string.
 2705: 1  44A2  90 20 00                MOV     DPTR,   #STRCACHE
 2706: 1  44A5  75 F0 06                MOV     B,      #110B
 2707: 1  44A8  C2 D5                   CLR     F0
 2708: 1  44AA  A8 81                   MOV     R0,     SP
 2709: 1                                MOVP2   @R0
 2710+ 2  44AC  86 36                   MOV     GLB_P2CACHE,@R0
 2711+ 2  44AE  86 A0                   MOV     P2,     @R0
 2712: 1  44B0  79 42                   MOV     R1,     #01000010B
 2713: 1  44B2  31 7C                   CALL    rDRAWSTRING
 2714: 1
 2715: 1                        ;STRING MAIN_DRAW_STR_SELECT, 'SELECT'
 2716: 1                        ;       MOV     DPTR,   #MAIN_DRAW_STR_SELECT
 2717: 1                        ;       MOV     B,      #111B
 2718: 1                        ;       CLR     F0
 2719: 1                        ;       MOV     R0,     SP
 2720: 1                        ;       MOVP2   @R0
 2721: 1                        ;       MOV     R1,     #01000010B
 2722: 1                        ;       CALL    rDRAWSTRING
 2723: 1
 2724: 1                                ; <<< <<< <<<
 2725: 1  44B4  D0 E0                   POP     ACC
 2726: 1  44B6  22                      RET
 2727: 1
 2728: 1                        ; --------------------------------------------------------------------
 2729: 1                        ; @CALBAK       INPUTCALLBACK
 2730: 1                        ; @NOTE         BUTTON.6        L
 2731: 1                        ;       BUTTON.5        D
 2732: 1                        ;       BUTTON.4        U
 2733: 1                        ;       BUTTON.3        R
 2734: 1                        ;       BUTTON.2        ACTA
 2735: 1                        ;       BUTTON.1        ACTB
 2736: 1                        ;       BUTTON.0        HOME
 2737: 1                        ;
 2738: 1                        ; I     R0      KEYDOWN
 2739: 1                        ; I     R1      KEYUP
 2740: 1                        ; I     R2      KEYHOLD
 2741: 1                        ; --------------------------------------------------------------------
 2742: 1                        ; @CALBAK       MAIN_INPUT
 2743: 1                        ; --------------------------------------------------------------------
 2744: 1  44B7                  cMAIN_INPUT:
 2745: 1        N      0000     BIT_U   SET     0
 2746: 1        N      0001     BIT_D   SET     1
 2747: 1        N      0002     BIT_R   SET     2
 2748: 1        N      0003     BIT_L   SET     3
 2749: 1        N      0004     BIT_A   SET     4
 2750: 1        N      0005     BIT_B   SET     5
 2751: 1        N      0006     BIT_    SET     6
 2752: 1        N      0007     BIT_HOME        SET     7
 2753: 1        N        02             USING   GAMEBANK/8
 2754: 1                                ; If button 0 pressed...
 2755: 1  44B7  E8                      MOV     A,      R0 ; KEY DOWN
 2756: 1  44B8  20 E5 1A                JB      ACC.5,  MAIN_INPUT_NEXT
 2757: 1  44BB  20 E4 23                JB      ACC.4,  MAIN_INPUT_PREV
 2758: 1  44BE  20 E2 01                JB      ACC.2,  MAIN_INPUT_SELECT
 2759: 1  44C1  22                      RET
 2760: 1
 2761: 1                                ; Cursor location will be ranking, game info.
 2762: 1                                ;MOV    DPTR,   #CURSOR
 2763: 1                                ;MOVX   A,      @DPTR
 2764: 1                                ;MOV    DPTR,   #RANKING_GAMEINFO
 2765: 1                                ;MOVX   @DPTR,  A
 2766: 1
 2767: 1  44C2                  MAIN_INPUT_SELECT:
 2768: 1                                ; Initiates selected session
 2769: 1  44C2  90 20 0F                MOV     DPTR,   #CURSOR
 2770: 1  44C5  E0                      MOVX    A,      @DPTR
 2771: 1
 2772: 1  44C6  B4 00 04                CJNE    A,      #0,     MAIN_INPUT_S1
 2773: 1  44C9  12 45 17                CALL    rSESSION_TETRIS
 2774: 1  44CC  22                      RET
 2775: 1  44CD                  MAIN_INPUT_S1:
 2776: 1  44CD  B4 01 04                CJNE    A,      #1,     MAIN_INPUT_S2
 2777: 1  44D0  12 49 B1                CALL    rSESSION_JIRUNG
 2778: 1  44D3  22                      RET
 2779: 1  44D4                  MAIN_INPUT_S2:
 2780: 1  44D4  22                      RET
 2781: 1  44D5                  MAIN_INPUT_NEXT:
 2782: 1                                ; Rotate cursor
 2783: 1  44D5  90 20 0F                MOV     DPTR,   #CURSOR
 2784: 1  44D8  E0                      MOVX    A,      @DPTR
 2785: 1                                ; NEXT = CURSOR + 1
 2786: 1  44D9  04                      INC     A
 2787: 1                                ; NEXT = NEXT == MAX ? 0 : NEXT
 2788: 1  44DA  B4 02 02                CJNE    A,      #MAXCURSOR, MAIN_INPUT_STORE
 2789: 1  44DD  74 00                   MOV     A,      #0
 2790: 1  44DF                  MAIN_INPUT_STORE:
 2791: 1  44DF  F0                      MOVX    @DPTR,  A
 2792: 1  44E0  22                      RET
 2793: 1  44E1                  MAIN_INPUT_PREV:
 2794: 1                                ; Rotate cursor
 2795: 1  44E1  90 20 0F                MOV     DPTR,   #CURSOR
 2796: 1  44E4  E0                      MOVX    A,      @DPTR
 2797: 1                                ; NEXT = CURSOR + 1
 2798: 1  44E5  14                      DEC     A
 2799: 1                                ; NEXT = NEXT == MAX ? 0 : NEXT
 2800: 1  44E6  B4 FF F6                CJNE    A,      #0FFH,  MAIN_INPUT_STORE
 2801: 1  44E9  74 01                   MOV     A,      #MAXCURSOR - 1
 2802: 1  44EB  80 F2                   SJMP    MAIN_INPUT_STORE
 2803: 1                        ; --------------------------------------------------------------------
 2804: 1                        ; @CALBAK       UPDATECALLBACK(VOID)
 2805: 1                        ; --------------------------------------------------------------------
 2806: 1                        ; @CALBAK       DYNAMICDRAWCALLBACK
 2807: 1                        ; --------------------------------------------------------------------
 2808: 1  44ED                  cTITLE_STATIC_DRAW:
 2809: 1                        ; Draw title image.
 2810: 1  44ED  51 83                   CALL    RBUFFER_BACK
 2811: 1  44EF  F5 A0                   MOV     P2,     A
 2812: 1  44F1  79 00                   MOV     R1,     #0
 2813: 1  44F3  90 4C D6                MOV     DPTR,   #IMG_TITLE
 2814: 1  44F6  C2 D7                   CLR     CY
 2815: 1  44F8  31 20                   CALL    RDRAWIMAGE
 2816: 1  44FA  22                      RET
 2817: 1                        ; --------------------------------------------------------------------
 2818: 1                        ; @CALBAK       INITIALIZERCALLBACK(VOID)
 2819: 1                        ; --------------------------------------------------------------------
 2820: 1  44FB                  cTITLE_INIT:
 2821: 1                                LDCDW   BR1,    BR0,    45
 2822+ 2  44FB  75 21 00                MOV     BR1,    #HIGH(45)
 2823+ 2  44FE  75 20 2D                MOV     BR0,    #LOW(45)
 2824: 1                                LDCDW   R1,     R0,     rMAIN_MENU
 2825+ 2  4501  79 43                   MOV     R1,     #HIGH(rMAIN_MENU)
 2826+ 2  4503  78 F7                   MOV     R0,     #LOW(rMAIN_MENU)
 2827: 1  4505  12 4B 17                CALL    rSET_TIMER
 2828: 1  4508  22                      RET
 2829: 1                        ; --------------------------------------------------------------------
 2830: 1                        ; @CALBAK       STATICDRAWCALLBAK
 2831: 1                        ; --------------------------------------------------------------------
 2832: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2833:                          $INCLUDE        (SSN_TETRIS.INC)
 2834: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2835: 1                        ; DEFINE_MODULE SSN_TMPLT??? ; This isn't required on session definition
 2836: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2837: 1                        LOCMEM_PVT
 2838+ 2        N      2000     LOCAL_MEMORY SET        2000H
 2839: 1                        LBIT_PVT
 2840+ 2  4509                  ??0023:
 2841+ 2        N      0000     IF      ??0023 < 4000H
 2842+ 2                        $ERROR  ("LBIT should be placed after code segment.")
 2843+ 2                        ENDIF
 2844+ 2        N      007B     __LB_PIVOT      SET     __INTB_OFST
 2845: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2846: 1                        ;
 2847: 1                        ;       SSN_TETRIS
 2848: 1                        ;
 2849: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2850: 1                        ;       DESCRIPTION
 2851: 1                        ; This is a session which defines the game 'TETRIS'.
 2852: 1                        ; The left side of the screen will show gameplay screen, and the right
 2853: 1                        ;side of the screen will show current score.
 2854: 1                        ;
 2855: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 2856: 1                        ; ######### SUBROUTINES & MACROS #####################################
 2857: 1                        ; --------------------------------------------------------------------
 2858: 1                        ; @NOTE LOADCDW HI, LO, CONST
 2859: 1                        ; @NOTE MOVP2   VAL
 2860: 1                        ; --------------------------------------------------------------------
 2861: 1                        ;
 2862: 1                        ;       LOCAL MEMORY ALLOCATIONS
 2863: 1                        ;
 2864: 1                        ; TYPE     |IDENTIFIER |SIZE/DESCRIPTION
 2865: 1                        ; ---------|-----------|----------------------------------------------
 2866: 1                        MEMALIGN        LOCAL_MEMORY, 100H
 2867+ 2        N      2000     LOCAL_MEMORY    SET     ((LOCAL_MEMORY+(100H-1))/100H)*100H
 2868: 1                        LOCMEM  TT_BOARD,       100H; .Board data buffer. To allow fast accessing
 2869+ 2        N      2000     TT_BOARD        SET     LOCAL_MEMORY
 2870+ 2        N      2100     LOCAL_MEMORY SET        LOCAL_MEMORY+100H
 2871+ 2        N      0000     IF      LOCAL_MEMORY>=4000H
 2872+ 2                        $ERROR  ("EXTERNAL MEMORY OVERFLOW")
 2873+ 2                        ENDIF
 2874: 1                                        ; and processing, a single block cell occupies
 2875: 1                                        ; 1 byte memory space.
 2876: 1
 2877: 1                        LOCMEM  TT_LEVEL,       1
 2878+ 2        N      2100     TT_LEVEL        SET     LOCAL_MEMORY
 2879+ 2        N      2101     LOCAL_MEMORY SET        LOCAL_MEMORY+1
 2880+ 2        N      0000     IF      LOCAL_MEMORY>=4000H
 2881+ 2                        $ERROR  ("EXTERNAL MEMORY OVERFLOW")
 2882+ 2                        ENDIF
 2883: 1                        LOCMEM  TT_TONEXTLV, 1; .Block destroy count left to next level.
 2884+ 2        N      2101     TT_TONEXTLV     SET     LOCAL_MEMORY
 2885+ 2        N      2102     LOCAL_MEMORY SET        LOCAL_MEMORY+1
 2886+ 2        N      0000     IF      LOCAL_MEMORY>=4000H
 2887+ 2                        $ERROR  ("EXTERNAL MEMORY OVERFLOW")
 2888+ 2                        ENDIF
 2889: 1                        LOCMEM  TT_DELAY,       1; .This is the frame length which indicates
 2890+ 2        N      2102     TT_DELAY        SET     LOCAL_MEMORY
 2891+ 2        N      2103     LOCAL_MEMORY SET        LOCAL_MEMORY+1
 2892+ 2        N      0000     IF      LOCAL_MEMORY>=4000H
 2893+ 2                        $ERROR  ("EXTERNAL MEMORY OVERFLOW")
 2894+ 2                        ENDIF
 2895: 1                                        ; the period of dropping block. it begins with
 2896: 1                                        ; 30frame, and it decreases per level.
 2897: 1                                        ; NO_USE, THE DELAY SHOULD BE 30 - LEVEL * 2
 2898: 1                        LOCMEM  TT_CNTLEFT,     1; .Frame counts that are left until the block shifts down.
 2899+ 2        N      2103     TT_CNTLEFT      SET     LOCAL_MEMORY
 2900+ 2        N      2104     LOCAL_MEMORY SET        LOCAL_MEMORY+1
 2901+ 2        N      0000     IF      LOCAL_MEMORY>=4000H
 2902+ 2                        $ERROR  ("EXTERNAL MEMORY OVERFLOW")
 2903+ 2                        ENDIF
 2904: 1                        LOCMEM  TT_DELLEFT,     1; .Delay time left, will be reset on block movement
 2905+ 2        N      2104     TT_DELLEFT      SET     LOCAL_MEMORY
 2906+ 2        N      2105     LOCAL_MEMORY SET        LOCAL_MEMORY+1
 2907+ 2        N      0000     IF      LOCAL_MEMORY>=4000H
 2908+ 2                        $ERROR  ("EXTERNAL MEMORY OVERFLOW")
 2909+ 2                        ENDIF
 2910: 1                        LOCMEM  TT_CB_TYPE, 1; .Current block type.
 2911+ 2        N      2105     TT_CB_TYPE      SET     LOCAL_MEMORY
 2912+ 2        N      2106     LOCAL_MEMORY SET        LOCAL_MEMORY+1
 2913+ 2        N      0000     IF      LOCAL_MEMORY>=4000H
 2914+ 2                        $ERROR  ("EXTERNAL MEMORY OVERFLOW")
 2915+ 2                        ENDIF
 2916: 1                        LOCMEM  TT_NB_TYPE,     1; .Next block type.
 2917+ 2        N      2106     TT_NB_TYPE      SET     LOCAL_MEMORY
 2918+ 2        N      2107     LOCAL_MEMORY SET        LOCAL_MEMORY+1
 2919+ 2        N      0000     IF      LOCAL_MEMORY>=4000H
 2920+ 2                        $ERROR  ("EXTERNAL MEMORY OVERFLOW")
 2921+ 2                        ENDIF
 2922: 1
 2923: 1                        MEMALIGN        LOCAL_MEMORY, 4
 2924+ 2        N      2108     LOCAL_MEMORY    SET     ((LOCAL_MEMORY+(4-1))/4)*4
 2925: 1                        LOCMEM  TT_CB_PVT,  4; .Location of four current active block cells.
 2926+ 2        N      2108     TT_CB_PVT       SET     LOCAL_MEMORY
 2927+ 2        N      210C     LOCAL_MEMORY SET        LOCAL_MEMORY+4
 2928+ 2        N      0000     IF      LOCAL_MEMORY>=4000H
 2929+ 2                        $ERROR  ("EXTERNAL MEMORY OVERFLOW")
 2930+ 2                        ENDIF
 2931: 1                                        ; The first byte of PVT data indicates the absolute
 2932: 1                                        ;location of block pivot, and the rest of three
 2933: 1                                        ;bytes indicate relative locations for each cells,
 2934: 1                                        ;and those are represented as signed value.
 2935: 1                                        ; On rotation, the pivot cell never be changed,
 2936: 1                                        ;but the rest of three locations will be changed
 2937: 1                                        ;to apply rotation.
 2938: 1                        LOCMEM  STRCACHE,       8; .STRING CACHE
 2939+ 2        N      210C     STRCACHE        SET     LOCAL_MEMORY
 2940+ 2        N      2114     LOCAL_MEMORY SET        LOCAL_MEMORY+8
 2941+ 2        N      0000     IF      LOCAL_MEMORY>=4000H
 2942+ 2                        $ERROR  ("EXTERNAL MEMORY OVERFLOW")
 2943+ 2                        ENDIF
 2944: 1                        MEMALIGN        LOCAL_MEMORY, 20H
 2945+ 2        N      2120     LOCAL_MEMORY    SET     ((LOCAL_MEMORY+(20H-1))/20H)*20H
 2946: 1                        LOCMEM  TT_TMP, 20H; Temporary memory for various usage.
 2947+ 2        N      2120     TT_TMP  SET     LOCAL_MEMORY
 2948+ 2        N      2140     LOCAL_MEMORY SET        LOCAL_MEMORY+20H
 2949+ 2        N      0000     IF      LOCAL_MEMORY>=4000H
 2950+ 2                        $ERROR  ("EXTERNAL MEMORY OVERFLOW")
 2951+ 2                        ENDIF
 2952: 1
 2953: 1                        ; LOCATION INFO WILL BE ALIGNED AS  [YYYY XXXX], XXXX <= 1010
 2954: 1                        CONST   TT_WIDTH,       10
 2955+ 2        N      000A     TT_WIDTH        EQU     10
 2956: 1                        CONST   TT_HEIGHT,      16
 2957+ 2        N      0010     TT_HEIGHT       EQU     16
 2958: 1
 2959: 1                        CONST   TT_PV_BOARD, 00000110B
 2960+ 2        N      0006     TT_PV_BOARD     EQU     00000110B
 2961: 1                        CONST   TT_PV_NEXT,  00100001B
 2962+ 2        N      0021     TT_PV_NEXT      EQU     00100001B
 2963: 1                        CONST   TT_PV_LVL,       11100001B
 2964+ 2        N      00E1     TT_PV_LVL       EQU     11100001B
 2965: 1                        CONST   TT_PV_SCORE, 01110000B
 2966+ 2        N      0070     TT_PV_SCORE     EQU     01110000B
 2967: 1
 2968: 1                        LBIT    TT_SCOREDIRTY; .Score dirty flag for dynamic draw callback
 2969+ 2        N      007B     TT_SCOREDIRTY   SET     __LB_PIVOT
 2970+ 2        N      007A     __LB_PIVOT      SET     __LB_PIVOT -1
 2971: 1                        LBIT    TT_NEXTDIRTY;  .Next block screen dirty flag
 2972+ 2        N      007A     TT_NEXTDIRTY    SET     __LB_PIVOT
 2973+ 2        N      0079     __LB_PIVOT      SET     __LB_PIVOT -1
 2974: 1                        LBIT    TT_BOARDDIRTY; .Board dirty flag
 2975+ 2        N      0079     TT_BOARDDIRTY   SET     __LB_PIVOT
 2976+ 2        N      0078     __LB_PIVOT      SET     __LB_PIVOT -1
 2977: 1                        LBIT    TT_LVLDIRTY;   .Level dirty flag
 2978+ 2        N      0078     TT_LVLDIRTY     SET     __LB_PIVOT
 2979+ 2        N      0077     __LB_PIVOT      SET     __LB_PIVOT -1
 2980: 1
 2981: 1                        LBIT    TT_FLGCLR;     .Flag clear signal flag. Should be reset on
 2982+ 2        N      0077     TT_FLGCLR       SET     __LB_PIVOT
 2983+ 2        N      0076     __LB_PIVOT      SET     __LB_PIVOT -1
 2984: 1                                        ;any dirty flag activation.
 2985: 1                        LBIT    TT_DROPBLOCK;  .Used to drop block immediately.
 2986+ 2        N      0076     TT_DROPBLOCK    SET     __LB_PIVOT
 2987+ 2        N      0075     __LB_PIVOT      SET     __LB_PIVOT -1
 2988: 1
 2989: 1                        ; --------------------------------------------------------------------
 2990: 1                        ; To depict a tetris block shape, a byte of data will be used.
 2991: 1                        ; Upper 4bit will show upper line, Lower 4bit will show lower line.
 2992: 1                        ; For example, the T block will be stored by this way.
 2993: 1                        ;       CONST TT_BLOCKSHAPE_T  00100111
 2994: 1                        ;       >>   * * ‚ñ† *
 2995: 1                        ;       >>   * ‚ñ† ‚óÜ ‚ñ†  ‚óÜ - Pivot location
 2996: 1                        ; This data will be instanciated on block spawn, 1 will be set as
 2997: 1                        ;filled block shape, 0 will indicate empty space.
 2998: 1                        CONST   TT_BL_T,        00100111B
 2999+ 2        N      0027     TT_BL_T EQU     00100111B
 3000: 1                        CONST   TT_BL_I,        00001111B
 3001+ 2        N      000F     TT_BL_I EQU     00001111B
 3002: 1                        CONST   TT_BL_LL,       00010111B
 3003+ 2        N      0017     TT_BL_LL        EQU     00010111B
 3004: 1                        CONST   TT_BL_RL,       01000111B
 3005+ 2        N      0047     TT_BL_RL        EQU     01000111B
 3006: 1                        CONST   TT_BL_Z,        01100011B
 3007+ 2        N      0063     TT_BL_Z EQU     01100011B
 3008: 1                        CONST   TT_BL_S,        00110110B
 3009+ 2        N      0036     TT_BL_S EQU     00110110B
 3010: 1                        CONST   TT_BL_SQ,       01100110B
 3011+ 2        N      0066     TT_BL_SQ        EQU     01100110B
 3012: 1
 3013: 1  4509  27 0F 17 47     TT_BLOCKSHAPE:DB        TT_BL_T, TT_BL_I, TT_BL_LL, TT_BL_RL, TT_BL_Z, TT_BL_S, TT_BL_SQ
       1  450D  63 36 66
 3014: 1  4510  05 01 03 04     TT_BLOCK_COLOR:DB       101B, 001B, 011B, 100B, 010B, 101B, 110B
       1  4514  02 05 06
 3015: 1                        ; --------------------------------------------------------------------
 3016: 1                        ; #MACRO        BLKTODISP
 3017: 1                        ; --------------------------------------------------------------------
 3018: 1                        ; Transform 16 by 16 location to (F0)1 + 3 by 8 location
 3019: 1                        BLKTODISP       MACRO   _A
 3020: 1                                PUSH    ACC
 3021: 1                                ; Upper 4bit to F0 + 3bit ofst
 3022: 1                                ANL     A,      #0F0H
 3023: 1                                RLC     _A
 3024: 1                                MOV     F0,     C
 3025: 1                                ; Lower 4bit and add 7 to shift right.
 3026: 1                                ANL     A,      #11100000B
 3027: 1                                POP     B
 3028: 1                                ; Masks B, its lower value.
 3029: 1                                ANL     B,      #0FH
 3030: 1                                ADD     A,      B
 3031: 1                                ADD     A,      #6
 3032: 1                                ; now result in A
 3033: 1                        ENDM
 3034: 1                        ; Adds lower 4bit and higher 4bit separately.
 3035: 1                        ; Invalidates B
 3036: 1                        ADDBLKRELC      MACRO   _A,     OP
 3037: 1                                PUSH    ACC
 3038: 1                                ; Adds upper 4bit first.
 3039: 1                                ANL     A,      #0F0H
 3040: 1                                ADD     _A,     OP
 3041: 1                                ANL     A,      #0F0H
 3042: 1                                ; Adds lower 4bit
 3043: 1                                MOV     B,      A
 3044: 1                                POP     ACC
 3045: 1                                ADD     A,      OP
 3046: 1                                ANL     A,      #00FH
 3047: 1                                ; Adds each value other.
 3048: 1                                ADD     A,      B
 3049: 1                        ENDM
 3050: 1                        ; --------------------------------------------------------------------
 3051: 1                        ;
 3052: 1                        ; @PROC SESSION_INIT
 3053: 1                        ; @note  It is recommended to define a general purpose session initializer
 3054: 1                        ;       to easy access to different session.
 3055: 1                        ;        This procedure should contain the code segment calling TRANSITION
 3056: 1                        ;       procedure, which requires following CALLBACK arguments:
 3057: 1                        ;
 3058: 1                        ;       I X     DPH:DPL INPUT
 3059: 1                        ;       I X     R1:R0   UPDATE
 3060: 1                        ;       I X     R3:R2   DYNAMIC DRAW CALL
 3061: 1                        ;       I X     R5:R4   SESSION INITIALIZER
 3062: 1                        ;       I X     R7:R6   STATIC DRAW CALL
 3063: 1                        ;
 3064: 1                        ; --------------------------------------------------------------------
 3065: 1  4517                  rSESSION_TETRIS:
 3066: 1                                ; Clears memory
 3067: 1  4517  90 20 00                MOV     DPTR,   #2000H
 3068: 1                                LDCDW   R1,R0,  2000H
 3069+ 2  451A  79 20                   MOV     R1,     #HIGH(2000H)
 3070+ 2  451C  78 00                   MOV     R0,     #LOW(2000H)
 3071: 1  451E  75 F0 00                MOV     B,      #0
 3072: 1  4521  11 2E                   CALL    rMEMSET
 3073: 1                                ; Assign input procedure
 3074: 1  4523  90 48 E5                MOV     DPTR,   #cTETINPUT
 3075: 1                                ; Assign update procedure
 3076: 1                                LDCDW   R1,R0,  cTETUPDATE
 3077+ 2  4526  79 45                   MOV     R1,     #HIGH(cTETUPDATE)
 3078+ 2  4528  78 D7                   MOV     R0,     #LOW(cTETUPDATE)
 3079: 1                                ; Assign draw call procedure
 3080: 1                                LDCDW   R3,R2,  cTETDNDRAW
 3081+ 2  452A  7B 47                   MOV     R3,     #HIGH(cTETDNDRAW)
 3082+ 2  452C  7A 46                   MOV     R2,     #LOW(cTETDNDRAW)
 3083: 1                                ; Assign session initializer
 3084: 1                                LDCDW   R5,R4,  cTETINIT
 3085+ 2  452E  7D 47                   MOV     R5,     #HIGH(cTETINIT)
 3086+ 2  4530  7C 09                   MOV     R4,     #LOW(cTETINIT)
 3087: 1                                ; Assign static draw call
 3088: 1                                LDCDW   R7,R6,  cTETSTDRAW
 3089+ 2  4532  7F 48                   MOV     R7,     #HIGH(cTETSTDRAW)
 3090+ 2  4534  7E A1                   MOV     R6,     #LOW(cTETSTDRAW)
 3091: 1                                ; Clear if the timer should not be reset.
 3092: 1                                ; Reset timer for tetris.
 3093: 1  4536  D3                      SETB    C
 3094: 1                                ; Calls the transition function.
 3095: 1                                ; It is recommended to place this line last.
 3096: 1  4537  12 4B 44                CALL    rTRANSITION
 3097: 1
 3098: 1  453A  22                      RET
 3099: 1                        ; --------------------------------------------------------------------
 3100: 1                        ;
 3101: 1                        ; @SPECT        CHECKBOUND
 3102: 1                        ;
 3103: 1                        ; I     R2      NEXT PIVOT, y x align
 3104: 1                        ; I     R3      CURRENT PIVOT
 3105: 1                        ; IX[3] DPTR    NEXT PIVOT LINKINGS
 3106: 1                        ; OUT   F0      VALID
 3107: 1                        ;
 3108: 1                        ; X     ACC
 3109: 1                        ;
 3110: 1                        ; --------------------------------------------------------------------
 3111: 1                        ; Check if given next block is valid
 3112: 1  453B                  sCHECKBOUND:
 3113: 1        N        02             USING   GAMEBANK/8
 3114: 1        B      00D5     VALID   SET     F0
 3115: 1        R        R2     PVNXT   SET     R2
 3116: 1  453B  C0 14                   PUSH    AR4
 3117: 1  453D  C0 F0                   PUSH    B
 3118: 1                                ; >>>>>
 3119: 1
 3120: 1                                ; init
 3121: 1  453F  D2 D5                   SETB    VALID
 3122: 1                                LDCDWP2 R1,     TT_BOARD
 3123+ 2                                MOVP2           #HIGH(TT_BOARD)
 3124+ 3  4541  75 36 20                MOV     GLB_P2CACHE,#HIGH(TT_BOARD)
 3125+ 3  4544  75 A0 20                MOV     P2,     #HIGH(TT_BOARD)
 3126+ 2  4547  79 00                   MOV     R1,     #LOW(TT_BOARD)
 3127: 1
 3128: 1                                ;SJMP   CHECKBOUND_LINKS
 3129: 1
 3130: 1                                ; Y Axis distance between current and next should be less than 4.
 3131: 1  4549  EB                      MOV     A,      R3
 3132: 1  454A  8A F0                   MOV     B,      R2
 3133: 1  454C  12 45 7A                CALL    CHECKBOUND_YVALID
 3134: 1
 3135: 1                                ; pivot validation
 3136: 1  454F  A9 12                   MOV     R1,     AR2
 3137: 1  4551  12 45 95                CALL    ssCHECKDOT
 3138: 1
 3139: 1  4554                  CHECKBOUND_LINKS:
 3140: 1
 3141: 1  4554  7C 03                   MOV     R4,     #3
 3142: 1  4556                  CHECKBOUND_FOREACH:
 3143: 1                        ; check block validation for each block linkings.
 3144: 1                        ; Apply absolute location to pivot
 3145: 1                                ; load value from ptr
 3146: 1  4556  E0                      MOVX    A,      @DPTR
 3147: 1  4557  C4                      SWAP    A
 3148: 1                                ADDBLKRELC      A,      PVNXT
 3149+ 2  4558  C0 E0                   PUSH    ACC
 3150+ 2                                ; Adds upper 4bit first.
 3151+ 2  455A  54 F0                   ANL     A,      #0F0H
 3152+ 2  455C  2A                      ADD     A,      PVNXT
 3153+ 2  455D  54 F0                   ANL     A,      #0F0H
 3154+ 2                                ; Adds lower 4bit
 3155+ 2  455F  F5 F0                   MOV     B,      A
 3156+ 2  4561  D0 E0                   POP     ACC
 3157+ 2  4563  2A                      ADD     A,      PVNXT
 3158+ 2  4564  54 0F                   ANL     A,      #00FH
 3159+ 2                                ; Adds each value other.
 3160+ 2  4566  25 F0                   ADD     A,      B
 3161: 1  4568  F9                      MOV     R1,     A
 3162: 1
 3163: 1                                ; Y Axis validation check
 3164: 1  4569  F5 F0                   MOV     B,      A
 3165: 1  456B  EB                      MOV     A,      R3
 3166: 1  456C  12 45 7A                CALL    CHECKBOUND_YVALID
 3167: 1
 3168: 1                                ; Call for checkdot function.
 3169: 1  456F  12 45 95                CALL    ssCHECKDOT
 3170: 1  4572  A3                      INC     DPTR
 3171: 1  4573  DC E1                   DJNZ    R4,     CHECKBOUND_FOREACH
 3172: 1
 3173: 1  4575                  CHECKBOUND_EXT:
 3174: 1                                ; <<<<<
 3175: 1  4575  D0 F0                   POP     B
 3176: 1  4577  D0 14                   POP     AR4
 3177: 1  4579  22                      RET
 3178: 1
 3179: 1  457A                  CHECKBOUND_YVALID:
 3180: 1  457A  C4                      SWAP    A
 3181: 1  457B  54 0F                   ANL     A,      #00FH
 3182: 1  457D  C5 F0                   XCH     A,      B
 3183: 1  457F  C4                      SWAP    A
 3184: 1  4580  54 0F                   ANL     A,      #00FH
 3185: 1  4582  C3                      CLR     C
 3186: 1  4583  95 F0                   SUBB    A,      B; NEXT - CURRENT
 3187: 1
 3188: 1                                ; Check if (next - current) + 4 is positive and less than 8.
 3189: 1  4585  24 04                   ADD     A,      #4
 3190: 1  4587  30 E7 03                JNB     ACC.7,  CHECKBOUND_YVALID1; Check if negative.
 3191: 1  458A  C2 D5                   CLR     VALID
 3192: 1  458C  22                      RET
 3193: 1  458D                  CHECKBOUND_YVALID1:
 3194: 1  458D  C3                      CLR     C
 3195: 1  458E  94 08                   SUBB    A,      #8
 3196: 1  4590  40 02                   JC      CHECKBOUND_YVALID2; If the result is larger than 8...
 3197: 1  4592  C2 D5                   CLR     VALID
 3198: 1  4594                  CHECKBOUND_YVALID2:
 3199: 1  4594  22                      RET
 3200: 1
 3201: 1                        ; --------------------------------------------------------------------
 3202: 1                        ;
 3203: 1                        ; @SPECTT       CHECKDOT
 3204: 1                        ; I     P2:R1   BOARD PIVOT, R1: LOCATION
 3205: 1                        ; I     F0      VALID_PREV
 3206: 1                        ; OUT   F0      VALID
 3207: 1                        ;
 3208: 1                        ; --------------------------------------------------------------------
 3209: 1  4595                  ssCHECKDOT:
 3210: 1        N        02             USING   GAMEBANK/8
 3211: 1        R        R1     LOCATION        SET     R1
 3212: 1                                ; Boundary check, x < 10
 3213: 1  4595  E9                      MOV     A,      R1
 3214: 1                                ; Masks lower 4bits to compare only lower 4bits
 3215: 1  4596  54 0F                   ANL     A,      #0FH
 3216: 1  4598  C3                      CLR     C
 3217: 1  4599  94 0A                   SUBB    A,      #10; Now A should be less than 10.
 3218: 1  459B  50 05                   JNC     CHECKDOT_FAIL
 3219: 1
 3220: 1                                ; Data check
 3221: 1  459D  E3                      MOVX    A,      @LOCATION
 3222: 1  459E  70 02                   JNZ     CHECKDOT_FAIL
 3223: 1  45A0  80 02                   SJMP    CHECKDOT_END
 3224: 1  45A2                  CHECKDOT_FAIL:
 3225: 1  45A2  C2 D5                   CLR     F0
 3226: 1  45A4                  CHECKDOT_END:
 3227: 1  45A4  22                      RET
 3228: 1                        ; --------------------------------------------------------------------
 3229: 1                        ;
 3230: 1                        ; @SPECT        GENBLOCK
 3231: 1                        ;
 3232: 1                        ; X     R7, R6, R5, R3, P2, R1
 3233: 1                        ;
 3234: 1                        ; --------------------------------------------------------------------
 3235: 1                        ; Generates current block link information, for pvt +1, 2, 3.
 3236: 1  45A5                  sGENBLOCK:
 3237: 1        N        02             USING   GAMEBANK/8
 3238: 1                                ; [-2-1] [-1-1] [ 0-1] [ 1-1]
 3239: 1                                ; [-2 0] [-1 0] [ PVT] [ 1 0]
 3240: 1
 3241: 1                                ; LOAD BLOCK SHAPE INFO
 3242: 1  45A5  90 21 05                MOV     DPTR,   #TT_CB_TYPE
 3243: 1  45A8  E0                      MOVX    A,      @DPTR
 3244: 1  45A9  90 45 09                MOV     DPTR,   #TT_BLOCKSHAPE
 3245: 1  45AC  93                      MOVC    A,      @A+DPTR
 3246: 1
 3247: 1        R        R7     BLSHAPE SET     R7
 3248: 1        R        R6     CURIDX  SET     R6
 3249: 1        R        R5     LEFT    SET     R5
 3250: 1
 3251: 1                                ; Caches it
 3252: 1  45AD  FF                      MOV     BLSHAPE,        A
 3253: 1  45AE  7E 00                   MOV     CURIDX, #0
 3254: 1  45B0  7D 08                   MOV     LEFT,   #8
 3255: 1
 3256: 1                                ; Get pivot link address
 3257: 1                                LDCDWP2 R1,     TT_CB_PVT+1
 3258+ 2                                MOVP2           #HIGH(TT_CB_PVT+1)
 3259+ 3  45B2  75 36 21                MOV     GLB_P2CACHE,#HIGH(TT_CB_PVT+1)
 3260+ 3  45B5  75 A0 21                MOV     P2,     #HIGH(TT_CB_PVT+1)
 3261+ 2  45B8  79 09                   MOV     R1,     #LOW(TT_CB_PVT+1)
 3262: 1  45BA  90 45 CF                MOV     DPTR,   #GENBLOCK_TABLE
 3263: 1
 3264: 1  45BD                  GENBLOCK_LP:
 3265: 1                        ; visits each bits of block shape info, without in case of pivot location(6th)
 3266: 1                                ; if curidx == 6, skip all
 3267: 1  45BD  BE 06 02                CJNE    CURIDX, #6,     GENBLOCK_VALID
 3268: 1  45C0  80 09                   SJMP    GENBLOCK_ESC
 3269: 1
 3270: 1  45C2                  GENBLOCK_VALID:
 3271: 1                                ; Extract leftmost bit of blshape
 3272: 1  45C2  EF                      MOV     A,      BLSHAPE
 3273: 1  45C3  33                      RLC     A
 3274: 1  45C4  FF                      MOV     BLSHAPE,        A
 3275: 1                                ; if CY is active, it means it's pivot is valid
 3276: 1  45C5  50 04                   JNC     GENBLOCK_ESC
 3277: 1                                ; Load pivot information from table
 3278: 1  45C7  EE                      MOV     A,      CURIDX
 3279: 1  45C8  93                      MOVC    A,      @A+DPTR
 3280: 1  45C9  F3                      MOVX    @R1,    A
 3281: 1                                ; mov head to next pivot
 3282: 1  45CA  09                      INC     R1
 3283: 1
 3284: 1  45CB                  GENBLOCK_ESC:
 3285: 1  45CB  0E                      INC     CURIDX
 3286: 1  45CC  DD EF                   DJNZ    LEFT,   GENBLOCK_LP
 3287: 1
 3288: 1  45CE  22                      RET
 3289: 1  45CF                  GENBLOCK_TABLE:
 3290: 1  45CF  EF FF 0F 1F     DB      11101111B,      11111111B,      00001111B,      00011111B
 3291: 1  45D3  E0 F0 00 10     DB      11100000B,      11110000B,      00000000B,      00010000B
 3292: 1                        ; --------------------------------------------------------------------
 3293: 1                        ; @CALBAK       TETUPDATE
 3294: 1                        ; --------------------------------------------------------------------
 3295: 1                        ; The main update routine of this session.
 3296: 1                        ; This procedure performs following operation.
 3297: 1                        ; 1. Decrease block drop counter by 1.
 3298: 1                        ; 2. If Block drop counter goes 0, reset it as specific number and drop
 3299: 1                        ;   block by 1.
 3300: 1                        ; 3. If there's nowhere to move when dropping block, then hold the
 3301: 1                        ;   block on the board, and get next block.
 3302: 1  45D7                  cTETUPDATE:
 3303: 1        N        02             USING   GAMEBANK/8
 3304: 1
 3305: 1                                ; Check if the block count indicates zero.
 3306: 1  45D7  90 21 03                MOV     DPTR,   #TT_CNTLEFT
 3307: 1  45DA  E0                      MOVX    A,      @DPTR
 3308: 1  45DB  60 03                   JZ      TETUPDATE_ON_CNT_ZERO
 3309: 1
 3310: 1                                ; Store the count left
 3311: 1  45DD  14                      DEC     A
 3312: 1  45DE  F0                      MOVX    @DPTR,  A
 3313: 1
 3314: 1  45DF  22                      RET
 3315: 1
 3316: 1  45E0                  TETUPDATE_ON_CNT_ZERO:
 3317: 1                        ; Determines where the count zero event should go.
 3318: 1                                ; Check if the block can be moved.
 3319: 1  45E0  90 21 08                MOV     DPTR,   #TT_CB_PVT
 3320: 1  45E3  E0                      MOVX    A,      @DPTR
 3321: 1                                ; To call check bound
 3322: 1  45E4  FB                      MOV     R3,     A
 3323: 1  45E5  24 10                   ADD     A,      #00010000B
 3324: 1  45E7  FA                      MOV     R2,     A
 3325: 1
 3326: 1  45E8  05 82                   INC     DPL
 3327: 1  45EA  B1 3B                   CALL    sCHECKBOUND
 3328: 1
 3329: 1                                ; VALIDATION INFO = F0
 3330: 1  45EC  30 D5 0A                JNB     F0,     TETUPDATE_ON_BLOCK_FIX
 3331: 1  45EF                  TETUPDATE_ON_BLOCK_DOWN:
 3332: 1                                ; Store new block info.
 3333: 1  45EF  90 21 08                MOV     DPTR,   #TT_CB_PVT
 3334: 1  45F2  EA                      MOV     A,      R2
 3335: 1  45F3  F0                      MOVX    @DPTR,  A
 3336: 1
 3337: 1                                ; If drop block, jump to entry again.
 3338: 1  45F4  20 76 E0                JB      TT_DROPBLOCK,   cTETUPDATE
 3339: 1                                ; done.
 3340: 1  45F7  C1 F4                   AJMP    TETUPDATE_BLOCK_CNT_RESET
 3341: 1
 3342: 1  45F9                  TETUPDATE_ON_BLOCK_FIX:
 3343: 1                        ; Draws block color on board
 3344: 1                        ; Tries to generate new block, and if cannot do so, game overs.
 3345: 1                        ; And checks block lines to find if there's any score gain.
 3346: 1                        ; If it exists, remove it and update score.
 3347: 1  45F9  C2 76                   CLR     TT_DROPBLOCK; On fix, cancel drop block.
 3348: 1                                ; ADD SCORE BY 1 BASICALLY.
 3349: 1  45FB  75 F0 01                MOV     B,      #1H
 3350: 1  45FE  71 BA                   CALL    rADDSCORE
 3351: 1  4600  D2 7B                   SETB    TT_SCOREDIRTY
 3352: 1
 3353: 1                                ; Draws block color on given location.
 3354: 1                                ; First, gets the color.
 3355: 1  4602  90 21 05                MOV     DPTR,   #TT_CB_TYPE
 3356: 1  4605  E0                      MOVX    A,      @DPTR
 3357: 1  4606  90 45 10                MOV     DPTR,   #TT_BLOCK_COLOR
 3358: 1  4609  93                      MOVC    A,      @A+DPTR; Gets block color
 3359: 1  460A  F5 20                   MOV     BR0,    A; Caches it
 3360: 1
 3361: 1                                ; pivot point.
 3362: 1                                LDCDWP2 R0,     TT_CB_PVT
 3363+ 2                                MOVP2           #HIGH(TT_CB_PVT)
 3364+ 3  460C  75 36 21                MOV     GLB_P2CACHE,#HIGH(TT_CB_PVT)
 3365+ 3  460F  75 A0 21                MOV     P2,     #HIGH(TT_CB_PVT)
 3366+ 2  4612  78 08                   MOV     R0,     #LOW(TT_CB_PVT)
 3367: 1  4614  E2                      MOVX    A,      @R0
 3368: 1        R        R4     PIVOT   SET     R4
 3369: 1  4615  FC                      MOV     PIVOT,  A; CACHE PIVOT
 3370: 1
 3371: 1                                ; fix it to board.
 3372: 1  4616  90 20 00                MOV     DPTR,   #TT_BOARD
 3373: 1  4619  F5 82                   MOV     DPL,    A
 3374: 1  461B  E5 20                   MOV     A,      BR0
 3375: 1  461D  F0                      MOVX    @DPTR,  A
 3376: 1
 3377: 1                                ; For each block links..
 3378: 1  461E  7B 03                   MOV     R3,     #3
 3379: 1  4620                  TETUPDATE_FIXING_BLOCK:
 3380: 1                                ; for next block link ..
 3381: 1  4620  08                      INC     R0
 3382: 1  4621  E2                      MOVX    A,      @R0
 3383: 1                                ; caculate exact location
 3384: 1  4622  C4                      SWAP    A
 3385: 1                                ADDBLKRELC      A,      PIVOT
 3386+ 2  4623  C0 E0                   PUSH    ACC
 3387+ 2                                ; Adds upper 4bit first.
 3388+ 2  4625  54 F0                   ANL     A,      #0F0H
 3389+ 2  4627  2C                      ADD     A,      PIVOT
 3390+ 2  4628  54 F0                   ANL     A,      #0F0H
 3391+ 2                                ; Adds lower 4bit
 3392+ 2  462A  F5 F0                   MOV     B,      A
 3393+ 2  462C  D0 E0                   POP     ACC
 3394+ 2  462E  2C                      ADD     A,      PIVOT
 3395+ 2  462F  54 0F                   ANL     A,      #00FH
 3396+ 2                                ; Adds each value other.
 3397+ 2  4631  25 F0                   ADD     A,      B
 3398: 1                                ; fix it.
 3399: 1  4633  F5 82                   MOV     DPL,    A
 3400: 1  4635  E5 20                   MOV     A,      BR0
 3401: 1  4637  F0                      MOVX    @DPTR,  A
 3402: 1  4638  DB E6                   DJNZ    R3,     TETUPDATE_FIXING_BLOCK
 3403: 1
 3404: 1                                ; If there was any score gain, pull down all the line elements from upper.
 3405: 1  463A  7E 00                   MOV     R6,     #0; SCORE_GETD
 3406: 1  463C  7F 00                   MOV     R7,     #0
 3407: 1                                ; scans the line from upper.
 3408: 1  463E                  TETUPDATE_SCAN:
 3409: 1        R        R3     HEAD    SET     R3
 3410: 1  463E  7B 10                   MOV     HEAD,   #16
 3411: 1
 3412: 1  4640                  TETUPDATE_SCAN_0:
 3413: 1  4640  90 20 00                MOV     DPTR,   #TT_BOARD
 3414: 1  4643  12 46 7F                CALL    TUP_SCANL
 3415: 1                                ; Check if there's any score gain.
 3416: 1  4646  30 D5 21                JNB     F0,     TETUPDATE_SCAN_1
 3417: 1                                ; Line destroied
 3418: 1  4649  12 46 93                CALL    TUP_COPYL
 3419: 1  464C  0E                      INC     R6
 3420: 1  464D  EE                      MOV     A,      R6
 3421: 1  464E  2F                      ADD     A,      R7
 3422: 1  464F  FF                      MOV     R7,     A
 3423: 1
 3424: 1                                ; Level counter
 3425: 1  4650  90 21 01                MOV     DPTR,   #TT_TONEXTLV
 3426: 1  4653  E0                      MOVX    A,      @DPTR
 3427: 1  4654  14                      DEC     A
 3428: 1  4655  F0                      MOVX    @DPTR,  A
 3429: 1  4656  70 E8                   JNZ     TETUPDATE_SCAN_0
 3430: 1                                ; --> to next level...
 3431: 1  4658  90 21 00                MOV     DPTR,   #TT_LEVEL
 3432: 1  465B  E0                      MOVX    A,      @DPTR
 3433: 1  465C  04                      INC     A
 3434: 1  465D  F0                      MOVX    @DPTR,  A
 3435: 1
 3436: 1                                ; Level up count = LEVEL * 7
 3437: 1  465E  75 F0 07                MOV     B,      #7
 3438: 1  4661  A4                      MUL     AB
 3439: 1
 3440: 1  4662  90 21 01                MOV     DPTR,   #TT_TONEXTLV
 3441: 1  4665  F0                      MOVX    @DPTR,  A
 3442: 1
 3443: 1                                ; Set flags
 3444: 1  4666  D2 78                   SETB    TT_LVLDIRTY
 3445: 1
 3446: 1  4668  80 D6                   SJMP    TETUPDATE_SCAN_0
 3447: 1  466A                  TETUPDATE_SCAN_1:
 3448: 1  466A  DB D4                   DJNZ    HEAD,   TETUPDATE_SCAN_0
 3449: 1
 3450: 1                                ; Apply score gain.
 3451: 1  466C  EF                      MOV     A,      R7
 3452: 1  466D  75 F0 03                MOV     B,      #3
 3453: 1  4670  A4                      MUL     AB
 3454: 1  4671  D4                      DA      A
 3455: 1  4672  F5 F0                   MOV     B,      A
 3456: 1
 3457: 1  4674  90 21 00                MOV     DPTR,   #TT_LEVEL
 3458: 1  4677  E0                      MOVX    A,      @DPTR
 3459: 1  4678  A4                      MUL     AB
 3460: 1  4679  F5 F0                   MOV     B,      A
 3461: 1
 3462: 1  467B  71 BA                   CALL    rADDSCORE
 3463: 1
 3464: 1
 3465: 1                                ; Skip subroutine area
 3466: 1  467D  80 36                   SJMP    TETUPDATE_CONTINUE
 3467: 1                        ; ---------------- SUBROUTINES.
 3468: 1  467F                  TUP_SCANL:
 3469: 1                        ; I     R3      HEAD + 1
 3470: 1                        ; I     DPTR    BOARD
 3471: 1                        ; OUT   F0      LINE FILLED?
 3472: 1                        ; X     R4
 3473: 1                                ; Scan specified line and returns result if the line has fully filled.
 3474: 1                                ; The head address indicates Y index.
 3475: 1  467F  EB                      MOV     A,      R3
 3476: 1  4680  14                      DEC     A
 3477: 1  4681  C4                      SWAP    A
 3478: 1  4682  F5 82                   MOV     DPL,    A
 3479: 1
 3480: 1                                ; Iteration count
 3481: 1  4684  7C 0A                   MOV     R4,     #10
 3482: 1
 3483: 1                                ; Result.
 3484: 1  4686  D2 D5                   SETB    F0
 3485: 1  4688                  TUP_SCANL_LP:
 3486: 1  4688  E0                      MOVX    A,      @DPTR
 3487: 1  4689  70 03                   JNZ     TUP_SCANL_KEEP; If any line indicates 0, this line is empty.
 3488: 1  468B  C2 D5                   CLR     F0
 3489: 1  468D  22                      RET
 3490: 1  468E                  TUP_SCANL_KEEP:
 3491: 1  468E  05 82                   INC     DPL
 3492: 1  4690  DC F6                   DJNZ    R4,     TUP_SCANL_LP
 3493: 1                        ; ~F0
 3494: 1  4692  22                      RET
 3495: 1                        ; ~~FUNC
 3496: 1
 3497: 1                        ; --------------------
 3498: 1  4693                  TUP_COPYL:
 3499: 1                        ; I     R3      HEAD
 3500: 1                        ; Coppies upper line into lower line.
 3501: 1                                MOVP2   DPH
 3502+ 2  4693  85 83 36                MOV     GLB_P2CACHE,DPH
 3503+ 2  4696  85 83 A0                MOV     P2,     DPH
 3504: 1
 3505: 1                                ; line HEAD will be removed.
 3506: 1  4699  EB                      MOV     A,      R3
 3507: 1  469A  FC                      MOV     R4,     A
 3508: 1
 3509: 1  469B                  TUP_COPYL_0:
 3510: 1                        ; Until all the line'd be shifted down...
 3511: 1                                ; Destination
 3512: 1  469B  EC                      MOV     A,      R4
 3513: 1  469C  14                      DEC     A
 3514: 1  469D  C4                      SWAP    A
 3515: 1  469E  F8                      MOV     R0,     A
 3516: 1                                ; Source
 3517: 1  469F  EC                      MOV     A,      R4
 3518: 1  46A0  14                      DEC     A
 3519: 1  46A1  14                      DEC     A
 3520: 1  46A2  C4                      SWAP    A
 3521: 1  46A3  F9                      MOV     R1,     A
 3522: 1
 3523: 1  46A4  7D 0A                   MOV     R5,     #10; Iteration count
 3524: 1
 3525: 1  46A6                  TUP_COPYL_1:
 3526: 1                        ; Copies data from upper to lower.
 3527: 1  46A6  E3                      MOVX    A,      @R1
 3528: 1  46A7  F2                      MOVX    @R0,    A
 3529: 1  46A8  08                      INC     R0
 3530: 1  46A9  09                      INC     R1
 3531: 1  46AA  DD FA                   DJNZ    R5,     TUP_COPYL_1
 3532: 1  46AC  DC ED                   DJNZ    R4,     TUP_COPYL_0
 3533: 1                        ; ~~TUP_COPYL_0
 3534: 1  46AE                  TUP_COPYL_3:
 3535: 1
 3536: 1  46AE  7D 0A                   MOV     R5,     #10
 3537: 1  46B0  78 00                   MOV     R0,     #0
 3538: 1  46B2  74 00                   MOV     A,      #0
 3539: 1  46B4                  TUP_COPYL_2:
 3540: 1                        ; Clears topmost line as 0.
 3541: 1                                ;MOVX   @R0,    A
 3542: 1                                ;INC    R0
 3543: 1                                ;DJNZ   R5,     TUP_COPYL_2
 3544: 1                        ; ~~TUP_COPYL_2
 3545: 1
 3546: 1  46B4  22                      RET
 3547: 1
 3548: 1
 3549: 1  46B5                  TETUPDATE_CONTINUE:
 3550: 1                                ; Reset pivot
 3551: 1  46B5  90 21 08                MOV     DPTR,   #TT_CB_PVT
 3552: 1  46B8  74 14                   MOV     A,      #014H
 3553: 1  46BA  F0                      MOVX    @DPTR,  A
 3554: 1
 3555: 1                                ; Generates next block.
 3556: 1                                ; Gets rand number.
 3557: 1  46BB  E5 8B                   MOV     A,      RANDNUM
 3558: 1  46BD  75 F0 07                MOV     B,      #7
 3559: 1  46C0  84                      DIV     AB
 3560: 1
 3561: 1                                ; Next block will be current.
 3562: 1  46C1  90 21 06                MOV     DPTR,   #TT_NB_TYPE
 3563: 1  46C4  E0                      MOVX    A,      @DPTR
 3564: 1  46C5  90 21 05                MOV     DPTR,   #TT_CB_TYPE
 3565: 1  46C8  F0                      MOVX    @DPTR,  A
 3566: 1
 3567: 1                                ; Rand % 7 will be next block.
 3568: 1  46C9  90 21 06                MOV     DPTR,   #TT_NB_TYPE
 3569: 1  46CC  E5 F0                   MOV     A,      B
 3570: 1  46CE  F0                      MOVX    @DPTR,  A
 3571: 1
 3572: 1  46CF  D2 7A                   SETB    TT_NEXTDIRTY
 3573: 1
 3574: 1  46D1  B1 A5                   CALL    sGENBLOCK
 3575: 1
 3576: 1                                ; Check if new block location is valid.
 3577: 1                                ; If not, game overs.
 3578: 1                                ; @todo
 3579: 1                                ; calling CHECKBOUND
 3580: 1  46D3  90 21 08                MOV     DPTR,   #TT_CB_PVT
 3581: 1  46D6  E0                      MOVX    A,      @DPTR
 3582: 1  46D7  FA                      MOV     R2,     A
 3583: 1  46D8  FB                      MOV     R3,     A
 3584: 1
 3585: 1  46D9  05 82                   INC     DPL
 3586: 1  46DB  B1 3B                   CALL    sCHECKBOUND
 3587: 1
 3588: 1  46DD  20 D5 14                JB      F0,     TETUPDATE_BLOCK_CNT_RESET
 3589: 1                                ; --> if generated block is on invalid location ==> game over.
 3590: 1  46E0  90 12 0A                MOV     DPTR,   #RANKING_RETURN
 3591: 1  46E3  74 17                   MOV     A,      #LOW(rSESSION_TETRIS)
 3592: 1  46E5  F0                      MOVX    @DPTR,  A
 3593: 1
 3594: 1  46E6  05 82                   INC     DPL
 3595: 1  46E8  74 45                   MOV     A,      #HIGH(rSESSION_TETRIS)
 3596: 1  46EA  F0                      MOVX    @DPTR,  A
 3597: 1
 3598: 1  46EB  90 12 20                MOV     DPTR,   #RANKING_GAMEINFO
 3599: 1  46EE  74 00                   MOV     A,      #0
 3600: 1  46F0  F0                      MOVX    @DPTR,  A
 3601: 1
 3602: 1  46F1  51 DB                   CALL    rTORANKING
 3603: 1  46F3  22                      RET
 3604: 1  46F4                  TETUPDATE_BLOCK_CNT_RESET:
 3605: 1                                ; 30 - 3*LEVEL should be new delay count
 3606: 1  46F4  90 21 00                MOV     DPTR,   #TT_LEVEL
 3607: 1  46F7  E0                      MOVX    A,      @DPTR
 3608: 1  46F8  75 F0 03                MOV     B,      #3
 3609: 1  46FB  A4                      MUL     AB
 3610: 1                                ; ~(A - 30) + 1 = 30 - A
 3611: 1  46FC  24 E2                   ADD     A,      #-30
 3612: 1  46FE  F4                      CPL     A
 3613: 1  46FF  04                      INC     A
 3614: 1                                ; Stores it.
 3615: 1  4700  90 21 03                MOV     DPTR,   #TT_CNTLEFT
 3616: 1  4703  F0                      MOVX    @DPTR,  A
 3617: 1
 3618: 1                                ; Refresh dirty flags.
 3619: 1  4704  D2 79                   SETB    TT_BOARDDIRTY
 3620: 1  4706  C2 77                   CLR     TT_FLGCLR
 3621: 1                                ; done.
 3622: 1  4708  22                      RET
 3623: 1                        ; --------------------------------------------------------------------
 3624: 1                        ; @CALBAK       TETINIT
 3625: 1                        ; --------------------------------------------------------------------
 3626: 1  4709                  cTETINIT:       ; TETRIS GAME LOGIC INITIALIZE
 3627: 1  4709  D2 7B                   SETB    TT_SCOREDIRTY
 3628: 1  470B  D2 78                   SETB    TT_LVLDIRTY
 3629: 1  470D  D2 79                   SETB    TT_BOARDDIRTY
 3630: 1  470F  D2 7A                   SETB    TT_NEXTDIRTY
 3631: 1  4711  C2 77                   CLR     TT_FLGCLR
 3632: 1
 3633: 1  4713  71 A7                   CALL    rINITSCORE
 3634: 1
 3635: 1                                ; RANDOM BLOCKS
 3636: 1  4715  E5 8B                   MOV     A,      RANDNUM
 3637: 1  4717  75 F0 07                MOV     B,      #7
 3638: 1  471A  84                      DIV     AB
 3639: 1
 3640: 1                                ; A % 8 will be stored as current block
 3641: 1  471B  90 21 06                MOV     DPTR,   #TT_NB_TYPE
 3642: 1  471E  C0 E0                   PUSH    ACC
 3643: 1  4720  E5 F0                   MOV     A,      B
 3644: 1  4722  F0                      MOVX    @DPTR,  A
 3645: 1
 3646: 1                                ; B will be stored as current block
 3647: 1  4723  90 21 05                MOV     DPTR,   #TT_CB_TYPE
 3648: 1  4726  D0 E0                   POP     ACC
 3649: 1  4728  75 F0 07                MOV     B,      #7
 3650: 1  472B  84                      DIV     AB
 3651: 1  472C  E5 F0                   MOV     A,      B
 3652: 1  472E  F0                      MOVX    @DPTR,  A
 3653: 1
 3654: 1                                ; Reset active block pivot
 3655: 1  472F  90 21 08                MOV     DPTR,   #TT_CB_PVT
 3656: 1  4732  74 14                   MOV     A,      #014H
 3657: 1  4734  F0                      MOVX    @DPTR,  A
 3658: 1
 3659: 1                                ; Generate current block
 3660: 1  4735  B1 A5                   CALL    sGENBLOCK
 3661: 1
 3662: 1                                ; Reset level
 3663: 1  4737  90 21 00                MOV     DPTR,   #TT_LEVEL
 3664: 1  473A  74 01                   MOV     A,      #1
 3665: 1  473C  F0                      MOVX    @DPTR,  A
 3666: 1
 3667: 1                                ; Reset level up count
 3668: 1  473D  90 21 01                MOV     DPTR,   #TT_TONEXTLV
 3669: 1  4740  74 05                   MOV     A,      #5
 3670: 1  4742  F0                      MOVX    @DPTR,  A
 3671: 1
 3672: 1
 3673: 1                                ; clear flags
 3674: 1  4743  C2 76                   CLR     TT_DROPBLOCK
 3675: 1
 3676: 1  4745  22                      RET
 3677: 1                        ; --------------------------------------------------------------------
 3678: 1                        ; @CALBAK       TETDNDRAW
 3679: 1                        ; --------------------------------------------------------------------
 3680: 1  4746                  cTETDNDRAW: ; TETRIS DYNAMIC DRAW
 3681: 1        N        02             USING   GAMEBANK/8
 3682: 1                                ; CACHES BACK BUFFER
 3683: 1  4746  51 83                   CALL    rBUFFER_BACK
 3684: 1  4748  FF                      MOV     R7,     A
 3685: 1        R        R7     BACKBUFFER      SET     R7
 3686: 1
 3687: 1                        ; Dirty flag will be drawn later ...
 3688: 1  4749                  TETDNDRAW_LV:
 3689: 1                        ; Meanless label for identification
 3690: 1  4749  30 78 22                JNB     TT_LVLDIRTY,    TETDNDRAW_BRD
 3691: 1                                ; Clear target board area
 3692: 1  474C  8F 83                   MOV     DPH,    BACKBUFFER
 3693: 1  474E  75 82 E1                MOV     DPL,    #TT_PV_LVL
 3694: 1  4751  75 F0 00                MOV     B,      #000B
 3695: 1  4754  79 04                   MOV     R1,     #4
 3696: 1  4756  7A 06                   MOV     R2,     #6
 3697: 1  4758  C3                      CLR     C
 3698: 1  4759  11 EA                   CALL    rFILLBOX
 3699: 1                                ; Draw level information
 3700: 1  475B  90 21 00                MOV     DPTR,   #TT_LEVEL
 3701: 1  475E  E0                      MOVX    A,      @DPTR
 3702: 1                                ; To ASCII
 3703: 1  475F  24 30                   ADD     A,      #'0'
 3704: 1                                ; @See RDRAWASCII
 3705: 1  4761  75 F0 03                MOV     B,      #011B
 3706: 1                                MOVP2   R7
 3707+ 2  4764  8F 36                   MOV     GLB_P2CACHE,R7
 3708+ 2  4766  8F A0                   MOV     P2,     R7
 3709: 1  4768  79 E1                   MOV     R1,     #TT_PV_LVL
 3710: 1  476A  C2 D5                   CLR     F0
 3711: 1  476C  31 AE                   CALL    rDRAWASCII
 3712: 1  476E                  TETDNDRAW_BRD:
 3713: 1  476E  20 79 03                JB      TT_BOARDDIRTY,  TETDNDRAW_BRD_ENTRY
 3714: 1  4771  02 48 14                JMP     TETDNDRAW_SCORE
 3715: 1
 3716: 1  4774                  TETDNDRAW_BRD_ENTRY:
 3717: 1                                ; >> Clears board
 3718: 1                                ; ##deprecated since drawing black dots at duplicated location on the code below wastes the
       1                        performance.
 3719: 1                                ;MOV    DPH,    BACKBUFFER
 3720: 1                                ;MOV    DPL,    #TT_PV_BOARD
 3721: 1                                ;MOV    B,      #0
 3722: 1                                ;MOV    R1,     #10
 3723: 1                                ;MOV    R2,     #16
 3724: 1                                ;CLR    C
 3725: 1                                ;CALL   rFILLBOX
 3726: 1
 3727: 1                                ; >> Draw board geometry
 3728: 1                                ; Draws dot for 0x00 ~ 0x9f
 3729: 1                                LDCDWP2         R0,     TT_BOARD
 3730+ 2                                MOVP2           #HIGH(TT_BOARD)
 3731+ 3  4774  75 36 20                MOV     GLB_P2CACHE,#HIGH(TT_BOARD)
 3732+ 3  4777  75 A0 20                MOV     P2,     #HIGH(TT_BOARD)
 3733+ 2  477A  78 00                   MOV     R0,     #LOW(TT_BOARD)
 3734: 1  477C  8F 83                   MOV     DPH,    BACKBUFFER
 3735: 1
 3736: 1  477E  7C 10                   MOV     R4,     #16; Vertical index
 3737: 1  4780                  TETDNDRAW_BRD_BRD0:
 3738: 1  4780  7B 0A                   MOV     R3,     #10; Horizontal index
 3739: 1  4782                  TETDNDRAW_BRD_BRD1:
 3740: 1                                ; Assemble r4 and r3, then use it to draw board color.
 3741: 1  4782  EC                      MOV     A,      R4
 3742: 1  4783  14                      DEC     A; should be decreased for 1.
 3743: 1  4784  C4                      SWAP    A; R4 indicates Y coordinate.
 3744: 1  4785  2B                      ADD     A,      R3
 3745: 1  4786  14                      DEC     A; R3 indicates X coordinate.
 3746: 1                                ; extracts color from board and caches it
 3747: 1  4787  F8                      MOV     R0,     A
 3748: 1  4788  E2                      MOVX    A,      @R0
 3749: 1  4789  C0 E0                   PUSH    ACC
 3750: 1
 3751: 1                                ; find location on board.
 3752: 1  478B  E8                      MOV     A,      R0
 3753: 1                                BLKTODISP       A
 3754+ 2  478C  C0 E0                   PUSH    ACC
 3755+ 2                                ; Upper 4bit to F0 + 3bit ofst
 3756+ 2  478E  54 F0                   ANL     A,      #0F0H
 3757+ 2  4790  33                      RLC     A
 3758+ 2  4791  92 D5                   MOV     F0,     C
 3759+ 2                                ; Lower 4bit and add 7 to shift right.
 3760+ 2  4793  54 E0                   ANL     A,      #11100000B
 3761+ 2  4795  D0 F0                   POP     B
 3762+ 2                                ; Masks B, its lower value.
 3763+ 2  4797  53 F0 0F                ANL     B,      #0FH
 3764+ 2  479A  25 F0                   ADD     A,      B
 3765+ 2  479C  24 06                   ADD     A,      #6
 3766+ 2                                ; now result in A
 3767: 1  479E  F5 82                   MOV     DPL,    A
 3768: 1  47A0  A2 D5                   MOV     C,      F0
 3769: 1  47A2  D0 F0                   POP     B; color which was cached.
 3770: 1  47A4  51 56                   CALL    rDRAWDOT
 3771: 1
 3772: 1  47A6  DB DA                   DJNZ    R3,     TETDNDRAW_BRD_BRD1
 3773: 1                        ; ~~LP ------
 3774: 1  47A8  DC D6                   DJNZ    R4,     TETDNDRAW_BRD_BRD0
 3775: 1                        ; ~LP -------
 3776: 1
 3777: 1                                ; >> Draw current active block instance
 3778: 1                                ; Extracts color information
 3779: 1  47AA  90 21 05                MOV     DPTR,   #TT_CB_TYPE
 3780: 1  47AD  E0                      MOVX    A,      @DPTR
 3781: 1  47AE  90 45 10                MOV     DPTR,   #TT_BLOCK_COLOR
 3782: 1  47B1  93                      MOVC    A,      @A+DPTR
 3783: 1                                ; Caches color
 3784: 1        R        R5     COLOR   SET     R5
 3785: 1  47B2  FD                      MOV     COLOR,  A
 3786: 1                                ; Draw dot on pivot
 3787: 1                                ; Extracts pivot location
 3788: 1  47B3  90 21 08                MOV     DPTR,   #TT_CB_PVT
 3789: 1  47B6  E0                      MOVX    A,      @DPTR
 3790: 1                                ; Caches pivot location
 3791: 1        R        R6     PIVOT   SET     R6
 3792: 1  47B7  FE                      MOV     PIVOT,  A
 3793: 1
 3794: 1                                ; Draw dot
 3795: 1  47B8  8F 83                   MOV     DPH,    BACKBUFFER
 3796: 1                                BLKTODISP       A
 3797+ 2  47BA  C0 E0                   PUSH    ACC
 3798+ 2                                ; Upper 4bit to F0 + 3bit ofst
 3799+ 2  47BC  54 F0                   ANL     A,      #0F0H
 3800+ 2  47BE  33                      RLC     A
 3801+ 2  47BF  92 D5                   MOV     F0,     C
 3802+ 2                                ; Lower 4bit and add 7 to shift right.
 3803+ 2  47C1  54 E0                   ANL     A,      #11100000B
 3804+ 2  47C3  D0 F0                   POP     B
 3805+ 2                                ; Masks B, its lower value.
 3806+ 2  47C5  53 F0 0F                ANL     B,      #0FH
 3807+ 2  47C8  25 F0                   ADD     A,      B
 3808+ 2  47CA  24 06                   ADD     A,      #6
 3809+ 2                                ; now result in A
 3810: 1  47CC  F5 82                   MOV     DPL,    A
 3811: 1  47CE  A2 D5                   MOV     C,      F0
 3812: 1  47D0  8D F0                   MOV     B,      COLOR
 3813: 1  47D2  51 56                   CALL    rDRAWDOT
 3814: 1
 3815: 1                                ; Load pivot, and calculate for 4 bits.
 3816: 1  47D4  7A 03                   MOV     R2,     #3
 3817: 1  47D6  90 21 08                MOV     DPTR,   #TT_CB_PVT
 3818: 1  47D9                  TETDNDRAW_BRD_AB:
 3819: 1                        ; To reuse DPL for 3 times, push this.
 3820: 1  47D9  05 82                   INC     DPL     ; SInce its value is in PVT now..
 3821: 1  47DB  C0 82                   PUSH    DPL
 3822: 1  47DD  C0 83                   PUSH    DPH
 3823: 1                                ; Gets relative offset.
 3824: 1  47DF  E0                      MOVX    A,      @DPTR
 3825: 1  47E0  C4                      SWAP    A
 3826: 1                                ADDBLKRELC      A,      PIVOT
 3827+ 2  47E1  C0 E0                   PUSH    ACC
 3828+ 2                                ; Adds upper 4bit first.
 3829+ 2  47E3  54 F0                   ANL     A,      #0F0H
 3830+ 2  47E5  2E                      ADD     A,      PIVOT
 3831+ 2  47E6  54 F0                   ANL     A,      #0F0H
 3832+ 2                                ; Adds lower 4bit
 3833+ 2  47E8  F5 F0                   MOV     B,      A
 3834+ 2  47EA  D0 E0                   POP     ACC
 3835+ 2  47EC  2E                      ADD     A,      PIVOT
 3836+ 2  47ED  54 0F                   ANL     A,      #00FH
 3837+ 2                                ; Adds each value other.
 3838+ 2  47EF  25 F0                   ADD     A,      B
 3839: 1                                ; Now there is relative offset in A, changes this to absolute
 3840: 1                                ;offset by adding block alignment info.
 3841: 1                                BLKTODISP       A
 3842+ 2  47F1  C0 E0                   PUSH    ACC
 3843+ 2                                ; Upper 4bit to F0 + 3bit ofst
 3844+ 2  47F3  54 F0                   ANL     A,      #0F0H
 3845+ 2  47F5  33                      RLC     A
 3846+ 2  47F6  92 D5                   MOV     F0,     C
 3847+ 2                                ; Lower 4bit and add 7 to shift right.
 3848+ 2  47F8  54 E0                   ANL     A,      #11100000B
 3849+ 2  47FA  D0 F0                   POP     B
 3850+ 2                                ; Masks B, its lower value.
 3851+ 2  47FC  53 F0 0F                ANL     B,      #0FH
 3852+ 2  47FF  25 F0                   ADD     A,      B
 3853+ 2  4801  24 06                   ADD     A,      #6
 3854+ 2                                ; now result in A
 3855: 1  4803  8F 83                   MOV     DPH,    BACKBUFFER
 3856: 1  4805  F5 82                   MOV     DPL,    A
 3857: 1  4807  A2 D5                   MOV     C,      F0
 3858: 1  4809  8D F0                   MOV     B,      COLOR
 3859: 1  480B  12 42 56                CALL    rDRAWDOT
 3860: 1                                ; Pops DPL.
 3861: 1  480E  D0 83                   POP     DPH
 3862: 1  4810  D0 82                   POP     DPL
 3863: 1  4812  DA C5                   DJNZ    R2,     TETDNDRAW_BRD_AB
 3864: 1                        ; ~~~ LOOP DONE
 3865: 1
 3866: 1                                ; Draw dots on pivot links
 3867: 1  4814                  TETDNDRAW_SCORE:
 3868: 1  4814  30 7B 39                JNB     TT_SCOREDIRTY,  TETDNDRAW_NEXT
 3869: 1                                ; Draws score information
 3870: 1
 3871: 1                                ; lower 2 bytes will be used.
 3872: 1                                LDCDWP2 R0,     (RANKING_SCORE+1)
 3873+ 2                                MOVP2           #HIGH((RANKING_SCORE+1))
 3874+ 3  4817  75 36 12                MOV     GLB_P2CACHE,#HIGH((RANKING_SCORE+1))
 3875+ 3  481A  75 A0 12                MOV     P2,     #HIGH((RANKING_SCORE+1))
 3876+ 2  481D  78 22                   MOV     R0,     #LOW((RANKING_SCORE+1))
 3877: 1  481F  90 21 0C                MOV     DPTR,   #STRCACHE; result string will be loaded here
 3878: 1  4822  E2                      MOVX    A,      @R0
 3879: 1  4823  F5 F0                   MOV     B,      A
 3880: 1  4825  12 40 41                CALL    rDTOA
 3881: 1
 3882: 1  4828  18                      DEC     R0
 3883: 1  4829  E2                      MOVX    A,      @R0
 3884: 1  482A  F5 F0                   MOV     B,      A
 3885: 1  482C  12 40 41                CALL    rDTOA
 3886: 1
 3887: 1                                ; Clear target board area
 3888: 1  482F  8F 83                   MOV     DPH,    BACKBUFFER
 3889: 1  4831  75 82 70                MOV     DPL,    #TT_PV_SCORE
 3890: 1  4834  75 F0 00                MOV     B,      #000B
 3891: 1  4837  79 10                   MOV     R1,     #16
 3892: 1  4839  7A 06                   MOV     R2,     #6
 3893: 1  483B  C3                      CLR     C
 3894: 1  483C  12 40 EA                CALL    rFILLBOX
 3895: 1
 3896: 1                                ; Draw string on there.
 3897: 1  483F  C2 D5                   CLR     F0
 3898: 1                                MOVP2   BACKBUFFER
 3899+ 2  4841  8F 36                   MOV     GLB_P2CACHE,BACKBUFFER
 3900+ 2  4843  8F A0                   MOV     P2,     BACKBUFFER
 3901: 1  4845  79 70                   MOV     R1,     #TT_PV_SCORE
 3902: 1  4847  90 21 0C                MOV     DPTR,   #STRCACHE
 3903: 1  484A  75 F0 06                MOV     B,      #110B
 3904: 1  484D  12 41 7C                CALL    rDRAWSTRING
 3905: 1
 3906: 1  4850                  TETDNDRAW_NEXT:
 3907: 1  4850  30 7A 3D                JNB     TT_NEXTDIRTY,   TETDNDRAW_DONE
 3908: 1                                ; Draw next block information
 3909: 1  4853  90 21 06                MOV     DPTR,   #TT_NB_TYPE
 3910: 1  4856  E0                      MOVX    A,      @DPTR
 3911: 1                                ; Caches it
 3912: 1  4857  F5 F0                   MOV     B,      A
 3913: 1                                ; Get block draw information
 3914: 1  4859  90 45 09                MOV     DPTR,   #TT_BLOCKSHAPE
 3915: 1  485C  93                      MOVC    A,      @A+DPTR
 3916: 1                                ; Caches it
 3917: 1  485D  FB                      MOV     R3,     A
 3918: 1
 3919: 1                                ; Extract color info
 3920: 1  485E  90 45 10                MOV     DPTR,   #TT_BLOCK_COLOR
 3921: 1  4861  E5 F0                   MOV     A,      B
 3922: 1  4863  93                      MOVC    A,      @A+DPTR
 3923: 1                                ; Caches it
 3924: 1  4864  FC                      MOV     R4,     A
 3925: 1
 3926: 1                        CONST   TT_NEXT_PIVOT, 01000001B
 3927+ 2        N      0041     TT_NEXT_PIVOT   EQU     01000001B
 3928: 1  4865  8F 83                   MOV     DPH,    R7
 3929: 1  4867  75 82 41                MOV     DPL,    #TT_NEXT_PIVOT
 3930: 1                                ; Draw next block loop... UPPER LINE
 3931: 1  486A  7A 04                   MOV     R2,     #4
 3932: 1  486C                  TETDNDRAW_NBLP:
 3933: 1                        ; 0 is black, 1 is given block color
 3934: 1                                ; If the rightmost bit is 1...
 3935: 1                                ; Don't need to care current carry bit which will be set in leftmost.
 3936: 1  486C  EB                      MOV     A,      R3
 3937: 1  486D  33                      RLC     A
 3938: 1  486E  FB                      MOV     R3,     A
 3939: 1  486F  50 08                   JNC     TETDNDDRAW_DRAWBLACK
 3940: 1                                ; DRAW COLOR
 3941: 1  4871  8C F0                   MOV     B,      R4
 3942: 1  4873  C3                      CLR     C
 3943: 1  4874  12 42 56                CALL    rDRAWDOT
 3944: 1  4877  80 07                   SJMP    TETDNDRAW_NBDONE
 3945: 1  4879                  TETDNDDRAW_DRAWBLACK:
 3946: 1                                ; DRAW BLACK
 3947: 1  4879  C3                      CLR     C
 3948: 1  487A  75 F0 00                MOV     B,      #0
 3949: 1  487D  12 42 56                CALL    rDRAWDOT
 3950: 1  4880                  TETDNDRAW_NBDONE:
 3951: 1  4880  05 82                   INC     DPL
 3952: 1  4882  DA E8                   DJNZ    R2,     TETDNDRAW_NBLP
 3953: 1  4884  E5 82                   MOV     A,      DPL
 3954: 1  4886  20 E5 07                JB      ACC.5,  TETDNDRAW_DONE
 3955: 1                                ; Draw LOWER LINE
 3956: 1  4889  75 82 61                MOV     DPL,    #TT_NEXT_PIVOT + 20H
 3957: 1  488C  7A 04                   MOV     R2,     #4
 3958: 1  488E  80 DC                   SJMP    TETDNDRAW_NBLP
 3959: 1  4890                  TETDNDRAW_DONE:
 3960: 1                                ; To avoid situation that the elements are drawn only
 3961: 1                                ;in single buffer, this flag is used. On the first draw
 3962: 1                                ;call, not any flag will be cleard though they are already
 3963: 1                                ;drawn on a single buffer, but they are cleared on the
 3964: 1                                ;second call. However, there is possibility that the flag
 3965: 1                                ;information has changed while in the middle of dirty flag
 3966: 1                                ;clearing, therefore this flag should be reset on any
 3967: 1                                ;dirty flag activation.
 3968: 1  4890  20 77 03                JB      TT_FLGCLR,      TETDNDRAW_CLR
 3969: 1  4893  D2 77                   SETB    TT_FLGCLR
 3970: 1  4895  22                      RET
 3971: 1  4896                  TETDNDRAW_CLR:
 3972: 1  4896  C2 77                   CLR     TT_FLGCLR
 3973: 1  4898  C2 78                   CLR     TT_LVLDIRTY
 3974: 1  489A  C2 7A                   CLR     TT_NEXTDIRTY
 3975: 1  489C  C2 79                   CLR     TT_BOARDDIRTY
 3976: 1  489E  C2 7B                   CLR     TT_SCOREDIRTY
 3977: 1  48A0  22                      RET
 3978: 1                        ; --------------------------------------------------------------------
 3979: 1                        ; @CALBAK       TETSTDRAW
 3980: 1                        ; --------------------------------------------------------------------
 3981: 1  48A1                  cTETSTDRAW: ; TETRIS STATIC DRAW
 3982: 1                        ; [0...5, 0...5]        NEXT BLOCK WITH BOUNDARY
 3983: 1                        ; [0...4, 6...11]       LEVEL DISPLAY
 3984: 1                        ; [5...16, 0...15]      TETRIS BOARD WITH BOUNDARY
 3985: 1                        ; [17...31, 3...10]     SCORE DISPLAY WITH BOUNDARY
 3986: 1        N        02             USING   GAMEBANK/8
 3987: 1
 3988: 1                                ; Cache current back buffer
 3989: 1  48A1  12 42 83                CALL    rBUFFER_BACK
 3990: 1  48A4  FF                      MOV     R7,     A
 3991: 1
 3992: 1                                ; Clears screen
 3993: 1  48A5  74 00                   MOV     A,      #0
 3994: 1  48A7  12 40 73                CALL    rFILLBUFFER
 3995: 1
 3996: 1                                ; DRAW NEXT BLOCK BOUNDARY
 3997: 1                                ; @SEE  GRAPHICS.INC/rDRAWBOX
 3998: 1  48AA  8F 83                   MOV     DPH,    R7      ; [0, 0]
 3999: 1  48AC  75 82 00                MOV     DPL,    #0
 4000: 1  48AF  75 F0 07                MOV     B,      #111B   ; [RGB]
 4001: 1  48B2  79 06                   MOV     R1,     #6
 4002: 1  48B4  7A 06                   MOV     R2,     #6
 4003: 1  48B6  C3                      CLR     C
 4004: 1  48B7  12 40 8F                CALL    rDRAWBOX
 4005: 1
 4006: 1                                ; DRAW BOARD BOUNDARY
 4007: 1  48BA  75 82 05                MOV     DPL,    #0101B  ; [5, 0]
 4008: 1  48BD  75 F0 07                MOV     B,      #111B   ; [RGB]
 4009: 1  48C0  79 0C                   MOV     R1,     #12
 4010: 1  48C2  7A 10                   MOV     R2,     #16
 4011: 1  48C4  C3                      CLR     C
 4012: 1  48C5  12 40 8F                CALL    rDRAWBOX
 4013: 1
 4014: 1                                ; To use maximum area, the upper and low lines of boundary
 4015: 1                                ;will be removed
 4016: 1  48C8  75 82 06                MOV     DPL,    #0110B  ; [6, 0]
 4017: 1  48CB  75 F0 00                MOV     B,      #000B   ; [RGB]
 4018: 1  48CE  79 0A                   MOV     R1,     #10
 4019: 1  48D0  7A 10                   MOV     R2,     #16
 4020: 1  48D2  C3                      CLR     C
 4021: 1  48D3  12 40 8F                CALL    rDRAWBOX
 4022: 1
 4023: 1                                ; To draw score boundary, firstly fills right side as white.
 4024: 1  48D6  75 82 11                MOV     DPL,    #00010001B      ; [17, 0]
 4025: 1  48D9  75 F0 07                MOV     B,      #111B
 4026: 1  48DC  79 0F                   MOV     R1,     #15
 4027: 1  48DE  7A 10                   MOV     R2,     #16
 4028: 1  48E0  C3                      CLR     C
 4029: 1  48E1  12 40 EA                CALL    rFILLBOX
 4030: 1
 4031: 1                                ; ... Score area will be cleared on dynamic draw call
 4032: 1  48E4  22                      RET
 4033: 1                        ; --------------------------------------------------------------------
 4034: 1                        ; @CALBAK       INPUTCALLBACK
 4035: 1                        ; @NOTE         BUTTON.6        L
 4036: 1                        ;       BUTTON.5        D
 4037: 1                        ;       BUTTON.4        U
 4038: 1                        ;       BUTTON.3        R
 4039: 1                        ;       BUTTON.2        ACTA
 4040: 1                        ;       BUTTON.1        ACTB
 4041: 1                        ;       BUTTON.0        HOME
 4042: 1                        ;
 4043: 1                        ; I     R0      KEYDOWN
 4044: 1                        ; I     R1      KEYUP
 4045: 1                        ; I     R2      KEYHOLD
 4046: 1                        ; --------------------------------------------------------------------
 4047: 1  48E5                  cTETINPUT:
 4048: 1        N        02             USING   GAMEBANK/8
 4049: 1                        ; TEMPORARY CODE... INPUT PROCESS
 4050: 1  48E5  88 F0                   MOV     B,      R0
 4051: 1  48E7  90 21 08                MOV     DPTR,   #TT_CB_PVT
 4052: 1  48EA  8A 22                   MOV     BR2,    R2
 4053: 1
 4054: 1  48EC  30 F1 04        ?IPN:   JNB     B.1,    ?IPL
 4055: 1                                ; Immediately drops block.
 4056: 1  48EF  D2 76                   SETB    TT_DROPBLOCK
 4057: 1  48F1  80 15                   SJMP    ?IPD0
 4058: 1
 4059: 1  48F3  30 F6 06        ?IPL:   JNB     B.6,    ?IPR
 4060: 1  48F6  7B 0F                   MOV     R3,     #00001111B
 4061: 1  48F8  12 49 55                CALL    TETINPUT_MVB
 4062: 1  48FB  22                      RET
 4063: 1
 4064: 1  48FC  30 F3 06        ?IPR:   JNB     B.3,    ?IPD
 4065: 1  48FF  7B 01                   MOV     R3,     #00000001B
 4066: 1  4901  12 49 55                CALL    TETINPUT_MVB
 4067: 1  4904  22                      RET
 4068: 1
 4069: 1  4905  30 15 07        ?IPD:   JNB     BR2.5,  ?IPU
 4070: 1  4908  90 21 03        ?IPD0:  MOV     DPTR,   #TT_CNTLEFT
 4071: 1  490B  74 00                   MOV     A,      #0
 4072: 1  490D  F0                      MOVX    @DPTR,  A
 4073: 1  490E  22                      RET
 4074: 1
 4075: 1  490F  30 F2 6C        ?IPU:   JNB     B.2,    TETINPUT_END
 4076: 1                                ; rotates block for clockwise 90 degree
 4077: 1  4912  90 21 08                MOV     DPTR,   #TT_CB_PVT
 4078: 1  4915  E0                      MOVX    A,      @DPTR
 4079: 1  4916  FA                      MOV     R2,     A
 4080: 1  4917  05 82                   INC     DPL
 4081: 1                                ; tries rotation
 4082: 1  4919  12 49 7F                CALL    sROTATER90
 4083: 1  491C  20 D5 20                JB      F0,     ?IPU_VALID
 4084: 1
 4085: 1                                ; tries for some other cases...
 4086: 1  491F  1A                      DEC     R2
 4087: 1  4920  90 21 09                MOV     DPTR,   #TT_CB_PVT+1
 4088: 1  4923  12 49 7F                CALL    sROTATER90
 4089: 1  4926  20 D5 0C                JB      F0,     ?IPU_VALID_OTHER
 4090: 1
 4091: 1  4929  0A                      INC     R2
 4092: 1  492A  0A                      INC     R2
 4093: 1  492B  90 21 09                MOV     DPTR,   #TT_CB_PVT+1
 4094: 1  492E  12 49 7F                CALL    sROTATER90
 4095: 1  4931  20 D5 01                JB      F0,     ?IPU_VALID_OTHER
 4096: 1
 4097: 1  4934  22                      RET
 4098: 1  4935                  ?IPU_VALID_OTHER:
 4099: 1                                LDCDWP2 R0,     TT_CB_PVT
 4100+ 2                                MOVP2           #HIGH(TT_CB_PVT)
 4101+ 3  4935  75 36 21                MOV     GLB_P2CACHE,#HIGH(TT_CB_PVT)
 4102+ 3  4938  75 A0 21                MOV     P2,     #HIGH(TT_CB_PVT)
 4103+ 2  493B  78 08                   MOV     R0,     #LOW(TT_CB_PVT)
 4104: 1  493D  EA                      MOV     A,      R2
 4105: 1  493E  F2                      MOVX    @R0,    A
 4106: 1
 4107: 1  493F                  ?IPU_VALID:     ; if rotation was valid...
 4108: 1                                LDCDWP2         R0,     (TT_CB_PVT+1)
 4109+ 2                                MOVP2           #HIGH((TT_CB_PVT+1))
 4110+ 3  493F  75 36 21                MOV     GLB_P2CACHE,#HIGH((TT_CB_PVT+1))
 4111+ 3  4942  75 A0 21                MOV     P2,     #HIGH((TT_CB_PVT+1))
 4112+ 2  4945  78 09                   MOV     R0,     #LOW((TT_CB_PVT+1))
 4113: 1  4947  7A 03                   MOV     R2,     #3
 4114: 1
 4115: 1  4949                  ?IPU_VALID_0:
 4116: 1  4949  E0                      MOVX    A,      @DPTR
 4117: 1  494A  F2                      MOVX    @R0,    A
 4118: 1  494B  08                      INC     R0
 4119: 1  494C  05 82                   INC     DPL
 4120: 1  494E  DA F9                   DJNZ    R2,     ?IPU_VALID_0
 4121: 1
 4122: 1  4950  D2 79                   SETB    TT_BOARDDIRTY
 4123: 1  4952  C2 77                   CLR     TT_FLGCLR
 4124: 1
 4125: 1  4954  22                      RET
 4126: 1
 4127: 1  4955                  TETINPUT_MVB:
 4128: 1  4955  E0                      MOVX    A,      @DPTR
 4129: 1  4956  C0 E0                   PUSH    ACC
 4130: 1                                ADDBLKRELC      A,      R3
 4131+ 2  4958  C0 E0                   PUSH    ACC
 4132+ 2                                ; Adds upper 4bit first.
 4133+ 2  495A  54 F0                   ANL     A,      #0F0H
 4134+ 2  495C  2B                      ADD     A,      R3
 4135+ 2  495D  54 F0                   ANL     A,      #0F0H
 4136+ 2                                ; Adds lower 4bit
 4137+ 2  495F  F5 F0                   MOV     B,      A
 4138+ 2  4961  D0 E0                   POP     ACC
 4139+ 2  4963  2B                      ADD     A,      R3
 4140+ 2  4964  54 0F                   ANL     A,      #00FH
 4141+ 2                                ; Adds each value other.
 4142+ 2  4966  25 F0                   ADD     A,      B
 4143: 1  4968  D0 13                   POP     AR3 ; Current location cache.
 4144: 1                                ; check boundary.
 4145: 1  496A  FA                      MOV     R2,     A
 4146: 1  496B  05 82                   INC     DPL; For the rest of pivot...
 4147: 1  496D  12 45 3B                CALL    sCHECKBOUND
 4148: 1                                ; if result is valid...
 4149: 1  4970  20 D5 01                JB      F0,     TETINPUT_CMITMV
 4150: 1  4973  22                      RET
 4151: 1  4974                  TETINPUT_CMITMV:
 4152: 1                                ; re-adjust dptr and store value
 4153: 1  4974  90 21 08                MOV     DPTR,   #TT_CB_PVT
 4154: 1  4977  EA                      MOV     A,      R2
 4155: 1  4978  F0                      MOVX    @DPTR,  A
 4156: 1                                ; dirty flag reset.
 4157: 1  4979  D2 79                   SETB    TT_BOARDDIRTY
 4158: 1  497B  C2 77                   CLR     TT_FLGCLR
 4159: 1
 4160: 1  497D  22                      RET
 4161: 1  497E                  TETINPUT_END:
 4162: 1  497E  22                      RET
 4163: 1                        ; --------------------------------------------------------------------
 4164: 1                        ;
 4165: 1                        ; @SPECT        ROTATER90
 4166: 1                        ;
 4167: 1                        ; I     R2      PIVOT LOCATION
 4168: 1                        ; I[3]  DPTR    LINK INFO
 4169: 1                        ; OUT[3]        DPTR    rotated result.
 4170: 1                        ; OUT   F0      Was valid ?
 4171: 1                        ;
 4172: 1                        ; X     R0, B, BR1, R3
 4173: 1                        ;
 4174: 1                        ; --------------------------------------------------------------------
 4175: 1                        MEMALIGN        LOCAL_MEMORY, 8
 4176+ 2        N      2140     LOCAL_MEMORY    SET     ((LOCAL_MEMORY+(8-1))/8)*8
 4177: 1                        LOCMEM  ROTATE_CACHE, 8
 4178+ 2        N      2140     ROTATE_CACHE    SET     LOCAL_MEMORY
 4179+ 2        N      2148     LOCAL_MEMORY SET        LOCAL_MEMORY+8
 4180+ 2        N      0000     IF      LOCAL_MEMORY>=4000H
 4181+ 2                        $ERROR  ("EXTERNAL MEMORY OVERFLOW")
 4182+ 2                        ENDIF
 4183: 1                        ; Rotates given block links to right.
 4184: 1  497F                  sROTATER90:
 4185: 1        N        02             USING   GAMEBANK/8
 4186: 1
 4187: 1                                LDCDWP2 R0,     ROTATE_CACHE
 4188+ 2                                MOVP2           #HIGH(ROTATE_CACHE)
 4189+ 3  497F  75 36 21                MOV     GLB_P2CACHE,#HIGH(ROTATE_CACHE)
 4190+ 3  4982  75 A0 21                MOV     P2,     #HIGH(ROTATE_CACHE)
 4191+ 2  4985  78 40                   MOV     R0,     #LOW(ROTATE_CACHE)
 4192: 1
 4193: 1  4987  75 21 03                MOV     BR1,    #3
 4194: 1  498A                  ROTATE90_0:     ; (x, y) -> (y, -x)
 4195: 1  498A  E0                      MOVX    A,      @DPTR
 4196: 1
 4197: 1  498B  C4                      SWAP    A
 4198: 1  498C  C0 E0                   PUSH    ACC
 4199: 1
 4200: 1  498E  F4                      CPL     A
 4201: 1  498F  04                      INC     A
 4202: 1  4990  54 0F                   ANL     A,      #00FH
 4203: 1  4992  F5 F0                   MOV     B,      A
 4204: 1
 4205: 1  4994  D0 E0                   POP     ACC
 4206: 1  4996  54 F0                   ANL     A,      #0F0H
 4207: 1  4998  25 F0                   ADD     A,      B
 4208: 1
 4209: 1                                ; cache it
 4210: 1  499A  F2                      MOVX    @R0,    A
 4211: 1
 4212: 1  499B  08                      INC     R0
 4213: 1  499C  05 82                   INC     DPL
 4214: 1
 4215: 1  499E  D5 21 E9                DJNZ    BR1,    ROTATE90_0
 4216: 1                        ; ~LP
 4217: 1  49A1  15 82                   DEC     DPL
 4218: 1  49A3  15 82                   DEC     DPL
 4219: 1
 4220: 1  49A5                  ROTATE90_ISVALID:
 4221: 1                        ; Checks if the upcoming location is valid
 4222: 1  49A5  90 21 40                MOV     DPTR,   #ROTATE_CACHE
 4223: 1  49A8  8A 13                   MOV     AR3,    R2
 4224: 1  49AA  12 45 3B                CALL    sCHECKBOUND
 4225: 1
 4226: 1                                ; return value.
 4227: 1  49AD  90 21 40                MOV     DPTR,   #ROTATE_CACHE
 4228: 1  49B0  22                      RET
 4229: 1
 4230: 1                        ; --------------------------------------------------------------------
 4231: 1                        ; @CALBAK       UPDATECALLBACK(VOID)
 4232: 1                        ; --------------------------------------------------------------------
 4233: 1                        ; @CALBAK       DYNAMICDRAWCALLBACK
 4234: 1                        ; I     B       BACKBUFFERHI
 4235: 1                        ; --------------------------------------------------------------------
 4236: 1                        ; @CALBAK       INITIALIZERCALLBACK(VOID)
 4237: 1                        ; --------------------------------------------------------------------
 4238: 1                        ; @CALBAK       STATICDRAWCALLBAK
 4239: 1                        ; I     B       BACKBUFFERHI
 4240: 1                        ; --------------------------------------------------------------------
 4241: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 4242:                          $INCLUDE        (SSN_JIRUNG.INC)
 4243: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 4244: 1                        ; DEFINE_MODULE SSN_TMPLT??? ; This isn't required on session definition
 4245: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 4246: 1                        LOCMEM_PVT
 4247+ 2        N      2000     LOCAL_MEMORY SET        2000H
 4248: 1                        LBIT_PVT
 4249+ 2  49B1                  ??0024:
 4250+ 2        N      0000     IF      ??0024 < 4000H
 4251+ 2                        $ERROR  ("LBIT should be placed after code segment.")
 4252+ 2                        ENDIF
 4253+ 2        N      007B     __LB_PIVOT      SET     __INTB_OFST
 4254: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 4255: 1                        ;
 4256: 1                        ;       SSN_JIRUNG
 4257: 1                        ;
 4258: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 4259: 1                        ;       DESCRIPTION
 4260: 1                        ; The jirungi game.
 4261: 1                        ; Uses 16*16 size of screen to describe jirungi game session.
 4262: 1                        ; 1 byte of memory allocated for represent current PIVOT location,
 4263: 1                        ;and the 16*16 size board itself represents current game state.
 4264: 1                        ; 1 byte of memory allocated to store current direction, u d r l
 4265: 1                        ; The worm dies when the pivot located on biting its body.
 4266: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 4267: 1                        ; ######### SUBROUTINES & MACROS #####################################
 4268: 1                        ; --------------------------------------------------------------------
 4269: 1                        ; @NOTE LOADCDW HI, LO, CONST
 4270: 1                        ; @NOTE MOVP2   VAL
 4271: 1                        ; --------------------------------------------------------------------
 4272: 1                        ;
 4273: 1                        ;       LOCAL MEMORY ALLOCATIONS
 4274: 1                        ;
 4275: 1                        ; TYPE     |IDENTIFIER |SIZE/DESCRIPTION
 4276: 1                        ; ---------|-----------|----------------------------------------------
 4277: 1                        MEMALIGN        LOCAL_MEMORY, 100H
 4278+ 2        N      2000     LOCAL_MEMORY    SET     ((LOCAL_MEMORY+(100H-1))/100H)*100H
 4279: 1                        LOCMEM  JR_BOARD,100H; .Main game board of jirungi game.
 4280+ 2        N      2000     JR_BOARD        SET     LOCAL_MEMORY
 4281+ 2        N      2100     LOCAL_MEMORY SET        LOCAL_MEMORY+100H
 4282+ 2        N      0000     IF      LOCAL_MEMORY>=4000H
 4283+ 2                        $ERROR  ("EXTERNAL MEMORY OVERFLOW")
 4284+ 2                        ENDIF
 4285: 1                        LOCMEM  JR_PVT, 1       ; .The pivot location of jirungi. Should be aligned as Y X order.
 4286+ 2        N      2100     JR_PVT  SET     LOCAL_MEMORY
 4287+ 2        N      2101     LOCAL_MEMORY SET        LOCAL_MEMORY+1
 4288+ 2        N      0000     IF      LOCAL_MEMORY>=4000H
 4289+ 2                        $ERROR  ("EXTERNAL MEMORY OVERFLOW")
 4290+ 2                        ENDIF
 4291: 1                        LOCMEM  JR_DIR, 1       ; .Direction of jirungi's pivot. Should be aligned as Y X order.
 4292+ 2        N      2101     JR_DIR  SET     LOCAL_MEMORY
 4293+ 2        N      2102     LOCAL_MEMORY SET        LOCAL_MEMORY+1
 4294+ 2        N      0000     IF      LOCAL_MEMORY>=4000H
 4295+ 2                        $ERROR  ("EXTERNAL MEMORY OVERFLOW")
 4296+ 2                        ENDIF
 4297: 1                        LOCMEM  JR_LVL, 1       ; .Number of layers of jirungi.
 4298+ 2        N      2102     JR_LVL  SET     LOCAL_MEMORY
 4299+ 2        N      2103     LOCAL_MEMORY SET        LOCAL_MEMORY+1
 4300+ 2        N      0000     IF      LOCAL_MEMORY>=4000H
 4301+ 2                        $ERROR  ("EXTERNAL MEMORY OVERFLOW")
 4302+ 2                        ENDIF
 4303: 1                        LOCMEM  JR_FOOD, 1      ; .Current food location.
 4304+ 2        N      2103     JR_FOOD SET     LOCAL_MEMORY
 4305+ 2        N      2104     LOCAL_MEMORY SET        LOCAL_MEMORY+1
 4306+ 2        N      0000     IF      LOCAL_MEMORY>=4000H
 4307+ 2                        $ERROR  ("EXTERNAL MEMORY OVERFLOW")
 4308+ 2                        ENDIF
 4309: 1                        LOCMEM  JR_TICKS, 1     ; .Tick count to next frame.
 4310+ 2        N      2104     JR_TICKS        SET     LOCAL_MEMORY
 4311+ 2        N      2105     LOCAL_MEMORY SET        LOCAL_MEMORY+1
 4312+ 2        N      0000     IF      LOCAL_MEMORY>=4000H
 4313+ 2                        $ERROR  ("EXTERNAL MEMORY OVERFLOW")
 4314+ 2                        ENDIF
 4315: 1                        ; --------------------------------------------------------------------
 4316: 1                        ;
 4317: 1                        ; @PROC SESSION_INIT
 4318: 1                        ; @note It is recommended to define a general purpose session initializer
 4319: 1                        ;        to easy access to different session.
 4320: 1                        ;       This procedure should contain the code segment calling TRANSITION
 4321: 1                        ;        procedure, which requires following CALLBACK arguments:
 4322: 1                        ;
 4323: 1                        ;       I X     DPH:DPL INPUT
 4324: 1                        ;       I X     R1:R0   UPDATE
 4325: 1                        ;       I X     R3:R2   DYNAMIC DRAW CALL
 4326: 1                        ;       I X     R5:R4   SESSION INITIALIZER
 4327: 1                        ;       I X     R7:R6   STATIC DRAW CALL
 4328: 1                        ;
 4329: 1                        ; --------------------------------------------------------------------
 4330: 1  49B1                  rSESSION_JIRUNG:
 4331: 1                                ; Clear memory
 4332: 1  49B1  90 20 00                MOV     DPTR,   #2000H
 4333: 1                                LDCDW   R1,R0,  2000H
 4334+ 2  49B4  79 20                   MOV     R1,     #HIGH(2000H)
 4335+ 2  49B6  78 00                   MOV     R0,     #LOW(2000H)
 4336: 1  49B8  75 F0 00                MOV     B,      #0
 4337: 1  49BB  12 40 2E                CALL    rMEMSET
 4338: 1                                ; Assign input procedure
 4339: 1  49BE  90 4A F2                MOV     DPTR,   #cJRINPUT
 4340: 1                                ; Assign update procedure
 4341: 1                                LDCDW   R1,R0,  cJRUPDATE
 4342+ 2  49C1  79 49                   MOV     R1,     #HIGH(cJRUPDATE)
 4343+ 2  49C3  78 D6                   MOV     R0,     #LOW(cJRUPDATE)
 4344: 1                                ; Assign draw call procedure
 4345: 1                                LDCDW   R3,R2,  cJRDRAW
 4346+ 2  49C5  7B 4A                   MOV     R3,     #HIGH(cJRDRAW)
 4347+ 2  49C7  7A 8C                   MOV     R2,     #LOW(cJRDRAW)
 4348: 1                                ; Assign session initializer
 4349: 1                                LDCDW   R5,R4,  cJRINIT
 4350+ 2  49C9  7D 4A                   MOV     R5,     #HIGH(cJRINIT)
 4351+ 2  49CB  7C 6D                   MOV     R4,     #LOW(cJRINIT)
 4352: 1                                ; Assign static draw call
 4353: 1                                LDCDW   R7,R6,  NULLF
 4354+ 2  49CD  7F 4B                   MOV     R7,     #HIGH(NULLF)
 4355+ 2  49CF  7E 16                   MOV     R6,     #LOW(NULLF)
 4356: 1                                ; Clear if the timer should not be reset.
 4357: 1  49D1  D3                      SETB    C
 4358: 1                                ; Calls the transition function.
 4359: 1                                ; It is recommended to place this line last.
 4360: 1  49D2  12 4B 44                CALL    rTRANSITION
 4361: 1  49D5  22                      RET
 4362: 1                        ; --------------------------------------------------------------------
 4363: 1                        ; @CALBAK       JRUPDATE
 4364: 1                        ; --------------------------------------------------------------------
 4365: 1  49D6                  cJRUPDATE:
 4366: 1        N        02             USING   GAMEBANK/8
 4367: 1                        ; <algorithm overview>
 4368: 1                        ; [] moves head as its direction
 4369: 1                        ; <> if there's worm's body on new pivot location...
 4370: 1                        ;       [] game overs, call ranking.
 4371: 1                        ; <> if there's <<<NO>>> food on the new pivot location ...
 4372: 1                        ;       [] iterate all the board elements to decrease them by 1 for each, only when it is larger tha
       1                        n 0.
 4373: 1                        ;       ==> this means, there's no decreasing if there's any food.
 4374: 1                        ; ><> else ... // if there's any food...
 4375: 1                        ;       [] increase current level count by 1
 4376: 1                        ;       [] places a food on random point.
 4377: 1                        ; [] fills the point which is current pivot location as current level.
 4378: 1                        ; ~done.
 4379: 1                                ; All the action begins only when the ticks equals zero.
 4380: 1  49D6  90 21 04                MOV     DPTR,   #JR_TICKS
 4381: 1  49D9  E0                      MOVX    A,      @DPTR
 4382: 1  49DA  60 03                   JZ      JRUPDATE_BEGIN
 4383: 1                                ; [] Decreases tick count, and escapes.
 4384: 1  49DC  14                      DEC     A
 4385: 1  49DD  F0                      MOVX    @DPTR,  A
 4386: 1  49DE  22                      RET
 4387: 1  49DF                  JRUPDATE_BEGIN:
 4388: 1                                ; Resets ticks left
 4389: 1  49DF  74 03                   MOV     A,      #3
 4390: 1  49E1  F0                      MOVX    @DPTR,  A
 4391: 1
 4392: 1                                ; [] MOVE HEAD LOC
 4393: 1                                ; get direction
 4394: 1  49E2  90 21 01                MOV     DPTR,   #JR_DIR
 4395: 1  49E5  E0                      MOVX    A,      @DPTR
 4396: 1  49E6  C0 E0                   PUSH    ACC
 4397: 1
 4398: 1                                ; get cur pivot.
 4399: 1  49E8  90 21 00                MOV     DPTR,   #JR_PVT
 4400: 1  49EB  E0                      MOVX    A,      @DPTR
 4401: 1
 4402: 1                                ; add them each.
 4403: 1  49EC  D0 12                   POP     AR2
 4404: 1  49EE  12 40 56                CALL    rADDBLKSEP
 4405: 1  49F1  F0                      MOVX    @DPTR,  A
 4406: 1
 4407: 1        R        R3     NEWPIVOT        SET     R3
 4408: 1  49F2  FB                      MOV     NEWPIVOT,       A
 4409: 1
 4410: 1                                ; <> check if there's worm body.
 4411: 1                                ; The dpl will directly be the coordinate.
 4412: 1  49F3  75 83 20                MOV     DPH,    #HIGH(JR_BOARD)
 4413: 1  49F6  8B 82                   MOV     DPL,    NEWPIVOT
 4414: 1
 4415: 1                                ; If it's not zero, that means there's worm body.
 4416: 1  49F8  E0                      MOVX    A,      @DPTR
 4417: 1  49F9  60 15                   JZ      JRUPDATE_NOOVER
 4418: 1                                ; [] game over sequence.
 4419: 1  49FB  90 12 0A                MOV     DPTR,   #RANKING_RETURN
 4420: 1  49FE  74 B1                   MOV     A,      #LOW(rSESSION_JIRUNG)
 4421: 1  4A00  F0                      MOVX    @DPTR,  A
 4422: 1
 4423: 1  4A01  05 82                   INC     DPL
 4424: 1  4A03  74 49                   MOV     A,      #HIGH(rSESSION_JIRUNG)
 4425: 1  4A05  F0                      MOVX    @DPTR,  A
 4426: 1
 4427: 1  4A06  90 12 20                MOV     DPTR,   #RANKING_GAMEINFO
 4428: 1  4A09  74 01                   MOV     A,      #1
 4429: 1  4A0B  F0                      MOVX    @DPTR,  A
 4430: 1
 4431: 1  4A0C  12 42 DB                CALL    rTORANKING
 4432: 1  4A0F  22                      RET
 4433: 1  4A10                  JRUPDATE_NOOVER:
 4434: 1                                ; <> if there's no food on new pivot loc...
 4435: 1                                ; gets food location.
 4436: 1  4A10  90 21 03                MOV     DPTR,   #JR_FOOD
 4437: 1  4A13  E0                      MOVX    A,      @DPTR
 4438: 1  4A14  8B F0                   MOV     B,      NEWPIVOT
 4439: 1                                ; compare with ..
 4440: 1  4A16  B5 F0 38                CJNE    A,      B,      JRUPDATE_NOFOOD
 4441: 1
 4442: 1                        ; ==> there's food.
 4443: 1                                ; [] increases current level by 1. Increases score.
 4444: 1  4A19  90 21 02                MOV     DPTR,   #JR_LVL
 4445: 1  4A1C  E0                      MOVX    A,      @DPTR
 4446: 1  4A1D  04                      INC     A
 4447: 1  4A1E  F0                      MOVX    @DPTR,  A
 4448: 1                                ; [] places food on random point.
 4449: 1  4A1F  75 83 20                MOV     DPH,    #HIGH(JR_BOARD)
 4450: 1                                ; random pivot
 4451: 1  4A22  E5 8B                   MOV     A,      RANDNUM
 4452: 1  4A24  F5 82                   MOV     DPL,    A
 4453: 1                                ; determine direction to proceed.
 4454: 1  4A26  A2 E0                   MOV     C,      ACC.0
 4455: 1  4A28  92 D5                   MOV     F0,     C
 4456: 1
 4457: 1  4A2A                  JRUPDATE_FINDPUTFOOD:
 4458: 1                        ; <> if specified board element location indicates 0, put food there.
 4459: 1                                ; :: else, iterate until find valid place.
 4460: 1  4A2A  E0                      MOVX    A,      @DPTR
 4461: 1  4A2B  60 0B                   JZ      JRUPDATE_FOUND
 4462: 1                                ; move up or down
 4463: 1  4A2D  20 D5 04                JB      F0,     JRUPDATE_INC
 4464: 1  4A30  15 82                   DEC     DPL
 4465: 1  4A32  80 F6                   SJMP    JRUPDATE_FINDPUTFOOD
 4466: 1  4A34                  JRUPDATE_INC:
 4467: 1  4A34  05 82                   INC     DPL
 4468: 1  4A36  80 F2                   SJMP    JRUPDATE_FINDPUTFOOD
 4469: 1  4A38                  JRUPDATE_FOUND:
 4470: 1
 4471: 1                                ; Now, dpl points an empty place.
 4472: 1                                ; locates new food.
 4473: 1  4A38  E5 82                   MOV     A,      DPL
 4474: 1  4A3A  90 21 03                MOV     DPTR,   #(JR_FOOD)
 4475: 1  4A3D  F0                      MOVX    @DPTR,  A
 4476: 1
 4477: 1                                ; [] increases score.
 4478: 1  4A3E  90 21 02                MOV     DPTR,   #JR_LVL
 4479: 1  4A41  E0                      MOVX    A,      @DPTR
 4480: 1                                ; adds score repeatedly, 50 per 10 level.
 4481: 1  4A42                  JRUPDATE_SCORELP:
 4482: 1  4A42  FA                      MOV     R2,     A
 4483: 1                                ; adds score.
 4484: 1  4A43  75 F0 32                MOV     B,      #50
 4485: 1  4A46  12 43 BA                CALL    rADDSCORE
 4486: 1                                ; check for iteration condition
 4487: 1  4A49  EA                      MOV     A,      R2
 4488: 1  4A4A  C3                      CLR     C
 4489: 1  4A4B  94 0A                   SUBB    A,      #10
 4490: 1  4A4D  50 F3                   JNC     JRUPDATE_SCORELP
 4491: 1
 4492: 1                                ; done.
 4493: 1  4A4F  80 0B                   SJMP    JRUPDATE_FILLCURRENT
 4494: 1  4A51                  JRUPDATE_NOFOOD:
 4495: 1                        ; ==> there's no food.
 4496: 1                                ; [] iterates every element of board, and if it's not zero, decreases each cells.
 4497: 1  4A51  90 20 00                MOV     DPTR,   #JR_BOARD
 4498: 1  4A54                  JRUPDATE_LIFESPAN:
 4499: 1  4A54  E0                      MOVX    A,      @DPTR
 4500: 1                                ; <> if lifespan left in this cell is larger than 0 ...
 4501: 1  4A55  60 02                   JZ      JRUPDATE_SKIP
 4502: 1                                ; [] decreases it by 1.
 4503: 1  4A57  14                      DEC     A
 4504: 1  4A58  F0                      MOVX    @DPTR,  A
 4505: 1  4A59                  JRUPDATE_SKIP:
 4506: 1  4A59  D5 82 F8                DJNZ    DPL,    JRUPDATE_LIFESPAN
 4507: 1                        ; ~~JRUPDATE_LIFESPAN
 4508: 1  4A5C                  JRUPDATE_FILLCURRENT:
 4509: 1                                ; [] fills current pivot location by current level.
 4510: 1                                ; current pivot location.
 4511: 1  4A5C  90 21 00                MOV     DPTR,   #JR_PVT
 4512: 1  4A5F  E0                      MOVX    A,      @DPTR
 4513: 1  4A60  C0 E0                   PUSH    ACC
 4514: 1
 4515: 1                                ; current level.
 4516: 1  4A62  90 21 02                MOV     DPTR,   #JR_LVL
 4517: 1  4A65  E0                      MOVX    A,      @DPTR
 4518: 1
 4519: 1                                ; Sets it by ...
 4520: 1  4A66  D0 82                   POP     DPL
 4521: 1  4A68  75 83 20                MOV     DPH,    #HIGH(JR_BOARD)
 4522: 1
 4523: 1  4A6B  F0                      MOVX    @DPTR,  A
 4524: 1
 4525: 1  4A6C  22                      RET
 4526: 1                        ; --------------------------------------------------------------------
 4527: 1                        ; @CALBAK       JRINIT
 4528: 1                        ; --------------------------------------------------------------------
 4529: 1                        ; Initializes jirungi game.
 4530: 1  4A6D                  cJRINIT:
 4531: 1                                ; Resets current level as 1.
 4532: 1  4A6D  90 21 02                MOV     DPTR,   #JR_LVL
 4533: 1  4A70  74 01                   MOV     A,      #1
 4534: 1  4A72  F0                      MOVX    @DPTR,  A
 4535: 1
 4536: 1                                ; Resets pivot
 4537: 1  4A73  90 21 00                MOV     DPTR,   #JR_PVT
 4538: 1  4A76  74 77                   MOV     A,      #01110111B; 7, 7.
 4539: 1  4A78  F0                      MOVX    @DPTR,  A
 4540: 1
 4541: 1                                ; Locates the first food. It'll be fixed location, 9'9.
 4542: 1  4A79  90 21 03                MOV     DPTR,   #JR_FOOD
 4543: 1  4A7C  74 99                   MOV     A,      #10011001B
 4544: 1  4A7E  F0                      MOVX    @DPTR,  A
 4545: 1
 4546: 1                                ; Adjust heading direction. Default is 0. game begins when
 4547: 1                                ;the player starts to move.
 4548: 1  4A7F  90 21 01                MOV     DPTR,   #JR_DIR
 4549: 1  4A82  74 10                   MOV     A,      #00010000B
 4550: 1  4A84  F0                      MOVX    @DPTR,  A
 4551: 1
 4552: 1                                ; Set initial tick timer.
 4553: 1  4A85  90 21 04                MOV     DPTR,   #JR_TICKS
 4554: 1  4A88  74 00                   MOV     A,      #0
 4555: 1  4A8A  F0                      MOVX    @DPTR,  A
 4556: 1
 4557: 1  4A8B  22                      RET
 4558: 1                        ; --------------------------------------------------------------------
 4559: 1                        ; @CALBAK       JRDRAW
 4560: 1                        ; --------------------------------------------------------------------
 4561: 1                        ; Draws jirungi game board every tick.
 4562: 1  4A8C                  cJRDRAW:
 4563: 1                                ; clears screen
 4564: 1  4A8C  74 00                   MOV     A,      #0
 4565: 1  4A8E  12 40 73                CALL    rFILLBUFFER
 4566: 1
 4567: 1                                ; draws border
 4568: 1                                ; border will be like this ..
 4569: 1                                ; +----+      +----+
 4570: 1                                ; |    | GAME |    |
 4571: 1                                ; +----+      +----+
 4572: 1                                ; The first border.
 4573: 1  4A91  75 82 00                MOV     DPL,    #0
 4574: 1  4A94  75 F0 01                MOV     B,      #001B
 4575: 1  4A97  79 08                   MOV     R1,     #8
 4576: 1  4A99  7A 10                   MOV     R2,     #16
 4577: 1  4A9B  C3                      CLR     C
 4578: 1  4A9C  12 40 8F                CALL    rDRAWBOX
 4579: 1
 4580: 1                                ; The second border.
 4581: 1  4A9F  75 82 18                MOV     DPL,    #24 ; Y = 0, X = 24
 4582: 1  4AA2  75 F0 01                MOV     B,      #001B
 4583: 1  4AA5  79 08                   MOV     R1,     #8
 4584: 1  4AA7  7A 10                   MOV     R2,     #16
 4585: 1  4AA9  C3                      CLR     C
 4586: 1  4AAA  12 40 8F                CALL    rDRAWBOX
 4587: 1
 4588: 1                                ; iterate all the board element, and draws color if it's not 0.
 4589: 1                                ; Radix point = Y0 X8
 4590: 1                                LDCDWP2 R1,     JR_BOARD
 4591+ 2                                MOVP2           #HIGH(JR_BOARD)
 4592+ 3  4AAD  75 36 20                MOV     GLB_P2CACHE,#HIGH(JR_BOARD)
 4593+ 3  4AB0  75 A0 20                MOV     P2,     #HIGH(JR_BOARD)
 4594+ 2  4AB3  79 00                   MOV     R1,     #LOW(JR_BOARD)
 4595: 1                                ; draws activated food.
 4596: 1  4AB5                  JRDRAW_BOARD_0:
 4597: 1                                ; <> if the board element is not zero, fill white color.
 4598: 1  4AB5  E3                      MOVX    A,      @R1
 4599: 1  4AB6  60 0E                   JZ      JRDRAW_BOARD_1
 4600: 1                                ; [] draw dot.
 4601: 1                                ; transpose location from board to disp.
 4602: 1  4AB8  E9                      MOV     A,      R1
 4603: 1  4AB9  12 4A DF                CALL    JRDRAW_BLKTODISP
 4604: 1                                ; call drawdot
 4605: 1  4ABC  F5 82                   MOV     DPL,    A
 4606: 1  4ABE  75 F0 07                MOV     B,      #111B
 4607: 1  4AC1  A2 D5                   MOV     C,      F0
 4608: 1  4AC3  12 42 56                CALL    rDRAWDOT
 4609: 1
 4610: 1  4AC6                  JRDRAW_BOARD_1: ; NODRAW
 4611: 1
 4612: 1  4AC6  D9 ED                   DJNZ    R1,     JRDRAW_BOARD_0
 4613: 1                        ; ~~JRDRAW_BOARD_0
 4614: 1
 4615: 1                                ; [] Draws food location
 4616: 1                                ; adjusts location
 4617: 1                                LDCDWP2 R1,     JR_FOOD
 4618+ 2                                MOVP2           #HIGH(JR_FOOD)
 4619+ 3  4AC8  75 36 21                MOV     GLB_P2CACHE,#HIGH(JR_FOOD)
 4620+ 3  4ACB  75 A0 21                MOV     P2,     #HIGH(JR_FOOD)
 4621+ 2  4ACE  79 03                   MOV     R1,     #LOW(JR_FOOD)
 4622: 1  4AD0  E3                      MOVX    A,      @R1
 4623: 1  4AD1  12 4A DF                CALL    JRDRAW_BLKTODISP
 4624: 1
 4625: 1                                ; draws dot
 4626: 1  4AD4  F5 82                   MOV     DPL,    A
 4627: 1  4AD6  75 F0 06                MOV     B,      #110B; will be yellow.
 4628: 1  4AD9  A2 D5                   MOV     C,      F0
 4629: 1  4ADB  12 42 56                CALL    rDRAWDOT
 4630: 1
 4631: 1  4ADE  22                      RET
 4632: 1
 4633: 1                        ; Transform 16 by 16 location to (F0)1 + 3 by 8 location
 4634: 1                        ; I     A       INPUT LOCATION
 4635: 1                        ; OUT   F0      SCREEN SELECTION
 4636: 1                        ; OUT   A       OUTPUT LOCATION (3, 5)
 4637: 1                        ; X     B
 4638: 1  4ADF                  JRDRAW_BLKTODISP:
 4639: 1  4ADF  C0 E0                   PUSH    ACC
 4640: 1                                ; Upper 4bit to F0 + 3bit ofst
 4641: 1  4AE1  54 F0                   ANL     A,      #0F0H
 4642: 1  4AE3  33                      RLC     A
 4643: 1  4AE4  92 D5                   MOV     F0,     C
 4644: 1                                ; Lower 4bit and add 7 to shift right.
 4645: 1  4AE6  54 E0                   ANL     A,      #11100000B
 4646: 1  4AE8  D0 F0                   POP     B
 4647: 1                                ; Masks B, its lower value.
 4648: 1  4AEA  53 F0 0F                ANL     B,      #0FH
 4649: 1  4AED  25 F0                   ADD     A,      B
 4650: 1  4AEF  24 08                   ADD     A,      #8
 4651: 1  4AF1  22                      RET
 4652: 1                        ; --------------------------------------------------------------------
 4653: 1                        ; @CALBAK       INPUTCALLBACK
 4654: 1                        ; @NOTE         BUTTON.6        L
 4655: 1                        ;       BUTTON.5        D
 4656: 1                        ;       BUTTON.4        U
 4657: 1                        ;       BUTTON.3        R
 4658: 1                        ;       BUTTON.2        ACTA
 4659: 1                        ;       BUTTON.1        ACTB
 4660: 1                        ;       BUTTON.0        HOME
 4661: 1                        ;
 4662: 1                        ; I     R0      KEYDOWN
 4663: 1                        ; I     R1      KEYUP
 4664: 1                        ; I     R2      KEYHOLD
 4665: 1                        ; --------------------------------------------------------------------
 4666: 1  4AF2                  cJRINPUT:
 4667: 1        N        02             USING   GAMEBANK/8
 4668: 1
 4669: 1  4AF2  88 20                   MOV     BR0,    R0
 4670: 1  4AF4  90 21 01                MOV     DPTR,   #JR_DIR
 4671: 1  4AF7  E0                      MOVX    A,      @DPTR
 4672: 1
 4673: 1  4AF8  30 04 04        JRINPUT_U:      JNB     BR0.4,  JRINPUT_D
 4674: 1  4AFB  74 F0                   MOV     A,      #11110000B
 4675: 1  4AFD  80 15                   SJMP    JRINPUT_X
 4676: 1
 4677: 1  4AFF  30 05 04        JRINPUT_D:      JNB     BR0.5,  JRINPUT_L
 4678: 1  4B02  74 10                   MOV     A,      #00010000B
 4679: 1  4B04  80 0E                   SJMP    JRINPUT_X
 4680: 1
 4681: 1  4B06  30 06 04        JRINPUT_L:      JNB     BR0.6,  JRINPUT_R
 4682: 1  4B09  74 0F                   MOV     A,      #00001111B
 4683: 1  4B0B  80 07                   SJMP    JRINPUT_X
 4684: 1
 4685: 1  4B0D  30 03 04        JRINPUT_R:      JNB     BR0.3,  JRINPUT_X
 4686: 1  4B10  74 01                   MOV     A,      #00000001B
 4687: 1  4B12  80 00                   SJMP    JRINPUT_X
 4688: 1
 4689: 1  4B14  F0              JRINPUT_X:      MOVX    @DPTR,  A
 4690: 1  4B15  22                      RET
 4691: 1                        ; --------------------------------------------------------------------
 4692: 1                        ; --------------------------------------------------------------------
 4693: 1                        ; @CALBAK       UPDATECALLBACK(VOID)
 4694: 1                        ; --------------------------------------------------------------------
 4695: 1                        ; @CALBAK       DYNAMICDRAWCALLBACK
 4696: 1                        ; I     B       BACKBUFFERHI
 4697: 1                        ; --------------------------------------------------------------------
 4698: 1                        ; @CALBAK       INITIALIZERCALLBACK(VOID)
 4699: 1                        ; --------------------------------------------------------------------
 4700: 1                        ; @CALBAK       STATICDRAWCALLBAK
 4701: 1                        ; I     B       BACKBUFFERHI
 4702: 1                        ; --------------------------------------------------------------------
 4703: 1                        ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 4704:                          ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 4705:                          ; > > > > > > > > > > > > > > > >  > > > > > > > > > > > > > > > > > >
 4706:                          ; > > > > > > > > > > CODE SEGMENT > > > > > > > > > > > > > > > > > >
 4707:                          ; > > > > > > > > > >  > > > > > > > > > > > > > > > > > > > > > > > >
 4708:                          ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 4709:                          ; --------------------------------------------------------------------
 4710:                          ;
 4711:                          ; ¬ß LIST OF PREFIXES:: PROC, SPEC[0-9a-zA-Z_]*, CALBAK
 4712:                          ;
 4713:                          ;       Prefix PROC indicates a general callable procedure which
 4714:                          ;        indicates an interface function.
 4715:                          ;
 4716:                          ;       Prefix SPEC[..] indicates a special purpose function which
 4717:                          ;        should be called only in specific sequence.
 4718:                          ;        All of the rules about prefix words and procedure concepts
 4719:                          ;        should be concretely defined.
 4720:                          ;
 4721:                          ;       Prefix CALBAK indicates a procedure is callback which fits
 4722:                          ;        in specific calling protocol.
 4723:                          ;
 4724:                          ; --------------------------------------------------------------------
 4725:                          ;
 4726:                          ; @PROC NULLFUNC(void)
 4727:                          ;
 4728:                          ; --------------------------------------------------------------------
 4729:                          ; A nullfunc can be assigned any void return type callbacks.
 4730:                          ; This null function exists to not define any functionality on
 4731:                          ;  specific callback argument.D
 4732:    4B16  22              NULLF:  RET ; do nothing ...
 4733:                          ; --------------------------------------------------------------------
 4734:                          ;
 4735:                          ; @PROC SET_TIMER
 4736:                          ; @note TimerCallback(void)
 4737:                          ;
 4738:                          ; I 2   BR1:BR0 Frames to wait.
 4739:                          ; I     R1:R0   Callback address
 4740:                          ;
 4741:                          ; X     DPTR, ACC
 4742:                          ;
 4743:                          ; --------------------------------------------------------------------
 4744:                          ; Assign a timer callback. This will iterate each timer until find empty one.
 4745:                          ; 4 Timers are enabled.
 4746:    4B17                  rSET_TIMER:
 4747:    4B17  90 12 00                MOV     DPTR,   #TCNT
 4748:
 4749:    4B1A  EA                      MOV     A,      R2
 4750:    4B1B  C0 E0                   PUSH    ACC
 4751:
 4752:                                  ; >>> >>>
 4753:    4B1D  7A 04                   MOV     R2,     #4
 4754:    4B1F                  SET_TIMER_BEGIN:
 4755:                          ; Iterate each timer count register until find one which is in idle state.
 4756:    4B1F  E0                      MOVX    A,      @DPTR
 4757:    4B20  05 82                   INC     DPL
 4758:                                  ; Zero count indicates it is not initialized yet.
 4759:    4B22  70 02                   JNZ     SET_TIMER_NEXT
 4760:                                  ; The TCNT data is ensured to be aligned in 20 byte boundary,
 4761:                                  ;  therefore it is safe to increase only DPL.
 4762:    4B24  60 06                   JZ      SET_TIMER_FOUND
 4763:    4B26                  SET_TIMER_NEXT:
 4764:                          ; Moves HEAD location to next address.
 4765:    4B26  05 82                   INC     DPL
 4766:    4B28  DA F5                   DJNZ    R2,     SET_TIMER_BEGIN
 4767:    4B2A  80 14                   SJMP    SET_TIMER_DONE
 4768:    4B2C                  SET_TIMER_FOUND:
 4769:                          ; If found, sets timer trigger time and callback.
 4770:                          ; At this point, DPL is pointing 1 higher point than pivot.
 4771:    4B2C  E5 21                   MOV     A,      BR1
 4772:    4B2E  F0                      MOVX    @DPTR,  A
 4773:    4B2F  15 82                   DEC     DPL
 4774:    4B31  E5 20                   MOV     A,      BR0
 4775:    4B33  F0                      MOVX    @DPTR,  A
 4776:                                  ; Can find callback external memory location by adding 8 to address.
 4777:    4B34  74 08                   MOV     A,      #8
 4778:    4B36  25 82                   ADD     A,      DPL
 4779:    4B38  F5 82                   MOV     DPL,    A
 4780:                                  ; Assigning callbacks
 4781:    4B3A  E8                      MOV     A,      R0
 4782:    4B3B  F0                      MOVX    @DPTR,  A
 4783:    4B3C  05 82                   INC     DPL
 4784:    4B3E  E9                      MOV     A,      R1
 4785:    4B3F  F0                      MOVX    @DPTR,  A
 4786:                                  ; Done.
 4787:                                  ; <<< <<<
 4788:    4B40                  SET_TIMER_DONE:
 4789:    4B40  D0 E0                   POP     ACC
 4790:    4B42  FA                      MOV     R2,     A
 4791:    4B43  22                      RET
 4792:                          ; --------------------------------------------------------------------
 4793:                          ;
 4794:                          ; @PROC TRANSITION
 4795:                          ;
 4796:                          ; IX B  CY      Set 1 if all gameplay timers are should be reset
 4797:                          ; IX 2  DPH:DPL Input procedure callback to assign at next session
 4798:                                          ; @CALBAK       InputProcCallback
 4799:                                          ;       I R0    KeysDown
 4800:                                          ;       I R1    KeysUp
 4801:                                          ;       I R2    KeysHolding
 4802:                          ; IX 2  R1:R0   Update procedure callback to assign at next session
 4803:                                          ; @CALBAK       UpdateCallback(void)
 4804:                          ; IX 2  R3:R2   Callback which handles all dynamic draw call.
 4805:                                          ; @CALBAK       DynamicDrawCallback
 4806:                          ; IX 2  R5:R4   Initializer callback
 4807:                                          ; @CALBAK       SessionInitCallback
 4808:                          ; IX 2  R7:R6   Static object draw callback
 4809:                                          ; @CALBAK       StaticDrawCallback
 4810:                          ;
 4811:                          ; --------------------------------------------------------------------
 4812:                          ; Transition between sessions...
 4813:    4B44                  rTRANSITION:
 4814:                                  ; Stop rendering while transition
 4815:    4B44  C2 8C                   CLR     TR0
 4816:                                  ; Decide whether game timer should be reinitialized
 4817:    4B46  50 1A                   JNC     TRANSITION_ASSIGNMENT
 4818:
 4819:    4B48  C0 F0                   PUSH    B
 4820:    4B4A  C0 83                   PUSH    DPH
 4821:    4B4C  C0 82                   PUSH    DPL
 4822:
 4823:                                  ; [] Resets timer
 4824:    4B4E  90 12 00                MOV     DPTR,   #TCNT
 4825:    4B51  75 F0 08                MOV     B,      #8
 4826:
 4827:                                  ; timer count zero indicates it is deactivated now.
 4828:    4B54                  TRANSITION_0:
 4829:    4B54  74 00                   MOV     A,      #0
 4830:    4B56  F0                      MOVX    @DPTR,  A
 4831:    4B57  05 82                   INC     DPL
 4832:    4B59  D5 F0 F8                DJNZ    B,      TRANSITION_0
 4833:
 4834:    4B5C  D0 82                   POP     DPL
 4835:    4B5E  D0 83                   POP     DPH
 4836:    4B60  D0 F0                   POP     B
 4837:
 4838:    4B62                  TRANSITION_ASSIGNMENT:
 4839:                                  ; Assign global callbacks
 4840:    4B62  85 82 30                MOV     CS_INPUTPR,             DPL
 4841:    4B65  85 83 31                MOV     CS_INPUTPR+1,   DPH
 4842:    4B68  88 32                   MOV     CS_UPDATE,              R0
 4843:    4B6A  89 33                   MOV     CS_UPDATE+1,    R1
 4844:    4B6C  8A 34                   MOV     CS_DRAW,                R2
 4845:    4B6E  8B 35                   MOV     CS_DRAW+1,              R3
 4846:
 4847:                                  ; Before call initializer function, cache input parameter
 4848:    4B70  C0 E0                   PUSH    ACC
 4849:    4B72  EF                      MOV     A,      R7
 4850:    4B73  C0 E0                   PUSH    ACC
 4851:    4B75  EE                      MOV     A,      R6
 4852:    4B76  C0 E0                   PUSH    ACC
 4853:
 4854:                                  ; Call initializer dynamically
 4855:    4B78  8C 82                   MOV     DPL,    R4
 4856:    4B7A  8D 83                   MOV     DPH,    R5
 4857:                                  DCALL   DPTR
 4858+ 1  4B7C  74 87                   MOV     A,      #LOW(??0025)
 4859+ 1  4B7E  C0 E0                   PUSH    ACC
 4860+ 1  4B80  74 4B                   MOV     A,      #HIGH(??0025)
 4861+ 1  4B82  C0 E0                   PUSH    ACC
 4862+ 1  4B84  74 00                   MOV     A,      #0
 4863+ 1  4B86  73                      JMP     @A+DPTR
 4864+ 1  4B87                  ??0025:
 4865:
 4866:                                  ; Values which were pushed, and are static draw function.
 4867:    4B87  D0 82                   POP     DPL
 4868:    4B89  D0 83                   POP     DPH
 4869:    4B8B  C0 83                   PUSH    DPH
 4870:    4B8D  C0 82                   PUSH    DPL
 4871:                                  DCALL   DPTR
 4872+ 1  4B8F  74 9A                   MOV     A,      #LOW(??0026)
 4873+ 1  4B91  C0 E0                   PUSH    ACC
 4874+ 1  4B93  74 4B                   MOV     A,      #HIGH(??0026)
 4875+ 1  4B95  C0 E0                   PUSH    ACC
 4876+ 1  4B97  74 00                   MOV     A,      #0
 4877+ 1  4B99  73                      JMP     @A+DPTR
 4878+ 1  4B9A                  ??0026:
 4879:
 4880:                                  ; Draw on both side of the buffer.
 4881:    4B9A  B2 7F                   CPL     CURBUFF
 4882:    4B9C  D0 82                   POP     DPL
 4883:    4B9E  D0 83                   POP     DPH
 4884:                                  DCALL   DPTR
 4885+ 1  4BA0  74 AB                   MOV     A,      #LOW(??0027)
 4886+ 1  4BA2  C0 E0                   PUSH    ACC
 4887+ 1  4BA4  74 4B                   MOV     A,      #HIGH(??0027)
 4888+ 1  4BA6  C0 E0                   PUSH    ACC
 4889+ 1  4BA8  74 00                   MOV     A,      #0
 4890+ 1  4BAA  73                      JMP     @A+DPTR
 4891+ 1  4BAB                  ??0027:
 4892:
 4893:                                  ; Resotre acc value.
 4894:    4BAB  D0 E0                   POP     ACC
 4895:
 4896:                                  ; Restart rendering
 4897:    4BAD  D2 8C                   SETB    TR0
 4898:    4BAF  22                      RET
 4899:                          ; --------------------------------------------------------------------
 4900:    4BB0  75 D0 00        TO_MONITOR:     MOV     PSW,    #0
 4901:    4BB3  75 81 5F                MOV     SP,     #5FH
 4902:    4BB6  78 58                   MOV     R0,     #58H
 4903:    4BB8  C2 8C                   CLR     TR0
 4904:
 4905:    4BBA  02 00 57                JMP     0057H
 4906:                          ; --------------------------------------------------------------------
 4907:                          ;
 4908:                          ; ####  MAIN ROUTINE
 4909:                          ;
 4910:                          ; The main loop of this program will initiate overall program
 4911:                          ;  instance.
 4912:                          ; 1. Will initialize game timer
 4913:                          ; 2. Will initialize sound organizer
 4914:                          ; 3. Will initialize graphics processor
 4915:                          ; 4... Will eternally repeat graphics processing
 4916:                          ; --------------------------------------------------------------------
 4917:    4BBD  75 81 38        MAIN:   MOV     SP,     #__INT_OFST
 4918:    4BC0  75 90 FF                MOV     P1,     #0FFH
 4919:    4BC3  75 D0 10                MOV     PSW,    #GAMEBANK
 4920:          N        02             USING   GAMEBANK/8
 4921:
 4922:                                  ; Clear global memory
 4923:    4BC6  90 10 00                MOV     DPTR,   #1000H
 4924:                                  LDCDW   R1,R0,  1000H
 4925+ 1  4BC9  79 10                   MOV     R1,     #HIGH(1000H)
 4926+ 1  4BCB  78 00                   MOV     R0,     #LOW(1000H)
 4927:    4BCD  75 F0 00                MOV     B,      #0
 4928:    4BD0  12 40 2E                CALL    rMEMSET
 4929:
 4930:                                  ; *** INITIALIZE GRAPHICS PROCDURE
 4931:    4BD3  78 08                   MOV     R0,     #GPUBANK
 4932:    4BD5  79 08                   MOV     R1,     #8
 4933:    4BD7                  MAIN_GPINIT:
 4934:    4BD7  76 00                   MOV     @R0,    #0
 4935:    4BD9  08                      INC     R0
 4936:    4BDA  D9 FB                   DJNZ    R1,     MAIN_GPINIT
 4937:
 4938:                                  ; *** CLEANING BUFFERS
 4939:    4BDC  74 00                   MOV     A,      #0
 4940:    4BDE  90 40 73                MOV     DPTR,   #RFILLBUFFER
 4941:                                  DCALL   DPTR
 4942+ 1  4BE1  74 EC                   MOV     A,      #LOW(??0028)
 4943+ 1  4BE3  C0 E0                   PUSH    ACC
 4944+ 1  4BE5  74 4B                   MOV     A,      #HIGH(??0028)
 4945+ 1  4BE7  C0 E0                   PUSH    ACC
 4946+ 1  4BE9  74 00                   MOV     A,      #0
 4947+ 1  4BEB  73                      JMP     @A+DPTR
 4948+ 1  4BEC                  ??0028:
 4949:    4BEC  B2 7F                   CPL     CURBUFF
 4950:    4BEE  90 40 73                MOV     DPTR,   #RFILLBUFFER
 4951:                                  DCALL   DPTR
 4952+ 1  4BF1  74 FC                   MOV     A,      #LOW(??0029)
 4953+ 1  4BF3  C0 E0                   PUSH    ACC
 4954+ 1  4BF5  74 4B                   MOV     A,      #HIGH(??0029)
 4955+ 1  4BF7  C0 E0                   PUSH    ACC
 4956+ 1  4BF9  74 00                   MOV     A,      #0
 4957+ 1  4BFB  73                      JMP     @A+DPTR
 4958+ 1  4BFC                  ??0029:
 4959:
 4960:                                  ; *** INITIALIZING HARDWARE TIMER & GAME TIMER
 4961:                                  ; Initializing timer 0 for core gameplay routine ...
 4962:    4BFC  D2 A9                   SETB    ET0
 4963:    4BFE  D2 8C                   SETB    TR0
 4964:                                  ; Initializes timer 1 to generate random numbers...
 4965:    4C00  D2 8E                   SETB    TR1
 4966:    4C02  75 8D 63                MOV     TH1,    #99
 4967:
 4968:                                  ; Reset all gameplay timers.
 4969:    4C05  90 12 00                MOV     DPTR,   #TCNT
 4970:    4C08  7A 08                   MOV     R2,     #8
 4971:
 4972:                                  ; Initializing timer 1 which takes charge of controlling
 4973:                                  ; sound system.
 4974:                                  ; SETB  ET1
 4975:
 4976:                                  ; Timer 0 will run as mod 1, Timer 1 will run as mod 2.
 4977:    4C0A  75 89 21                MOV     TMOD,   #00100001B
 4978:    4C0D  D2 AF                   SETB    EA
 4979:
 4980:    4C0F  74 00           MAIN_TIMER:     MOV     A,      #0
 4981:    4C11  F0                      MOVX    @DPTR,  A
 4982:    4C12  05 82                   INC     DPL
 4983:    4C14  DA F9                   DJNZ    R2,     MAIN_TIMER
 4984:
 4985:                                  ; *** ENTERING ENTRY SESSION ...
 4986:    4C16  12 43 D3                CALL    rTITLE_SESSION
 4987:
 4988:                                  ; Function test.
 4989:                                  $include        (test\function.inc)
 4990: 1                        ; FUNCTIONALITY TEST
 4991: 1        N      0000     IF      0; SET THIS TO 0 IF RUN
 4992: 1
 4993: 1
 4994: 1                                MOV     DPTR,   #2000H
 4995: 1                                LDCDW   R1,R0,  2000H
 4996: 1                                MOV     B,      #0
 4997: 1                                CALL    RMEMSET
 4998: 1
 4999: 1
 5000: 1                                JMP     TO_MONITOR
 5001: 1
 5002: 1
 5003: 1
 5004: 1
 5005: 1
 5006: 1
 5007: 1                        ENDIF
 5008:
 5009:                                  ; This is main grahpics processing loop.
 5010:                                  ; It will operate without any delay or idling.
 5011:
 5012:                                  ; *** MAIN LOOP
 5013:    4C19                  GP_MAIN:        ; .The role of this processing loop is simple: Runs gameloop.
 5014:    4C19  30 7D FD        GP_WAIT:        JNB     FRAMEBOUND30, GP_WAIT; Wait for 33 ms...
 5015:    4C1C  C2 7D                   CLR     FRAMEBOUND30
 5016:
 5017:    4C1E  12 4C 25                LCALL   rGAMELOOP
 5018:                                  ; swaps front and back buffer.
 5019:    4C21  B2 7F                   CPL     CURBUFF
 5020:    4C23  80 F4                   SJMP    GP_MAIN
 5021:
 5022:                          ;   the prgoram will not end until you power down the system...
 5023:                          ; --------------------------------------------------------------------
 5024:                          ;       GAMEPLAY ROUTINE
 5025:                          ; --------------------------------------------------------------------
 5026:    4C25  75 D0 10        rGAMELOOP:      MOV     PSW,    #GAMEBANK
 5027:          N        02             USING   GAMEBANK/8
 5028:
 5029:                                  ; # timer management
 5030:    4C28  12 4C 62                CALL    rUPDATE_TIMER
 5031:
 5032:                                  ; # sound management
 5033:
 5034:
 5035:                                  ; # input procedure             CONTROLLER
 5036:    4C2B  12 4C B2                CALL    rPREPROCESS_INPUT
 5037:    4C2E  85 30 82                MOV     DPL,    CS_INPUTPR
 5038:    4C31  85 31 83                MOV     DPH,    CS_INPUTPR + 1
 5039:                                  DCALL   DPTR
 5040+ 1  4C34  74 3F                   MOV     A,      #LOW(??0030)
 5041+ 1  4C36  C0 E0                   PUSH    ACC
 5042+ 1  4C38  74 4C                   MOV     A,      #HIGH(??0030)
 5043+ 1  4C3A  C0 E0                   PUSH    ACC
 5044+ 1  4C3C  74 00                   MOV     A,      #0
 5045+ 1  4C3E  73                      JMP     @A+DPTR
 5046+ 1  4C3F                  ??0030:
 5047:
 5048:                                  ; # update gameplay             MODEL
 5049:    4C3F  85 32 82                MOV     DPL,    CS_UPDATE
 5050:    4C42  85 33 83                MOV     DPH,    CS_UPDATE + 1
 5051:                                  DCALL   DPTR
 5052+ 1  4C45  74 50                   MOV     A,      #LOW(??0031)
 5053+ 1  4C47  C0 E0                   PUSH    ACC
 5054+ 1  4C49  74 4C                   MOV     A,      #HIGH(??0031)
 5055+ 1  4C4B  C0 E0                   PUSH    ACC
 5056+ 1  4C4D  74 00                   MOV     A,      #0
 5057+ 1  4C4F  73                      JMP     @A+DPTR
 5058+ 1  4C50                  ??0031:
 5059:
 5060:                                  ; # draw call           VIEW
 5061:    4C50  85 34 82                MOV     DPL,    CS_DRAW
 5062:    4C53  85 35 83                MOV     DPH,    CS_DRAW + 1
 5063:                                  DCALL   DPTR
 5064+ 1  4C56  74 61                   MOV     A,      #LOW(??0032)
 5065+ 1  4C58  C0 E0                   PUSH    ACC
 5066+ 1  4C5A  74 4C                   MOV     A,      #HIGH(??0032)
 5067+ 1  4C5C  C0 E0                   PUSH    ACC
 5068+ 1  4C5E  74 00                   MOV     A,      #0
 5069+ 1  4C60  73                      JMP     @A+DPTR
 5070+ 1  4C61                  ??0032:
 5071:
 5072:    4C61  22                      RET
 5073:                          ; --------------------------------------------------------------------
 5074:                          ;
 5075:                          ; @SPECMAIN     UPDATE_TIMER(VOID)
 5076:                          ;
 5077:                          ; --------------------------------------------------------------------
 5078:                          ; This specified procedure iterates each timer instances and update it all.
 5079:    4C62                  rUPDATE_TIMER:
 5080:          N        02             USING   GAMEBANK/8
 5081:                                  ; Short timer location
 5082:                                  LDCDWP2 R1,     TCNT
 5083+ 1                                MOVP2           #HIGH(TCNT)
 5084+ 2  4C62  75 36 12                MOV     GLB_P2CACHE,#HIGH(TCNT)
 5085+ 2  4C65  75 A0 12                MOV     P2,     #HIGH(TCNT)
 5086+ 1  4C68  79 00                   MOV     R1,     #LOW(TCNT)
 5087:
 5088:                                  ; Of number of timers...
 5089:    4C6A  7A 04                   MOV     R2,     #4
 5090:    4C6C                  UPDATE_TIMER_NEXT:
 5091:                          ; Visit each short timers and decrease items which are not zero.
 5092:    4C6C  E3                      MOVX    A,      @R1
 5093:    4C6D  09                      INC     R1
 5094:                                  ; Zero value indicates it is not a running timer.
 5095:    4C6E  70 07                   JNZ     UPDATE_TIMER_UPDATE
 5096:    4C70  E3                      MOVX    A,      @R1
 5097:    4C71  70 04                   JNZ     UPDATE_TIMER_UPDATE
 5098:                                  ; Find next timer
 5099:    4C73                  UPDATE_TIMER_TO_NEXT:
 5100:    4C73  09                      INC     R1
 5101:    4C74  DA F6                   DJNZ    R2,     UPDATE_TIMER_NEXT
 5102:    4C76  22                      RET
 5103:    4C77                  UPDATE_TIMER_UPDATE:
 5104:                                  ; Decrease double byte value and store it.
 5105:    4C77  19                      DEC     R1
 5106:
 5107:                                  ; Decreases lower value
 5108:    4C78  E3                      MOVX    A,      @R1
 5109:    4C79  14                      DEC     A
 5110:    4C7A  F3                      MOVX    @R1,    A
 5111:    4C7B  09                      INC     R1
 5112:    4C7C  70 F5                   JNZ     UPDATE_TIMER_TO_NEXT
 5113:                                  ; If A has switched into zero...
 5114:                                  ; Higher value
 5115:    4C7E  E3                      MOVX    A,      @R1
 5116:    4C7F  60 09                   JZ      UPDATE_TIMER_RUN
 5117:    4C81  14                      DEC     A
 5118:    4C82  F3                      MOVX    @R1,    A
 5119:    4C83  19                      DEC     R1
 5120:    4C84  74 FF                   MOV     A,      #0FFH
 5121:    4C86  F3                      MOVX    @R1,    A
 5122:    4C87  09                      INC     R1
 5123:    4C88  80 E9                   SJMP    UPDATE_TIMER_TO_NEXT
 5124:
 5125:    4C8A                  UPDATE_TIMER_RUN:
 5126:    4C8A  19                      DEC     R1
 5127:                                  ; @CALL CALLBACK
 5128:                                  ; Cache locals
 5129:    4C8B  C0 11                   PUSH    AR1
 5130:    4C8D  C0 12                   PUSH    AR2
 5131:                                  PUSHP2
 5132+ 1  4C8F  C0 36                   PUSH    GLB_P2CACHE
 5133:                                  ; Adds offset to find callback location.
 5134:    4C91  74 08                   MOV     A,      #8
 5135:    4C93  29                      ADD     A,      R1
 5136:    4C94  F9                      MOV     R1,     A
 5137:                                  ; Load callback funciton
 5138:    4C95  E3                      MOVX    A,      @R1
 5139:    4C96  F5 82                   MOV     DPL,    A
 5140:    4C98  09                      INC     R1
 5141:    4C99  E3                      MOVX    A,      @R1
 5142:    4C9A  F5 83                   MOV     DPH,    A
 5143:                                  ; Call timer callback
 5144:                                  DCALL   DPTR
 5145+ 1  4C9C  74 A7                   MOV     A,      #LOW(??0033)
 5146+ 1  4C9E  C0 E0                   PUSH    ACC
 5147+ 1  4CA0  74 4C                   MOV     A,      #HIGH(??0033)
 5148+ 1  4CA2  C0 E0                   PUSH    ACC
 5149+ 1  4CA4  74 00                   MOV     A,      #0
 5150+ 1  4CA6  73                      JMP     @A+DPTR
 5151+ 1  4CA7                  ??0033:
 5152:                                  ; Resotre values
 5153:                                  POPP2
 5154+ 1  4CA7  D0 36                   POP     GLB_P2CACHE
 5155+ 1                                PEAKP2  P2
 5156+ 2  4CA9  85 36 A0                MOV     P2,     GLB_P2CACHE
 5157:    4CAC  D0 12                   POP     AR2
 5158:    4CAE  D0 11                   POP     AR1
 5159:    4CB0  80 C1                   SJMP    UPDATE_TIMER_TO_NEXT
 5160:                          ; --------------------------------------------------------------------
 5161:                          ;
 5162:                          ; @SPECMAIN     PREPROCESS_INPUT
 5163:                          ; OUT   R0      BUTTONDN
 5164:                          ; OUT   R1      BUTTONUP
 5165:                          ; OUT   R2      BUTTONHELD
 5166:                          ;
 5167:                          ; --------------------------------------------------------------------
 5168:    4CB2                  rPREPROCESS_INPUT:
 5169:                          ; @Input data of previous frame is stored in PREV_INPUT.
 5170:          N        02             USING   GAMEBANK/8
 5171:
 5172:                          ; R3 = CACHE INPUT
 5173:                          ; R4 = CACHE DELTA VALUE
 5174:
 5175:                          ;       ; If home button pressed, call title session
 5176:    4CB2  90 C0 00                MOV     DPTR,   #INPUTPORT
 5177:                          ;       MOVX    A,      @DPTR
 5178:                          ;       JB      ACC.0,  PREPROCESS_INPUT_MAIN
 5179:                          ;       CALL    rTITLE_SESSION
 5180:                          ;       RET
 5181:                          ;PREPROCESS_INPUT_MAIN:
 5182:                          ; Reads current input from INPUT PORT, and caches it into R3
 5183:    4CB5  E0                      MOVX    A,      @DPTR
 5184:    4CB6  A2 E0                   MOV     C,      ACC.0
 5185:    4CB8  92 97                   MOV     P1.7,   C
 5186:                                  ; Input button will be pulled-up. Changes this via invert.
 5187:    4CBA  F4                      CPL     A
 5188:    4CBB  FB                      MOV     R3,     A
 5189:
 5190:                                  ; @Compares previous input state with current input state,
 5191:                                  ;  then assembles outputs
 5192:                                  ; Finds newly pushed buttons. R4 indicates delta bits
 5193:                                  ;  between previous and current input.
 5194:    4CBC  AC 37                   MOV     R4,     PREV_INPUT
 5195:    4CBE  62 14                   XRL     AR4,    A
 5196:
 5197:                                  ; Newly pushed buttons can be found by AND operation
 5198:                                  ;  between DELTA value and present input.
 5199:    4CC0  5C                      ANL     A,      R4
 5200:    4CC1  F8                      MOV     R0,     A
 5201:
 5202:                                  ; Finds newly released buttons by AND operation
 5203:                                  ;  between DELTA value and previous input.
 5204:    4CC2  E5 37                   MOV     A,      PREV_INPUT
 5205:    4CC4  5C                      ANL     A,      R4
 5206:    4CC5  F9                      MOV     R1,     A
 5207:
 5208:                                  ; Finds held buttons by AND operation between previous
 5209:                                  ;  and current input value.
 5210:    4CC6  EB                      MOV     A,      R3
 5211:    4CC7  55 37                   ANL     A,      PREV_INPUT
 5212:    4CC9  FA                      MOV     R2,     A
 5213:
 5214:                                  ; Assign PREV_INPUT
 5215:    4CCA  8B 37                   MOV     PREV_INPUT,     R3
 5216:
 5217:                                  ; If home button downed, go to ranking or title.
 5218:                                  ; @todo
 5219:    4CCC  88 F0                   MOV     B,      R0
 5220:    4CCE  20 F0 01                JB      B.0,    PREPROCESS_INPUT_HOME
 5221:    4CD1  22                      RET
 5222:    4CD2                  PREPROCESS_INPUT_HOME:
 5223:    4CD2  12 43 D3                CALL    rTITLE_SESSION
 5224:    4CD5  22                      RET
 5225:                          ; --------------------------------------------------------------------
 5226:                          ; RESOURCE DATA
 5227:                          ; --------------------------------------------------------------------
 5228:                          $include        (res.image.inc)
 5229: 1
 5230: 1        N      0001     IF      1
 5231: 1  4CD6                  IMG_TITLE:
 5232: 1                        ;       TITLE SCREEN ... MOUNTAIN
 5233: 1  4CD6  10              DB      00010000B
 5234: 1                        ;          |+++.+++.+++.+++|+++.+++.+++.+++|+++.+++.+++.+++|+++.+++.+++.+++|XXX|
 5235: 1  4CD7  11 11 11 11     DB      11H,11H,11H,11H,11H,11H,11H,11H,11H,11H,11H,11H,11H,11H,11H,11H,88H
       1  4CDB  11 11 11 11
       1  4CDF  11 11 11 11
       1  4CE3  11 11 11 11
       1  4CE7  88
 5236: 1  4CE8  11 11 11 11     DB      11H,11H,11H,11H,11H,11H,11H,11H,11H,11H,11H,11H,11H,11H,11H,11H,88H
       1  4CEC  11 11 11 11
       1  4CF0  11 11 11 11
       1  4CF4  11 11 11 11
       1  4CF8  88
 5237: 1  4CF9  11 11 11 11     DB      11H,11H,11H,11H,11H,11H,16H,66H,66H,66H,66H,11H,11H,11H,11H,11H,88H
       1  4CFD  11 11 16 66
       1  4D01  66 66 66 11
       1  4D05  11 11 11 11
       1  4D09  88
 5238: 1  4D0A  11 11 11 11     DB      11H,11H,11H,11H,11H,16H,66H,66H,66H,66H,66H,61H,11H,11H,11H,11H,88H
       1  4D0E  11 16 66 66
       1  4D12  66 66 66 61
       1  4D16  11 11 11 11
       1  4D1A  88
 5239: 1  4D1B  11 11 11 11     DB      11H,11H,11H,11H,11H,66H,66H,66H,44H,44H,46H,66H,61H,11H,11H,12H,88H
       1  4D1F  11 66 66 66
       1  4D23  44 44 46 66
       1  4D27  61 11 11 12
       1  4D2B  88
 5240: 1  4D2C  11 11 11 21     DB      11H,11H,11H,21H,16H,66H,66H,44H,44H,24H,44H,66H,61H,11H,11H,22H,88H
       1  4D30  16 66 66 44
       1  4D34  44 24 44 66
       1  4D38  61 11 11 22
       1  4D3C  88
 5241: 1  4D3D  11 11 12 22     DB      11H,11H,12H,22H,26H,66H,64H,44H,22H,22H,24H,46H,66H,61H,22H,22H,88H
       1  4D41  26 66 64 44
       1  4D45  22 22 24 46
       1  4D49  66 61 22 22
       1  4D4D  88
 5242: 1  4D4E  11 21 22 22     DB      11H,21H,22H,22H,22H,26H,44H,22H,22H,22H,22H,44H,66H,62H,22H,22H,88H
       1  4D52  22 26 44 22
       1  4D56  22 22 22 44
       1  4D5A  66 62 22 22
       1  4D5E  88
 5243: 1  4D5F  12 22 22 22     DB      12H,22H,22H,22H,22H,22H,42H,22H,22H,22H,22H,22H,22H,22H,22H,22H,88H
       1  4D63  22 22 42 22
       1  4D67  22 22 22 22
       1  4D6B  22 22 22 22
       1  4D6F  88
 5244: 1  4D70  22 22 22 22     DB      22H,22H,22H,22H,22H,22H,22H,22H,22H,22H,22H,22H,22H,22H,22H,22H,88H
       1  4D74  22 22 22 22
       1  4D78  22 22 22 22
       1  4D7C  22 22 22 22
       1  4D80  88
 5245: 1  4D81  22 22 22 22     DB      22H,22H,22H,22H,22H,22H,22H,22H,22H,22H,22H,22H,22H,22H,22H,22H,88H
       1  4D85  22 22 22 22
       1  4D89  22 22 22 22
       1  4D8D  22 22 22 22
       1  4D91  88
 5246: 1  4D92  22 27 00 07     DB      22H,27H,00H,07H,07H,70H,77H,70H,70H,77H,77H,77H,07H,77H,07H,22H,88H
       1  4D96  07 70 77 70
       1  4D9A  70 77 77 77
       1  4D9E  07 77 07 22
       1  4DA2  88
 5247: 1  4DA3  22 27 07 70     DB      22H,27H,07H,70H,77H,07H,70H,07H,07H,07H,07H,00H,70H,07H,07H,22H,88H
       1  4DA7  77 07 70 07
       1  4DAB  07 07 07 00
       1  4DAF  70 07 07 22
       1  4DB3  88
 5248: 1  4DB4  22 27 70 70     DB      22H,27H,70H,70H,77H,70H,77H,07H,77H,07H,07H,70H,70H,07H,77H,22H,88H
       1  4DB8  77 70 77 07
       1  4DBC  77 07 07 70
       1  4DC0  70 07 77 22
       1  4DC4  88
 5249: 1  4DC5  22 27 07 70     DB      22H,27H,07H,70H,77H,07H,70H,07H,07H,07H,07H,00H,70H,07H,07H,22H,88H
       1  4DC9  77 07 70 07
       1  4DCD  07 07 07 00
       1  4DD1  70 07 07 22
       1  4DD5  88
 5250: 1  4DD6  22 27 07 07     DB      22H,27H,07H,07H,07H,07H,77H,77H,07H,07H,07H,77H,07H,77H,07H,22H,88H
       1  4DDA  07 07 77 77
       1  4DDE  07 07 07 77
       1  4DE2  07 77 07 22
       1  4DE6  88
 5251: 1
 5252: 1                        ;       HEADER:
 5253: 1                        ;       {VOID_BE_BLANK, NOUSE, NOUSE, {5{VERTICAL_SIZE}}}
 5254: 1                        ;       COLOR:
 5255: 1                        ;       0 VOID, 1 BLUE, 2 GREEN, 3 CYAN, 4 RED, 5 MAGENTA, 6 YELLOW, 7 WHITE
 5256: 1                        ;       8 LINE END
 5257: 1                        ;       . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
 5258: 1                        ;       5 1 5 5 5 5 5 5 5 5 5 5 5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
 5259: 1                        ;       5 1 5 5 5 5 5 5 5 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1
 5260: 1                        ;       5 1 5 5 5 5 1 1 1 1 1 1 1 6 6 6 6 6 6 6 6 6 1 1 1 1 1 1 1 1 1 1
 5261: 1                        ;       1 1 1 1 1 1 1 1 1 1 1 6 6 6 6 6 6 6 6 6 6 6 6 1 1 1 1 1 1 1 1 1
 5262: 1                        ;       1 1 1 1 1 1 1 1 1 1 6 6 6 6 6 6 4 4 4 4 4 6 6 6 6 1 1 1 1 1 1 2
 5263: 1                        ;       1 1 1 1 1 1 2 1 1 6 6 6 6 6 4 4 4 4 2 4 4 4 6 6 6 1 1 1 1 1 2 2
 5264: 1                        ;       1 1 1 1 1 2 2 2 2 6 6 6 6 4 4 4 2 2 2 2 2 4 4 6 6 6 6 1 2 2 2 2
 5265: 1                        ;       1 1 2 1 2 2 2 2 2 2 2 6 4 4 2 2 2 2 2 2 2 2 4 4 6 6 6 2 2 2 2 2
 5266: 1                        ;       1 2 2 2 2 2 2 2 2 2 2 2 4 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
 5267: 1                        ;       2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
 5268: 1                        ;       2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2
 5269: 1                        ;       2 2 0 7 0 0 0 7 0 7 7 0 7 7 7 0 7 0 7 7 7 7 7 7 0 7 7 7 0 7 2 2
 5270: 1                        ;       2 2 0 7 0 7 7 0 7 7 0 7 7 0 0 7 0 7 0 7 0 7 0 0 7 0 0 7 0 7 2 2
 5271: 1                        ;       2 2 0 7 7 0 7 0 7 7 7 0 7 7 0 7 7 7 0 7 0 7 7 0 7 0 0 7 7 7 2 2
 5272: 1                        ;       2 2 0 7 0 7 7 0 7 7 0 7 7 0 0 7 0 7 0 7 0 7 0 0 7 0 0 7 0 7 2 2
 5273: 1                        ;       2 2 0 7 0 7 0 7 0 7 0 7 7 7 7 7 0 7 0 7 0 7 7 7 0 7 7 7 0 7 2 2
 5274: 1
 5275: 1                        ;       . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
 5276: 1                        ;       0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 5277: 1                        ;       0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 5278: 1                        ;       0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 5279: 1                        ;       0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 5280: 1                        ;       0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 5281: 1                        ;       0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 5282: 1                        ;       0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 5283: 1                        ;       0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 5284: 1                        ;       0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 5285: 1                        ;       0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 5286: 1                        ;       0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 5287: 1                        ;       0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 5288: 1                        ;       0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 5289: 1                        ;       0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 5290: 1                        ;       0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 5291: 1                        ;       0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 5292: 1                        ENDIF
 5293:                          $include        (res.ascii.inc)
 5294: 1
 5295: 1  4DE7                  ASCII:
 5296: 1                        ; SP, !, ", #, $, %, &, '
 5297: 1  4DE7  00 00 00        DB      0, 0, 0         ; SPACE
 5298: 1  4DEA  66 66 06        DB      66h, 66h, 06h   ; !
 5299: 1  4DED  55 55 A0        DB      55h, 55h, 0A0H  ; "
 5300: 1  4DF0  00 00 00        DB      0, 0, 0         ; #
 5301: 1  4DF3  00 00 00        DB      0, 0, 0         ; $
 5302: 1  4DF6  00 00 00        DB      0, 0, 0         ; %
 5303: 1  4DF9  00 00 00        DB      0, 0, 0         ; &
 5304: 1  4DFC  44 80 00        DB      44H, 80H, 0             ; '
 5305: 1                        ; (, ), *, +, `, -, ., /
 5306: 1  4DFF  42 22 24        DB      42H, 22H, 24H   ; (
 5307: 1  4E02  24 44 42        DB      24H, 44H, 42H   ; )
 5308: 1  4E05  00 A4 A0        DB      00H, 0A4H, 0A0H ; *
 5309: 1  4E08  00 4E 40        DB      00H, 4EH, 40H   ; +
 5310: 1  4E0B  00 00 00        DB      0, 0, 0         ; `
 5311: 1  4E0E  00 0E 00        DB      00H, 0EH, 00H   ; -
 5312: 1  4E11  00 00 CC        DB      00H, 00H, 0CCH  ; .
 5313: 1  4E14  12 24 48        DB      12H, 24H, 48H   ; /
 5314: 1  4E17                  ASCII_NUM: ; where the letter offset begins
 5315: 1                        ; 0 1 2 3 4 5 6 7 8 9 :
 5316: 1
 5317: 1                        ; . 0 0 .   >--* MSB
 5318: 1                        ; 0 . . 0   *-->  LSB
 5319: 1                        ; 0 . 0 0
 5320: 1                        ; 0 0 . 0
 5321: 1                        ; 0 . . 0
 5322: 1                        ; . 0 0 .
 5323: 1  4E17  69 BD 96        DB      069H, 0BDH, 96H ; 0
 5324: 1
 5325: 1                        ; . 1 1 .   >--* MSB
 5326: 1                        ; 1 . 1 .   *-->  LSB
 5327: 1                        ; . . 1 .
 5328: 1                        ; . . 1 .
 5329: 1                        ; . . 1 .
 5330: 1                        ; . 1 1 1
 5331: 1  4E1A  6A 22 2F        DB      6AH, 22H, 2FH
 5332: 1
 5333: 1                        ; . 2 2 .   >--* MSB
 5334: 1                        ; 2 . . 2   *-->  LSB
 5335: 1                        ; . . . 2
 5336: 1                        ; . . 2 .
 5337: 1                        ; . 2 . .
 5338: 1                        ; 2 2 2 2
 5339: 1  4E1D  69 12 4F        DB      69H, 12H, 4FH
 5340: 1
 5341: 1                        ; . 3 3 .   >--* MSB
 5342: 1                        ; 3 . . 3   *-->  LSB
 5343: 1                        ; . . 3 .
 5344: 1                        ; . . . 3
 5345: 1                        ; 3 . . 3
 5346: 1                        ; . 3 3 .
 5347: 1  4E20  69 21 96        DB      69H, 21H, 96H
 5348: 1
 5349: 1                        ; . . 4 .   >--* MSB
 5350: 1                        ; . 4 4 .   *-->  LSB
 5351: 1                        ; 4 . 4 .
 5352: 1                        ; 4 4 4 4
 5353: 1                        ; . . 4 .
 5354: 1                        ; . . 4 .
 5355: 1  4E23  26 AF 22        DB      26H, 0AFH, 22H
 5356: 1
 5357: 1                        ; 5 5 5 5   >--* MSB
 5358: 1                        ; 5 . . .   *-->  LSB
 5359: 1                        ; 5 5 5 .
 5360: 1                        ; . . . 5
 5361: 1                        ; . . . 5
 5362: 1                        ; 5 5 5 .
 5363: 1  4E26  F8 E1 1E        DB      0F8H, 0E1H, 1EH
 5364: 1
 5365: 1                        ; . 6 . .   >--* MSB
 5366: 1                        ; 6 . . .   *-->  LSB
 5367: 1                        ; 6 6 6 .
 5368: 1                        ; 6 . . 6
 5369: 1                        ; 6 . . 6
 5370: 1                        ; . 6 6 .
 5371: 1  4E29  48 E9 96        DB      48H, 0E9H, 96H
 5372: 1
 5373: 1                        ; 7 7 7 7   >--* MSB
 5374: 1                        ; 7 . . 7   *-->  LSB
 5375: 1                        ; . . 7 .
 5376: 1                        ; . . 7 .
 5377: 1                        ; . 7 . .
 5378: 1                        ; . 7 . .
 5379: 1  4E2C  F9 22 44        DB      0F9H, 22H, 44H
 5380: 1
 5381: 1                        ; . 8 8 .   >--* MSB
 5382: 1                        ; 8 . . 8   *-->  LSB
 5383: 1                        ; . 8 8 .
 5384: 1                        ; 8 . . 8
 5385: 1                        ; 8 . . 8
 5386: 1                        ; . 8 8 .
 5387: 1  4E2F  69 69 96        DB      69H, 69H, 96H
 5388: 1
 5389: 1                        ; . 9 9 .   >--* MSB
 5390: 1                        ; 9 . . 9   *-->  LSB
 5391: 1                        ; . 9 9 9
 5392: 1                        ; . . . 9
 5393: 1                        ; . . 9 .
 5394: 1                        ; . 9 . .
 5395: 1  4E32  69 71 24        DB      69H, 71H, 24H
 5396: 1
 5397: 1                        ; . . . .   >--* MSB
 5398: 1                        ; . 0 . .   *-->  LSB
 5399: 1                        ; . 0 . .
 5400: 1                        ; . . . .
 5401: 1                        ; . 0 . .
 5402: 1                        ; . 0 . .
 5403: 1  4E35  04 40 44        DB      04H, 40H, 44H
 5404: 1                        ; ; < = > ? @ A B C D E
 5405: 1                        ; F G H I J K L M N O P
 5406: 1                        ; Q R S T U V W X Y Z [
 5407: 1  4E38  N      000C     DS      12
 5408: 1
 5409: 1                        ; . ? ? .   >--* MSB
 5410: 1                        ; ? . . ?   *-->  LSB
 5411: 1                        ; . . ? .
 5412: 1                        ; . ? . .
 5413: 1                        ; . . . .
 5414: 1                        ; . ? . .
 5415: 1  4E44  69 24 04        DB      69H, 24H, 04H
 5416: 1  4E47  N      0003     DS      3
 5417: 1
 5418: 1                        ; . A A .   >--* MSB
 5419: 1                        ; A . . A   *-->  LSB
 5420: 1                        ; A . . A
 5421: 1                        ; A A A A
 5422: 1                        ; A . . A
 5423: 1                        ; A . . A
 5424: 1  4E4A  69 9F 99        DB      01101001B,10011111B,10011001B
 5425: 1
 5426: 1                        ; B B B .   >--* MSB
 5427: 1                        ; B . . B   *-->  LSB
 5428: 1                        ; B B B .
 5429: 1                        ; B . . B
 5430: 1                        ; B . . B
 5431: 1                        ; B B B .
 5432: 1  4E4D  E9 E9 9E        DB      11101001B, 11101001B, 10011110B
 5433: 1
 5434: 1                        ; . C C C   >--* MSB
 5435: 1                        ; C . . .   *-->  LSB
 5436: 1                        ; C . . .
 5437: 1                        ; C . . .
 5438: 1                        ; C . . .
 5439: 1                        ; . C C C
 5440: 1  4E50  78 88 87        DB      01111000B, 10001000B, 10000111B
 5441: 1
 5442: 1                        ; D D D .   >--* MSB
 5443: 1                        ; D . . D   *-->  LSB
 5444: 1                        ; D . . D
 5445: 1                        ; D . . D
 5446: 1                        ; D . . D
 5447: 1                        ; D D D .
 5448: 1  4E53  E9 99 9E        DB      11101001B, 10011001B, 10011110B
 5449: 1
 5450: 1                        ; E E E E   >--* MSB
 5451: 1                        ; E . . .   *-->  LSB
 5452: 1                        ; E E E .
 5453: 1                        ; E . . .
 5454: 1                        ; E . . .
 5455: 1                        ; E E E E
 5456: 1  4E56  F8 E8 8F        DB      11111000B, 11101000B, 10001111B
 5457: 1
 5458: 1
 5459: 1                        ; F F F F   >--* MSB
 5460: 1                        ; F . . .   *-->  LSB
 5461: 1                        ; F F F .
 5462: 1                        ; F . . .
 5463: 1                        ; F . . .
 5464: 1                        ; F . . .
 5465: 1  4E59  E8 E8 88        DB      11101000B, 11101000B, 10001000B
 5466: 1
 5467: 1                        ; . G G .   >--* MSB
 5468: 1                        ; G . . G   *-->  LSB
 5469: 1                        ; G . . .
 5470: 1                        ; G . G G
 5471: 1                        ; G . . G
 5472: 1                        ; . G G .
 5473: 1  4E5C  69 8B 96        DB      69H, 10001011B, 96H
 5474: 1
 5475: 1                        ; H . . H   >--* MSB
 5476: 1                        ; H . . H   *-->  LSB
 5477: 1                        ; H H H H
 5478: 1                        ; H . . H
 5479: 1                        ; H . . H
 5480: 1                        ; H . . H
 5481: 1  4E5F  99 F9 99        DB      99H, 11111001B, 99H
 5482: 1
 5483: 1                        ; I I I .   >--* MSB
 5484: 1                        ; . I . .   *-->  LSB
 5485: 1                        ; . I . .
 5486: 1                        ; . I . .
 5487: 1                        ; . I . .
 5488: 1                        ; I I I .
 5489: 1  4E62  E4 44 4E        DB      11100100B,      44H,    4EH
 5490: 1
 5491: 1                        ; J J J J   >--* MSB
 5492: 1                        ; . . J .   *-->  LSB
 5493: 1                        ; . . J .
 5494: 1                        ; . . J .
 5495: 1                        ; J . J .
 5496: 1                        ; J J . .
 5497: 1  4E65  F2 22 AC        DB      11110010B,      22H,    10101100B
 5498: 1
 5499: 1                        ; K . . K   >--* MSB
 5500: 1                        ; K . K .   *-->  LSB
 5501: 1                        ; K K . .
 5502: 1                        ; K . K .
 5503: 1                        ; K . . K
 5504: 1                        ; K . . K
 5505: 1  4E68  9A CA 99        DB      10011010B,      11001010B,      10011001B
 5506: 1
 5507: 1                        ; L . . .   >--* MSB
 5508: 1                        ; L . . .   *-->  LSB
 5509: 1                        ; L . . .
 5510: 1                        ; L . . .
 5511: 1                        ; L . . .
 5512: 1                        ; L L L L
 5513: 1  4E6B  88 88 8F        DB      88H,    88H,    8FH
 5514: 1
 5515: 1                        ; M M M M   >--* MSB
 5516: 1                        ; M M . M   *-->  LSB
 5517: 1                        ; M M . M
 5518: 1                        ; M M . M
 5519: 1                        ; M M . M
 5520: 1                        ; M M . M
 5521: 1  4E6E  FD DD DD        DB      0FDH,   0DDH,   0DDH
 5522: 1
 5523: 1
 5524: 1                        ; N . . N   >--* MSB
 5525: 1                        ; N N . N   *-->  LSB
 5526: 1                        ; N . N N
 5527: 1                        ; N . . N
 5528: 1                        ; N . . N
 5529: 1                        ; N . . N
 5530: 1  4E71  9D B9 99        DB      9DH,    0B9H,   99H
 5531: 1
 5532: 1
 5533: 1                        ; . O O .   >--* MSB
 5534: 1                        ; O . . O   *-->  LSB
 5535: 1                        ; O . . O
 5536: 1                        ; O . . O
 5537: 1                        ; O . . O
 5538: 1                        ; . O O .
 5539: 1  4E74  69 99 96        DB      69H,    99H,    96H
 5540: 1
 5541: 1                        ; P P P .   >--* MSB
 5542: 1                        ; P . . P   *-->  LSB
 5543: 1                        ; P . . P
 5544: 1                        ; P P P .
 5545: 1                        ; P . . .
 5546: 1                        ; P . . .
 5547: 1  4E77  E9 9E 88        DB      0E9H,   9EH,    88H
 5548: 1
 5549: 1                        ; . Q Q .   >--* MSB
 5550: 1                        ; Q . . Q   *-->  LSB
 5551: 1                        ; Q . . Q
 5552: 1                        ; Q . . Q
 5553: 1                        ; . Q Q .
 5554: 1                        ; . . . Q
 5555: 1  4E7A  69 99 61        DB      69H,    99H,    61H
 5556: 1
 5557: 1                        ; R R R .   >--* MSB
 5558: 1                        ; R . . R   *-->  LSB
 5559: 1                        ; R R R .
 5560: 1                        ; R . . R
 5561: 1                        ; R . . R
 5562: 1                        ; R . . R
 5563: 1  4E7D  E9 E9 99        DB      0E9H,   0E9H,   99H
 5564: 1
 5565: 1                        ; . S S .   >--* MSB
 5566: 1                        ; S . . S   *-->  LSB
 5567: 1                        ; . S . .
 5568: 1                        ; . . S S
 5569: 1                        ; S . . S
 5570: 1                        ; . S S .
 5571: 1  4E80  69 43 96        DB      69H,    43H,    96H
 5572: 1
 5573: 1                        ; T T T .   >--* MSB
 5574: 1                        ; . T . .   *-->  LSB
 5575: 1                        ; . T . .
 5576: 1                        ; . T . .
 5577: 1                        ; . T . .
 5578: 1                        ; . T . .
 5579: 1  4E83  E4 44 44        DB      11100100B,      01000100B,      01000100B
 5580: 1
 5581: 1                        ; U . . U   >--* MSB
 5582: 1                        ; U . . U   *-->  LSB
 5583: 1                        ; U . . U
 5584: 1                        ; U . . U
 5585: 1                        ; U . . U
 5586: 1                        ; . U U .
 5587: 1  4E86  99 99 96        DB      99H,    99H,    96H
 5588: 1
 5589: 1                        ; . . . V   >--* MSB
 5590: 1                        ; V . . V   *-->  LSB
 5591: 1                        ; V . . V
 5592: 1                        ; . V . V
 5593: 1                        ; . . V V
 5594: 1                        ; . . . V
 5595: 1  4E89  19 95 31        DB      19H,    95H,    31H
 5596: 1
 5597: 1                        ; W . . W   >--* MSB
 5598: 1                        ; W W . W   *-->  LSB
 5599: 1                        ; W W . W
 5600: 1                        ; W W . W
 5601: 1                        ; W W . W
 5602: 1                        ; W W W .
 5603: 1  4E8C  9D DD DE         DB     9DH,    0DDH,   0DEH
 5604: 1
 5605: 1                        ; X . . X   >--* MSB
 5606: 1                        ; X . . X   *-->  LSB
 5607: 1                        ; . X X .
 5608: 1                        ; . X X .
 5609: 1                        ; X . . X
 5610: 1                        ; X . . X
 5611: 1  4E8F  99 66 99        DB      99H,    66H,    099H
 5612: 1
 5613: 1                        ; Y . . Y   >--* MSB
 5614: 1                        ; Y . Y .   *-->  LSB
 5615: 1                        ; . Y . .
 5616: 1                        ; . Y . .
 5617: 1                        ; . Y . .
 5618: 1                        ; . Y . .
 5619: 1  4E92  9A 44 44        DB      9AH,    44H,    44H
 5620: 1
 5621: 1                        ; Z Z Z Z   >--* MSB
 5622: 1                        ; . . . Z   *-->  LSB
 5623: 1                        ; Z . Z .
 5624: 1                        ; . Z Z Z
 5625: 1                        ; Z . . .
 5626: 1                        ; Z Z Z Z
 5627: 1  4E95  F1 A7 8F        DB      0F1H,   0A7H,   8FH
 5628: 1
 5629: 1                        ; [ [ . .   ---
 5630: 1                        ; [ . . .
 5631: 1                        ; [ . . .
 5632: 1                        ; [ . . .
 5633: 1                        ; [ . . .
 5634: 1                        ; [ [ . .
 5635: 1                        ; \ ] ^ _ ` a b c d e f
 5636: 1                        ; g h i j k l m n o p q
 5637: 1                        ; r s t u v w x y z
 5638: 1  4E98  N      0012     DS      18
 5639: 1
 5640: 1                        ; . . . .   ---
 5641: 1                        ; . a a .
 5642: 1                        ; . . . a
 5643: 1                        ; . a a a
 5644: 1                        ; a . . a
 5645: 1                        ; . a a a
 5646: 1
 5647: 1                        ; . . . .   ---
 5648: 1                        ; b . . .
 5649: 1                        ; b . . .
 5650: 1                        ; b b b .
 5651: 1                        ; b   . b
 5652: 1                        ; . b b .
 5653: 1
 5654: 1                        ; . . . .   ---
 5655: 1                        ; . . . .
 5656: 1                        ; . c c .
 5657: 1                        ; c . . .
 5658: 1                        ; c . . .
 5659: 1                        ; . c c .
 5660: 1
 5661: 1                        ; . . . .   ---
 5662: 1                        ; . . . d
 5663: 1                        ; . . . d
 5664: 1                        ; . d d d
 5665: 1                        ; d . . d
 5666: 1                        ; . d d .
 5667: 1
 5668: 1                        ; . . . .   ---
 5669: 1                        ; . e e .
 5670: 1                        ; e . . e
 5671: 1                        ; e e e .
 5672: 1                        ; e . . .
 5673: 1                        ; . e e .
 5674: 1
 5675: 1                        ; . . f f   ---
 5676: 1                        ; . f . .
 5677: 1                        ; f f f f
 5678: 1                        ; . f . .
 5679: 1                        ; . f . .
 5680: 1                        ; . f . .
 5681: 1
 5682: 1                        ; . . . .   ---
 5683: 1                        ; . g g .
 5684: 1                        ; g . . g
 5685: 1                        ; . g g g
 5686: 1                        ; . . . g
 5687: 1                        ; . g g .
 5688: 1
 5689: 1                        ; . . . . . ---
 5690: 1                        ; h       .
 5691: 1                        ; h       .
 5692: 1                        ; h       .
 5693: 1                        ; h h h   .
 5694: 1                        ; h     h .
 5695: 1                        ; h     h .
 5696: 1                        ; . . . . .
 5697: 1                        ; . . . . . ---
 5698: 1                        ;         .
 5699: 1                        ;   i i   .
 5700: 1                        ;         .
 5701: 1                        ;   i i   .
 5702: 1                        ;   i     .
 5703: 1                        ;   i     .
 5704: 1                        ; . . . . .
 5705: 1                        ; . . . . . ---
 5706: 1                        ;   j j   .
 5707: 1                        ;         .
 5708: 1                        ;   j j   .
 5709: 1                        ;     j   .
 5710: 1                        ; j   j   .
 5711: 1                        ;   j j   .
 5712: 1                        ; . . . . .
 5713: 1                        ; . . . . . ---
 5714: 1                        ;         .
 5715: 1                        ; k       .
 5716: 1                        ; k   k   .
 5717: 1                        ; k k     .
 5718: 1                        ; k   k   .
 5719: 1                        ; k     k .
 5720: 1                        ; . . . . .
 5721: 1                        ; . . . . . ---
 5722: 1                        ;     l   .
 5723: 1                        ;   l     .
 5724: 1                        ;   l     .
 5725: 1                        ;   l     .
 5726: 1                        ;   l     .
 5727: 1                        ; l l     .
 5728: 1                        ; . . . . .
 5729: 1                        ; . . . . . ---
 5730: 1                        ;         .
 5731: 1                        ;         .
 5732: 1                        ;         .
 5733: 1                        ; m m m   .
 5734: 1                        ; m m   m .
 5735: 1                        ; m m   m .
 5736: 1                        ; . . . . .
 5737: 1                        ; . . . . . ---
 5738: 1                        ;         .
 5739: 1                        ;         .
 5740: 1                        ;         .
 5741: 1                        ; n n     .
 5742: 1                        ; n   n   .
 5743: 1                        ; n   n   .
 5744: 1                        ; . . . . .
 5745: 1                        ; . . . . . ---
 5746: 1                        ;         .
 5747: 1                        ;         .
 5748: 1                        ;   o o   .
 5749: 1                        ; o     o .
 5750: 1                        ; o     o .
 5751: 1                        ;   o o   .
 5752: 1                        ; . . . . .
 5753: 1                        ; . . . . . ---
 5754: 1                        ;         .
 5755: 1                        ;   p p   .
 5756: 1                        ; p     p .
 5757: 1                        ; p p p   .
 5758: 1                        ; p       .
 5759: 1                        ; p       .
 5760: 1                        ; . . . . .
 5761: 1                        ; . . . . . ---
 5762: 1                        ;         .
 5763: 1                        ;   q q   .
 5764: 1                        ; q   q   .
 5765: 1                        ; q q q   .
 5766: 1                        ;     q   .
 5767: 1                        ;       q .
 5768: 1                        ; . . . . .
 5769: 1                        ; . . . . . ---
 5770: 1                        ;         .
 5771: 1                        ;         .
 5772: 1                        ; r   r r .
 5773: 1                        ; r r     .
 5774: 1                        ; r       .
 5775: 1                        ; r       .
 5776: 1                        ; . . . . .
 5777: 1                        ; . . . . . ---
 5778: 1                        ;         .
 5779: 1                        ;   s s s .
 5780: 1                        ; s       .
 5781: 1                        ;   s s   .
 5782: 1                        ;       s .
 5783: 1                        ; s s s   .
 5784: 1                        ; . . . . .
 5785: 1                        ; . . . . . ---
 5786: 1                        ;         .
 5787: 1                        ;         .
 5788: 1                        ;   t     .
 5789: 1                        ; t t t   .
 5790: 1                        ;   t     .
 5791: 1                        ;   t t   .
 5792: 1                        ; . . . . .
 5793: 1                        ; . . . . . ---
 5794: 1                        ;         .
 5795: 1                        ;         .
 5796: 1                        ;         .
 5797: 1                        ; u   u   .
 5798: 1                        ; u   u   .
 5799: 1                        ;   u u u .
 5800: 1                        ; . . . . .
 5801: 1                        ; . . . . . ---
 5802: 1                        ;         .
 5803: 1                        ;         .
 5804: 1                        ;         .
 5805: 1                        ; v   v   .
 5806: 1                        ; v   v   .
 5807: 1                        ;   v     .
 5808: 1                        ; . . . . .
 5809: 1                        ; . . . . . ---
 5810: 1                        ;         .
 5811: 1                        ;         .
 5812: 1                        ;         .
 5813: 1                        ; w w   w .
 5814: 1                        ; w w   w .
 5815: 1                        ; w w w   .
 5816: 1                        ; . . . . .
 5817: 1                        ; . . . . . ---
 5818: 1                        ;         .
 5819: 1                        ;         .
 5820: 1                        ; x   x   .
 5821: 1                        ; x   x   .
 5822: 1                        ;   x     .
 5823: 1                        ; x   x   .
 5824: 1                        ; . . . . .
 5825: 1                        ; . . . . . ---
 5826: 1                        ;         .
 5827: 1                        ;         .
 5828: 1                        ; y   y   .
 5829: 1                        ; y   y   .
 5830: 1                        ;   y     .
 5831: 1                        ;     y   .
 5832: 1                        ; . . . . .
 5833: 1                        ; . . . . . ---
 5834: 1                        ;         .
 5835: 1                        ;         .
 5836: 1                        ; z z z   .
 5837: 1                        ;     z   .
 5838: 1                        ;   z     .
 5839: 1                        ; z z z   .
 5840: 1                        ; . . . . .
 5841:                          ; --------------------------------------------------------------------
 5842:                          ; ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 5843:
 5844:
 5845:                          END





                     register banks used:  1, 2, 3

                     no errors





               L I S T   O F   S Y M B O L S
               =============================


SYMBOL                            TYPE     VALUE        LINE
------------------------------------------------------------
??0000                            CODE      0000         212
??0001                            CODE      0000         222
??0002                            CODE      0000         230
??0003                            CODE      0000         260
??0004                            CODE      0000         267
??0005                            CODE      0000         274
??0006                            CODE      0000         282
??0007                            CODE      0000         292
??0008                            CODE      0000         332
??0009                            CODE      41EC        1362
??0010                            CODE      41F8        1397
??0011                            CODE      4204        1432
??0012                            CODE      4210        1467
??0013                            CODE      4225        1502
??0014                            CODE      4231        1537
??0015                            CODE      423D        1572
??0016                            CODE      4249        1607
??0017                            CODE      42DB        2103
??0018                            CODE      4342        2269
??0019                            CODE      43A6        2362
??0020                            CODE      43D3        2460
??0021                            CODE      442D        2610
??0022                            CODE      4441        2619
??0023                            CODE      4509        2840
??0024                            CODE      49B1        4249
??0025                            CODE      4B87        4864
??0026                            CODE      4B9A        4878
??0027                            CODE      4BAB        4891
??0028                            CODE      4BEC        4948
??0029                            CODE      4BFC        4958
??0030                            CODE      4C3F        5046
??0031                            CODE      4C50        5058
??0032                            CODE      4C61        5070
??0033                            CODE      4CA7        5151
??ASEM_51                         NUMBER    8051
??VERSION                         NUMBER    0130
?IPD                              CODE      4905        4069
?IPD0                             CODE      4908        4070
?IPL                              CODE      48F3        4059
?IPN                              CODE      48EC        4054
?IPR                              CODE      48FC        4064
?IPU                              CODE      490F        4075
?IPU_VALID                        CODE      493F        4107
?IPU_VALID_0                      CODE      4949        4115
?IPU_VALID_OTHER                  CODE      4935        4098
AC                                BIT         D6
ACC                               DATA        E0
ADDBLKRELC                        MACRO                 3036
ADDSCORE_LP                       CODE      43C7        2410
ASCII                             CODE      4DE7        5295
ASCII_NUM                         CODE      4E17        5314
B                                 DATA        F0
BACKBUFFER                        REGISTER    R7        3685
BANK2                             NUMBER    0018         381
BIT_                              NUMBER    0006        2751
BIT_A                             NUMBER    0004        2749
BIT_B                             NUMBER    0005        2750
BIT_D                             NUMBER    0001        2746
BIT_HOME                          NUMBER    0007        2752
BIT_L                             NUMBER    0003        2748
BIT_R                             NUMBER    0002        2747
BIT_U                             NUMBER    0000        2745
BLKTODISP                         MACRO                 3019
BLSHAPE                           REGISTER    R7        3247
BLTOVOID                          NUMBER    00D5        1041
BR0                               NUMBER    0020         367
BR1                               NUMBER    0021         368
BR2                               NUMBER    0022         369
BR3                               NUMBER    0023         370
BR4                               NUMBER    0024         371
BR5                               NUMBER    0025         372
BR6                               NUMBER    0026         373
BR7                               NUMBER    0027         374
BTN0                              NUMBER    0001         387
BTN1                              NUMBER    0002         388
BTN2                              NUMBER    0004         389
BTN3                              NUMBER    0008         390
BTN4                              NUMBER    0010         391
BTN5                              NUMBER    0020         392
BTN6                              NUMBER    0040         393
BTN7                              NUMBER    0080         394
BUFFER_BACK_0                     CODE      4289        1736
BUFFER_FRONT_0                    CODE      4280        1717
CACHE                             REGISTER    R3         829
CHECKBOUND_EXT                    CODE      4575        3173
CHECKBOUND_FOREACH                CODE      4556        3142
CHECKBOUND_LINKS                  CODE      4554        3139
CHECKBOUND_YVALID                 CODE      457A        3179
CHECKBOUND_YVALID1                CODE      458D        3193
CHECKBOUND_YVALID2                CODE      4594        3198
CHECKDOT_END                      CODE      45A4        3226
CHECKDOT_FAIL                     CODE      45A2        3224
CJRDRAW                           CODE      4A8C        4562
CJRINIT                           CODE      4A6D        4530
CJRINPUT                          CODE      4AF2        4666
CJRUPDATE                         CODE      49D6        4365
CMAIN_INPUT                       CODE      44B7        2744
COLOR                             REGISTER    R5         830
CONST                             MACRO                  180
COUNT                             REGISTER    R7        1293
CRANKDRAW                         CODE      4342        2276
CRANKINIT                         CODE      4329        2253
CRETURNTOSESSION                  CODE      4380        2332
CS_DRAW                           NUMBER    0034         278
CS_INPUTPR                        NUMBER    0030         264
CS_UPDATE                         NUMBER    0032         271
CTETDNDRAW                        CODE      4746        3680
CTETINIT                          CODE      4709        3626
CTETINPUT                         CODE      48E5        4047
CTETSTDRAW                        CODE      48A1        3981
CTETUPDATE                        CODE      45D7        3302
CTITLE_INIT                       CODE      44FB        2820
CTITLE_STATIC_DRAW                CODE      44ED        2808
CURBUFF                           NUMBER    007F         216
CURIDX                            REGISTER    R6        3248
CURSOR                            NUMBER    200F        2507
CY                                BIT         D7
C_HEAD                            REGISTER    R4        1040
DBGBANK                           NUMBER    0000         376
DCALL                             MACRO                  541
DECLARE_MODULE                    MACRO                   35
DEFINE_MODULE                     MACRO                   30
DELAY_0                           CODE      406A         679
DPH                               DATA        83
DPL                               DATA        82
DP_A                              NUMBER    0092        1754
DP_ASMLOC                         MACRO                  801
DP_B                              NUMBER    0093        1755
DP_C                              NUMBER    0094        1756
DP_CLK                            NUMBER    0090        1752
DP_D                              NUMBER    0095        1757
DP_LAT                            NUMBER    0091        1753
DP_RGBHL                          REGISTER    R1        1758
DRAWBOX_D                         CODE      40AE         876
DRAWBOX_L                         CODE      40D8         918
DRAWBOX_R                         CODE      409F         854
DRAWBOX_X                         CODE      40E3         925
DRAWDOTB_END                      CODE      4278        1698
DRAWDOTB_LOW                      CODE      4271        1693
DRAWDOT_END                       CODE      4266        1665
DRAWDOT_LOW                       CODE      425F        1660
DRAWIMAGE_0                       CODE      4157        1099
DRAWIMAGE_1                       CODE      415E        1104
DRAWIMAGE_2                       CODE      4167        1114
DRAWIMAGE_DONE                    CODE      4171        1124
DRAWIMAGE_DRAW_DOT                CODE      414F        1091
DRAWIMAGE_DRAW_LINE               CODE      4139        1068
DRAWIMAGE_LINE_ENTRY              CODE      4137        1064
DRAWIMAGE_NEXTDOT                 CODE      416E        1120
DRAWSTRING_DONE                   CODE      41A9        1196
DRAWSTRING_DRAW                   CODE      4186        1158
DRAWSTRING_NOSPACE                CODE      418E        1167
DRAWSTRING_STEP                   CODE      419E        1183
EA                                BIT         AF
ERRORBIT                          NUMBER    0092         361
ES                                BIT         AC
ET0                               BIT         A9
ET1                               BIT         AB
EX0                               BIT         A8
EX1                               BIT         AA
EXTI0                             CODE      0003
EXTI1                             CODE      0013
F0                                BIT         D5
F0CACHE                           NUMBER    0001        1151
FILLBOX_HORI                      CODE      40FD         971
FILLBOX_VERT                      CODE      40F9         966
FILLBUFFER_0                      CODE      4088         788
FRAMEBOUND30                      NUMBER    007D         234
FRAMEBOUND60                      NUMBER    007E         226
GAMEBANK                          NUMBER    0010         379
GBIT                              MACRO                  149
GBUFFER1                          NUMBER    1000         203
GBUFFER2                          NUMBER    1100         209
GENBLOCK_ESC                      CODE      45CB        3284
GENBLOCK_LP                       CODE      45BD        3264
GENBLOCK_TABLE                    CODE      45CF        3289
GENBLOCK_VALID                    CODE      45C2        3270
GLBMEM                            MACRO                  102
GLBMEMAT                          MACRO                  110
GLB_P2CACHE                       NUMBER    0036         286
GLOBAL_MEMORY                     NUMBER    1231         100
GPUBANK                           NUMBER    0008         377
GP_MAIN                           CODE      4C19        5013
GP_WAIT                           CODE      4C19        5014
HEAD                              REGISTER    R3        1036
HEAD_C                            NUMBER    001C        1294
HEAD_C0                           REGISTER    R4        1295
HEIGHT                            REGISTER    R2         828
IE                                DATA        A8
IE0                               BIT         89
IE1                               BIT         8B
IMG_TITLE                         CODE      4CD6        5231
INITSCORE0                        CODE      43B1        2379
INPUTPORT                         NUMBER    C000         187
INT0                              BIT         B2
INT1                              BIT         B3
INTMEM                            MACRO                  136
IP                                DATA        B8
IS_SPACE                          NUMBER    0000        1150
IT0                               BIT         88
IT1                               BIT         8A
IUPDATE_DISPLAY                   CODE      428C        1750
JRDRAW_BLKTODISP                  CODE      4ADF        4638
JRDRAW_BOARD_0                    CODE      4AB5        4596
JRDRAW_BOARD_1                    CODE      4AC6        4610
JRINPUT_D                         CODE      4AFF        4677
JRINPUT_L                         CODE      4B06        4681
JRINPUT_R                         CODE      4B0D        4685
JRINPUT_U                         CODE      4AF8        4673
JRINPUT_X                         CODE      4B14        4689
JRUPDATE_BEGIN                    CODE      49DF        4387
JRUPDATE_FILLCURRENT              CODE      4A5C        4508
JRUPDATE_FINDPUTFOOD              CODE      4A2A        4457
JRUPDATE_FOUND                    CODE      4A38        4469
JRUPDATE_INC                      CODE      4A34        4466
JRUPDATE_LIFESPAN                 CODE      4A54        4498
JRUPDATE_NOFOOD                   CODE      4A51        4494
JRUPDATE_NOOVER                   CODE      4A10        4433
JRUPDATE_SCORELP                  CODE      4A42        4481
JRUPDATE_SKIP                     CODE      4A59        4505
JR_BOARD                          NUMBER    2000        4280
JR_DIR                            NUMBER    2101        4292
JR_FOOD                           NUMBER    2103        4304
JR_LVL                            NUMBER    2102        4298
JR_PVT                            NUMBER    2100        4286
JR_TICKS                          NUMBER    2104        4310
LBIT                              MACRO                  169
LBIT_PVT                          MACRO                  160
LCDPORT                           NUMBER    8000         185
LDCDW                             MACRO                  513
LDCDWP2                           MACRO                  506
LEFT                              REGISTER    R5        3249
LINELEFT                          REGISTER    R2        1037
LOCAL_MEMORY                      NUMBER    2105         119
LOCATION                          REGISTER    R1        3211
LOCMEM                            MACRO                  125
LOCMEM_PVT                        MACRO                  121
MAIN                              CODE      4BBD        4917
MAIN_DRAW_1                       CODE      442F        2612
MAIN_DRAW_2                       CODE      4443        2621
MAIN_DRAW_DEFAULT                 CODE      444B        2641
MAIN_DRAW_JIRUNG                  CODE      443A        2618
MAIN_DRAW_SCORE                   CODE      449A        2696
MAIN_DRAW_SWDONE                  CODE      4459        2648
MAIN_DRAW_TETRIS                  CODE      4426        2609
MAIN_GPINIT                       CODE      4BD7        4933
MAIN_INPUT_NEXT                   CODE      44D5        2781
MAIN_INPUT_PREV                   CODE      44E1        2793
MAIN_INPUT_S1                     CODE      44CD        2775
MAIN_INPUT_S2                     CODE      44D4        2779
MAIN_INPUT_SELECT                 CODE      44C2        2767
MAIN_INPUT_STORE                  CODE      44DF        2790
MAIN_TIMER                        CODE      4C0F        4980
MAXCURSOR                         NUMBER    0002        2498
MEMALIGN                          MACRO                  175
MOVP2                             MACRO                  499
MOVW                              MACRO                  555
NEG                               MACRO                  491
NEWPIVOT                          REGISTER    R3        4407
NULLF                             CODE      4B16        4732
OUTPUTPORT                        NUMBER    C000         186
OV                                BIT         D2
P                                 BIT         D0
P0                                DATA        80
P1                                DATA        90
P2                                DATA        A0
P3                                DATA        B0
PCON                              DATA        87
PEAKP2                            MACRO                  520
PIVOT                             REGISTER    R6        3368
POPP2                             MACRO                  532
PREPROCESS_INPUT_HOME             CODE      4CD2        5222
PREV_INPUT                        NUMBER    0037         296
PS                                BIT         BC
PSW                               DATA        D0
PT0                               BIT         B9
PT1                               BIT         BB
PUSHP2                            MACRO                  526
PVNXT                             REGISTER    R2        3115
PX0                               BIT         B8
PX1                               BIT         BA
RADDBLKSEP                        CODE      4056         656
RADDSCORE                         CODE      43BA        2396
RADDSEP                           CODE      401B         571
RANDNUM                           NUMBER    008B         258
RANKDRAW_DTOA                     CODE      4365        2304
RANKING_GAMEINFO                  NUMBER    1220         342
RANKING_HIGHST                    NUMBER    1225         356
RANKING_RECORDEN                  NUMBER    007C         336
RANKING_RETURN                    NUMBER    120A         315
RANKING_SCORE                     NUMBER    1221         348
RANKSTR                           CODE      4339        2268
RB8                               BIT         9A
RBUFFER_BACK                      CODE      4283        1731
RBUFFER_FRONT                     CODE      427A        1712
RD                                BIT         B7
RDELAY                            CODE      4067         678
RDRAWASCII                        CODE      41AE        1219
RDRAWBOX                          CODE      408F         825
RDRAWDOT                          CODE      4256        1649
RDRAWDOTB                         CODE      4268        1682
RDRAWIMAGE                        CODE      4120        1034
RDRAWSTRING                       CODE      417C        1148
RDTOA                             CODE      4041         625
REN                               BIT         9C
RESET                             CODE      0000
RETURNTOSESSION_FINALIZE          CODE      4387        2337
RFILLBOX                          CODE      40EA         946
RFILLBUFFER                       CODE      4073         767
RGAMELOOP                         CODE      4C25        5026
RI                                BIT         98
RINITSCORE                        CODE      43A7        2371
RMAIN_DRAW                        CODE      440F        2590
RMAIN_MENU                        CODE      43F7        2561
RMEMSET                           CODE      402E         594
ROTATE90_0                        CODE      498A        4194
ROTATE90_ISVALID                  CODE      49A5        4220
ROTATE_CACHE                      NUMBER    2140        4178
RPREPROCESS_INPUT                 CODE      4CB2        5168
RS0                               BIT         D3
RS1                               BIT         D4
RSESSION_JIRUNG                   CODE      49B1        4330
RSESSION_TETRIS                   CODE      4517        3065
RSET_TIMER                        CODE      4B17        4746
RTITLE_SESSION                    CODE      43D3        2528
RTORANKING                        CODE      42DB        2160
RTRANSITION                       CODE      4B44        4813
RUPDATE_TIMER                     CODE      4C62        5079
RXD                               BIT         B0
R__DRAWASCII                      CODE      41D7        1289
SBUF                              DATA        99
SCHECKBOUND                       CODE      453B        3112
SCON                              DATA        98
SCRNSELEC                         NUMBER    0000        1038
SET_TIMER_BEGIN                   CODE      4B1F        4754
SET_TIMER_DONE                    CODE      4B40        4788
SET_TIMER_FOUND                   CODE      4B2C        4768
SET_TIMER_NEXT                    CODE      4B26        4763
SGENBLOCK                         CODE      45A5        3236
SINT                              CODE      0023
SM0                               BIT         9F
SM1                               BIT         9E
SM2                               BIT         9D
SP                                DATA        81
SROTATER90                        CODE      497F        4184
SSCHECKDOT                        CODE      4595        3209
STRCACHE                          NUMBER    210C        2271
STRING                            MACRO                  481
T0                                BIT         B4
T1                                BIT         B5
TB8                               BIT         9B
TCALBAKOFST                       NUMBER    1208         308
TCNT                              NUMBER    1200         302
TCON                              DATA        88
TETDNDDRAW_DRAWBLACK              CODE      4879        3945
TETDNDRAW_BRD                     CODE      476E        3712
TETDNDRAW_BRD_AB                  CODE      47D9        3818
TETDNDRAW_BRD_BRD0                CODE      4780        3737
TETDNDRAW_BRD_BRD1                CODE      4782        3739
TETDNDRAW_BRD_ENTRY               CODE      4774        3716
TETDNDRAW_CLR                     CODE      4896        3971
TETDNDRAW_DONE                    CODE      4890        3959
TETDNDRAW_LV                      CODE      4749        3688
TETDNDRAW_NBDONE                  CODE      4880        3950
TETDNDRAW_NBLP                    CODE      486C        3932
TETDNDRAW_NEXT                    CODE      4850        3906
TETDNDRAW_SCORE                   CODE      4814        3867
TETINPUT_CMITMV                   CODE      4974        4151
TETINPUT_END                      CODE      497E        4161
TETINPUT_MVB                      CODE      4955        4127
TETUPDATE_BLOCK_CNT_RESET         CODE      46F4        3604
TETUPDATE_CONTINUE                CODE      46B5        3549
TETUPDATE_FIXING_BLOCK            CODE      4620        3379
TETUPDATE_ON_BLOCK_DOWN           CODE      45EF        3331
TETUPDATE_ON_BLOCK_FIX            CODE      45F9        3342
TETUPDATE_ON_CNT_ZERO             CODE      45E0        3316
TETUPDATE_SCAN                    CODE      463E        3408
TETUPDATE_SCAN_0                  CODE      4640        3412
TETUPDATE_SCAN_1                  CODE      466A        3447
TF0                               BIT         8D
TF1                               BIT         8F
TH0                               DATA        8C
TH1                               DATA        8D
TI                                BIT         99
TIMER0                            CODE      000B
TIMER1                            CODE      001B
TL0                               DATA        8A
TL1                               DATA        8B
TMOD                              DATA        89
TORANKING_0                       CODE      42F2        2185
TORANKING_1                       CODE      430A        2209
TORANKING_DISP                    CODE      4303        2202
TO_MONITOR                        CODE      4BB0        4900
TR0                               BIT         8C
TR1                               BIT         8E
TRANSITION_0                      CODE      4B54        4828
TRANSITION_ASSIGNMENT             CODE      4B62        4838
TT_BLOCKSHAPE                     CODE      4509        3013
TT_BLOCK_COLOR                    CODE      4510        3014
TT_BL_I                           NUMBER    000F        3001
TT_BL_LL                          NUMBER    0017        3003
TT_BL_RL                          NUMBER    0047        3005
TT_BL_S                           NUMBER    0036        3009
TT_BL_SQ                          NUMBER    0066        3011
TT_BL_T                           NUMBER    0027        2999
TT_BL_Z                           NUMBER    0063        3007
TT_BOARD                          NUMBER    2000        2869
TT_BOARDDIRTY                     NUMBER    0079        2975
TT_CB_PVT                         NUMBER    2108        2926
TT_CB_TYPE                        NUMBER    2105        2911
TT_CNTLEFT                        NUMBER    2103        2899
TT_DELAY                          NUMBER    2102        2890
TT_DELLEFT                        NUMBER    2104        2905
TT_DROPBLOCK                      NUMBER    0076        2986
TT_FLGCLR                         NUMBER    0077        2982
TT_HEIGHT                         NUMBER    0010        2957
TT_LEVEL                          NUMBER    2100        2878
TT_LVLDIRTY                       NUMBER    0078        2978
TT_NB_TYPE                        NUMBER    2106        2917
TT_NEXTDIRTY                      NUMBER    007A        2972
TT_NEXT_PIVOT                     NUMBER    0041        3927
TT_PV_BOARD                       NUMBER    0006        2960
TT_PV_LVL                         NUMBER    00E1        2964
TT_PV_NEXT                        NUMBER    0021        2962
TT_PV_SCORE                       NUMBER    0070        2966
TT_SCOREDIRTY                     NUMBER    007B        2969
TT_TMP                            NUMBER    2120        2947
TT_TONEXTLV                       NUMBER    2101        2884
TT_WIDTH                          NUMBER    000A        2955
TUP_COPYL                         CODE      4693        3498
TUP_COPYL_0                       CODE      469B        3509
TUP_COPYL_1                       CODE      46A6        3525
TUP_COPYL_2                       CODE      46B4        3539
TUP_COPYL_3                       CODE      46AE        3534
TUP_SCANL                         CODE      467F        3468
TUP_SCANL_KEEP                    CODE      468E        3490
TUP_SCANL_LP                      CODE      4688        3485
TXD                               BIT         B1
UPDATE_DISPLAY_FRAME_BOUNDARY     CODE      42CD        1832
UPDATE_DISPLAY_LINE               CODE      42AC        1795
UPDATE_TIMER_NEXT                 CODE      4C6C        5090
UPDATE_TIMER_RUN                  CODE      4C8A        5125
UPDATE_TIMER_TO_NEXT              CODE      4C73        5099
UPDATE_TIMER_UPDATE               CODE      4C77        5103
VALID                             NUMBER    00D5        3114
WIDTH                             REGISTER    R1         827
WID_IT                            NUMBER    0015         952
WR                                BIT         B6
_FRAME                            NUMBER    C43B         385
_SSN_BANK                         NUMBER    0018         384
__DRAWASCII_0                     CODE      41DB        1300
__DRAWASCII_DRAWDOT               MACRO                 1312
__INTB_OFST                       NUMBER    007B         147
__INT_OFST                        NUMBER    0038         134
__LB_PIVOT                        NUMBER    007B        2107
__OPT_SIZE__                      NUMBER    0001         397
____GRAPHICS                      NUMBER    0001         436
____GRAPHICS_DEF                  NUMBER    0000         435
____UTILS                         NUMBER    0001         440
____UTILS_DEF                     NUMBER    0000         439
